# docs.chromia.com llms-full.txt

[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ“„ï¸Overview** \\
To write unit tests for Rell code, use test module. You need to use the @test](/rell/tests/overview)[**ğŸ—ƒï¸Rell test namespace** \\
4 items](/category/rell-test-namespace)[**ğŸ“„ï¸Assertions** \\
This topic describes the functions available for making assertions within tests. These functions are used to verify](/rell/tests/assertions)[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ“„ï¸Configure the Chromia bridge client** \\
The Chromia bridge client is a TypeScript library with utilities](/bridge/bridge-client/)[**ğŸ“„ï¸Work with the client** \\
To interact with the Chromia blockchain using the bridge client, you'll need to manage an active Session that handles](/bridge/bridge-client/work-with-client)[**ğŸ“„ï¸Example usage: Bridge from EVM to Chromia and vice versa** \\
Bridge from EVM to Chromia](/bridge/bridge-client/example)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

This topic covers some common troubleshooting steps you can take to identify and resolve problems with your token
bridge.

## Initialization [â€‹](\#initialization "Direct link to Initialization")

#### TokenBridge: validator address is invalid [â€‹](\#tokenbridge-validator-address-is-invalid "Direct link to TokenBridge: validator address is invalid")

- **Error Description:** The validator address cannot be zero (entirely zeros).
- **Solution:** Set a valid, non-zero validator address.

## Ownership [â€‹](\#ownership "Direct link to Ownership")

#### TokenBridge: renounce ownership is not allowed [â€‹](\#tokenbridge-renounce-ownership-is-not-allowed "Direct link to TokenBridge: renounce ownership is not allowed")

- **Error Description:** Renouncing ownership is not permitted.
- **Solution:** Ownership cannot be renounced. Verify the ownership requirements.

## Setting blockchain RID [â€‹](\#setting-blockchain-rid "Direct link to Setting blockchain RID")

#### TokenBridge: blockchain RID is invalid [â€‹](\#tokenbridge-blockchain-rid-is-invalid "Direct link to TokenBridge: blockchain RID is invalid")

- **Error Description:** The blockchain RID cannot be zero (entirely zeros).
- **Solution:** Set a valid, non-zero blockchain RID.

## Token Allowance [â€‹](\#token-allowance "Direct link to Token Allowance")

#### TokenBridge: token address is invalid [â€‹](\#tokenbridge-token-address-is-invalid "Direct link to TokenBridge: token address is invalid")

- **Error Description:** The token address cannot be zero (entirely zeros).
- **Solution:** Verify the token address and ensure it is not zero.

#### TokenBridge: not allowed token [â€‹](\#tokenbridge-not-allowed-token "Direct link to TokenBridge: not allowed token")

- **Error Description:** Operations with the token are not permitted.
- **Solution:** Call the `allowToken()` function first to enable the token.

## Mass exit [â€‹](\#mass-exit "Direct link to Mass exit")

#### TokenBridge: mass exit already set [â€‹](\#tokenbridge-mass-exit-already-set "Direct link to TokenBridge: mass exit already set")

- **Error Description:** Mass exit has already been triggered.
- **Solution:** Mass exit should only be triggered once.

## Withdrawal request [â€‹](\#withdrawal-request "Direct link to Withdrawal request")

#### TokenBridge: event hash is invalid [â€‹](\#tokenbridge-event-hash-is-invalid "Direct link to TokenBridge: event hash is invalid")

- **Error Description:** The withdrawal event hash cannot be zero (entirely zeros).
- **Solution:** Verify the event hash and ensure it is not zero.

#### TokenBridge: withdraw request status is not withdrawable [â€‹](\#tokenbridge-withdraw-request-status-is-not-withdrawable "Direct link to TokenBridge: withdraw request status is not withdrawable")

- **Error Description:** The withdrawal event must have the `Withdrawable` status to be processed.
- **Solution:** Ensure the withdrawal event status is set to `Withdrawable`.

#### TokenBridge: withdraw request status is not pending [â€‹](\#tokenbridge-withdraw-request-status-is-not-pending "Direct link to TokenBridge: withdraw request status is not pending")

- **Error Description:** The withdrawal event must have the `Pending` status to be withdrawable.
- **Solution:** Ensure the withdrawal event status is set to `Pending`.

#### TokenBridge: blockchain RID is not set [â€‹](\#tokenbridge-blockchain-rid-is-not-set "Direct link to TokenBridge: blockchain RID is not set")

- **Error Description:** The blockchain RID value is not set.
- **Solution:** Call the `setBlockchainRid()` function first.

#### TokenBridge: event hash was already used [â€‹](\#tokenbridge-event-hash-was-already-used "Direct link to TokenBridge: event hash was already used")

- **Error Description:** A withdrawal event on the Chromia side might be used as a withdrawal request only once.
- **Solution:** Use a unique event hash for each withdrawal request.

## Postchain errors [â€‹](\#postchain-errors "Direct link to Postchain errors")

#### TokenBridge: cannot withdraw request after the mass exit block height [â€‹](\#tokenbridge-cannot-withdraw-request-after-the-mass-exit-block-height "Direct link to TokenBridge: cannot withdraw request after the mass exit block height")

- **Error Description:** Withdrawal requests cannot be processed after the mass exit block height.
- **Solution:** Try to withdraw funds by snapshot ( `withdrawBySnapshot()`) or withdraw funds back to Chromia
( `withdrawToPostchain()`).

#### TokenBridge: block signature is invalid [â€‹](\#tokenbridge-block-signature-is-invalid "Direct link to TokenBridge: block signature is invalid")

- **Error Description:** The signature of the block containing the withdrawal event is invalid.
- **Solution:** Check the withdrawal event data on the Chromia side. Ensure the validator set on the EVM side matches
the validator list hosted in the `IValidator` contract of the token bridge.

#### TokenBridge: invalid merkle proof [â€‹](\#tokenbridge-invalid-merkle-proof "Direct link to TokenBridge: invalid merkle proof")

- **Error Description:** The provided merkle proof for the withdrawal event is invalid.
- **Solution:** Check the withdrawal event data on the Chromia side.

#### TokenBridge: incorrect network ID [â€‹](\#tokenbridge-incorrect-network-id "Direct link to TokenBridge: incorrect network ID")

- **Error Description:** The network ID provided is incorrect.
- **Solution:** Verify the provided network ID matches the expected value.

#### TokenBridge: invalid amount to make request withdraw [â€‹](\#tokenbridge-invalid-amount-to-make-request-withdraw "Direct link to TokenBridge: invalid amount to make request withdraw")

- **Error Description:** Invalid amount to make request withdraw (amount less than or equal to 0).
- **Solution:** Ensure the withdrawal amount is greater than zero.

## Withdrawal and withdrawal back to Chromia [â€‹](\#withdrawal-and-withdrawal-back-to-chromia "Direct link to Withdrawal and withdrawal back to Chromia")

#### TokenBridge: no fund for the beneficiary [â€‹](\#tokenbridge-no-fund-for-the-beneficiary "Direct link to TokenBridge: no fund for the beneficiary")

- **Error Description:** There is no withdrawal request for the specified beneficiary or transaction sender.
- **Solution:** Verify a withdrawal request exists for the beneficiary.

#### TokenBridge: not mature enough to withdraw the fund [â€‹](\#tokenbridge-not-mature-enough-to-withdraw-the-fund "Direct link to TokenBridge: not mature enough to withdraw the fund")

- **Error Description:** The requested withdrawal has not met the required number of block confirmations.
- **Solution:** Ensure the requested withdrawal has the required number of block confirmations.

#### TokenBridge: fund is pending or was already claimed [â€‹](\#tokenbridge-fund-is-pending-or-was-already-claimed "Direct link to TokenBridge: fund is pending or was already claimed")

- **Error Description:** The requested withdrawal is either pending or has already been executed.
- **Solution:** Check the status of the requested withdrawal to ensure it is not pending or already executed.

## Withdraw by snapshot [â€‹](\#withdraw-by-snapshot "Direct link to Withdraw by snapshot")

#### TokenBridge: snapshot already used [â€‹](\#tokenbridge-snapshot-already-used "Direct link to TokenBridge: snapshot already used")

- **Error Description:** The specified snapshot has already been used.
- **Solution:** Use a unique, unused snapshot for each withdrawal.

#### TokenBridge: snapshot data is not correct [â€‹](\#tokenbridge-snapshot-data-is-not-correct "Direct link to TokenBridge: snapshot data is not correct")

- **Error Description:** The snapshot data is incorrect.
- **Solution:** Verify the snapshot data matches the Chromia side withdrawal event data.

#### TokenBridge: snapshot block should be the same with mass exit block [â€‹](\#tokenbridge-snapshot-block-should-be-the-same-with-mass-exit-block "Direct link to TokenBridge: snapshot block should be the same with mass exit block")

- **Error Description:** The snapshot block does not match the block on which the Mass Exit was triggered.
- **Solution:** Ensure the snapshot block matches the mass exit block.

## Emergency withdrawal [â€‹](\#emergency-withdrawal "Direct link to Emergency withdrawal")

#### TokenBridge: token address is invalid [â€‹](\#tokenbridge-token-address-is-invalid-1 "Direct link to TokenBridge: token address is invalid")

- **Error Description:** Token address value must not be equal to zero value (consisting entirely of zeros).
- **Solution:** Set a valid, non-zero token address.

### TokenBridge: beneficiary address is invalid [â€‹](\#tokenbridge-beneficiary-address-is-invalid "Direct link to TokenBridge: beneficiary address is invalid")

- **Error Description:** Beneficiary address value must not be equal to zero value (consisting entirely of zeros).
- **Solution:** Set a valid, non-zero beneficiary address.

#### TokenBridge: cannot do emergency withdrawal until 90 days after mass exit [â€‹](\#tokenbridge-cannot-do-emergency-withdrawal-until-90-days-after-mass-exit "Direct link to TokenBridge: cannot do emergency withdrawal until 90 days after mass exit")

- **Error Description:** Emergency withdrawal can only be executed after a 90-day period from the Mass Exit event.
- **Solution:** Emergency withdrawal is only available after 90 days from the mass exit event.

- [Initialization](#initialization)
- [Ownership](#ownership)
- [Setting blockchain RID](#setting-blockchain-rid)
- [Token Allowance](#token-allowance)
- [Mass exit](#mass-exit)
- [Withdrawal request](#withdrawal-request)
- [Postchain errors](#postchain-errors)
- [Withdrawal and withdrawal back to Chromia](#withdrawal-and-withdrawal-back-to-chromia)
- [Withdraw by snapshot](#withdraw-by-snapshot)
- [Emergency withdrawal](#emergency-withdrawal)
  - [TokenBridge: beneficiary address is invalid](#tokenbridge-beneficiary-address-is-invalid)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

```codeBlockLines_e6Vv
Usage: chr deployment [OPTIONS] COMMAND [ARGS]...

  Create and maintain deployments

â•­â”€ Options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  -h, --help  Show this message and exit                                     â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€ Commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  create    Deploy blockchain into container                                 â”‚
â”‚  info      Information about a deployed blockchain                          â”‚
â”‚  inspect   Inspect the API of a deployed blockchain                         â”‚
â”‚  update    Update configuration of a deployed blockchain                    â”‚
â”‚  resume    Starts a paused blockchain in a container                        â”‚
â”‚  pause     Pauses a blockchain in a container                               â”‚
â”‚  remove    Removes a blockchain in a container (This action is permanent)   â”‚
â”‚  proposal  Act on proposals                                                 â”‚
â”‚  voterset  Interact with votersets                                          â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

```

## deployment create [â€‹](\#deployment-create "Direct link to deployment create")

To deploy your dapp in a container, you use ( `chr deployment create`):

```codeBlockLines_e6Vv
Usage: chr deployment create [<options>]

  Deploy blockchain into container

Configuration Properties:
  -cfg, --config=<config>    Alternate path for client configuration file
  -s, --settings=<settings>  Alternate path for project settings file

Options:
  --secret=<path>           Path to secret file (pubkey/privkey)
  -d, --network=<text>      Specify which deployment target to use
  -bc, --blockchain=<text>  Name of blockchain to deploy
  --no-compression          If compression on rell sources should not be done
  -y                        Confirm that this will create a new deployment
  -h, --help                Show this message and exit

```

The `chr deployment create` command reads the `deployments` key in the
[project config file](/intro/configuration/project-config). For the first deployment towards a target, the
[Chromia CLI](/intro/terminology#chromia-command-line-interface-chromia-cli) prompts you with the chains config you
need to add to the [project config file](/intro/configuration/project-config). An example of such a prompt looks
something like this:

```codeBlockLines_e6Vv
Add the following to your project settings file
deployments:
  testnet:
    chains:
      my_rell_dapp: x"<BlockchainRID>" #Dapp Blockchain RID

```

note

This prompt is your genesis [**Blockchain RID**](/intro/terminology#blockchain-rid-brid); you must save this in the
config file. This is the identifier for all your following deployments to the chain.

If you already have a deployment and haven't added the chain identifier in your Project Settings file, the command
`chr deployment` overrides any previous deployment to the network. That's why saving the genesis **Blockchain RID**
prompted after the first deployment is important.

note

If you want to override the state, ignore the chain identifier.

When you deploy, you create a snapshot build in the `build/` folder with a timestamp by default. You can change this in
the [project config file](/intro/configuration/project-config) in `compile:target` if you want a different target.

- To deploy a [dapp](/intro/terminology#decentralized-application-dapp), you can run the following command when
being in the working directory where the `chromia.yml` file presides:

```codeBlockLines_e6Vv
chr deployment create --network testnet --secret .secret

```

- Otherwise, you can set a path for the `chromia.yml` file or specify a different Project Settings file:

```codeBlockLines_e6Vv
chr deployment create --settings chromia.yml --network testnet --secret .secret

```

- If you have multiple chains and only want to deploy a specific one, you can write the command like this:

```codeBlockLines_e6Vv
chr deployment create --settings chromia.yml --network testnet --blockchain my_rell_dapp --secret .secret

```

## deployment info [â€‹](\#deployment-info "Direct link to deployment info")

To get information about your dapp, you use ( `chr deployment info`):

```codeBlockLines_e6Vv
Usage: chr deployment info [<options>]

  Information about a deployed blockchain

Configuration Properties:
  -s, --settings=<settings>  Alternate path for project settings file

Chromia Configuration:

  Use connection configured under deployment from chromia.yml

  -d, --network=<text>      Specify which deployment target to use
  -bc, --blockchain=<text>  Name of blockchain to deploy

Manual:

  Set connection parameters manually

  -brid, --blockchain-rid=<text>  Target Blockchain RID
  --api-url=<text>                Target api url

Options:
  --verbose                         Show verbose information about nodes
  -f, --output-format=(table|JSON)  Output format
  -h, --help                        Show this message and exit

```

## deployment inspect [â€‹](\#deployment-inspect "Direct link to deployment inspect")

To inspect the API of your dapp, you use ( `chr deployment inspect`):

```codeBlockLines_e6Vv
Usage: chr deployment inspect [<options>]

  Inspect the API of a deployed blockchain

Configuration Properties:
  -cfg, --config=<config>    Alternate path for client configuration file
  -s, --settings=<settings>  Alternate path for project settings file

Node:

  Target a test node

  -brid, --blockchain-rid=<text>  Target Blockchain RID
  --cid=<int>                     Target Blockchain IID
  --api-url=<text>                Target api url

Deployment:

  Use a configured deployment

  -d, --network=<text>      Specify which deployment target to use
  -bc, --blockchain=<text>  Name of blockchain in deployment configuration

Options:
  -f, --output-format=(table|JSON)
                           Output format
  -m, --modules=<modules>  Explicitly state which module to inspect (comma
                           separated)
  -l, --list-modules       List all module names
  --module-args            Show module_args
  --definitions=(queries|operations|entities|objects)
                           List definitions of this kind (comma separated),
                           default: all
  --signature=<value>      Show the signature of the specified definition and
                           exit
  -h, --help               Show this message and exit

```

## deployment update [â€‹](\#deployment-update "Direct link to deployment update")

To update your dapp, you use ( `chr deployment update`):

```codeBlockLines_e6Vv
Usage: chr deployment update [<options>]

  Update configuration of a deployed blockchain

Configuration Properties:
  -cfg, --config=<config>    Alternate path for client configuration file
  -s, --settings=<settings>  Alternate path for project settings file

Options:
  --secret=<path>           Path to secret file (pubkey/privkey)
  -d, --network=<text>      Specify which deployment target to use
  -bc, --blockchain=<text>  Name of blockchain to deploy
  --no-compression          If compression on rell sources should not be done
  --height=<int>            Deploy configuration at a specific height
  --verify-only             Verifies blockchain config without sending update
                            transaction
  --skip-verification       Skip verification of blockchain config before
                            sending update transaction
  -h, --help                Show this message and exit

```

## deployment pause [â€‹](\#deployment-pause "Direct link to deployment pause")

To pause your dapp, you use ( `chr deployment pause`):

```codeBlockLines_e6Vv
Usage: chr deployment pause [<options>]

  Pauses a blockchain in a container

Configuration Properties:
  -cfg, --config=<config>    Alternate path for client configuration file
  -s, --settings=<settings>  Alternate path for project settings file

Options:
  --secret=<path>           Path to secret file (pubkey/privkey)
  --description=<text>      Description on why the blockchain is being acted on
  -d, --network=<text>      Specify which deployment target to use
  -bc, --blockchain=<text>  Name of blockchain to deploy
  -h, --help                Show this message and exit

```

## deployment resume [â€‹](\#deployment-resume "Direct link to deployment resume")

To start your paused dapp, you use ( `chr deployment resume`):

```codeBlockLines_e6Vv
Usage: chr deployment resume [<options>]

  Starts a paused blockchain in a container

Configuration Properties:
  -cfg, --config=<config>    Alternate path for client configuration file
  -s, --settings=<settings>  Alternate path for project settings file

Options:
  --secret=<path>           Path to secret file (pubkey/privkey)
  --description=<text>      Description on why the blockchain is being acted on
  -d, --network=<text>      Specify which deployment target to use
  -bc, --blockchain=<text>  Name of blockchain to deploy
  -h, --help                Show this message and exit

```

## deployment remove [â€‹](\#deployment-remove "Direct link to deployment remove")

To remove your dapp, you use ( `chr deployment remove`):

```codeBlockLines_e6Vv
Usage: chr deployment remove [<options>]

  Removes a blockchain in a container (This action is permanent)

Configuration Properties:
  -cfg, --config=<config>    Alternate path for client configuration file
  -s, --settings=<settings>  Alternate path for project settings file

Options:
  --secret=<path>           Path to secret file (pubkey/privkey)
  --description=<text>      Description on why the blockchain is being acted on
  -d, --network=<text>      Specify which deployment target to use
  -bc, --blockchain=<text>  Name of blockchain to deploy
  -h, --help                Show this message and exit

```

## deployment proposal [â€‹](\#deployment-proposal "Direct link to deployment proposal")

The deployment proposal command ( `chr deployment proposal`) comprises sub-commands that manage proposals.

```codeBlockLines_e6Vv
Usage: chr deployment proposal [OPTIONS] COMMAND [ARGS]...

  Act on proposals

â•­â”€ Options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  -h, --help  Show this message and exit                                     â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€ Commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  vote    Vote on proposals linked to your public key                        â”‚
â”‚  list    List all proposals that you can vote on                            â”‚
â”‚  info    Get information of a given proposal                                â”‚
â”‚  revoke  Revoke/remove a proposal submitted by you                          â”‚
â”‚  rename  Create a proposal to rename a deployed blockchain                  â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

```

### proposal vote [â€‹](\#proposal-vote "Direct link to proposal vote")

```codeBlockLines_e6Vv
Usage: chr deployment proposal vote [<options>]

  Vote on proposals linked to your public key

Configuration Properties:
  -cfg, --config=<config>    Alternate path for client configuration file
  -s, --settings=<settings>  Alternate path for project settings file

Deployment:

  Use a configured deployment network

  -d, --network=<text>  Specify which deployment target to use

Options:
  --secret=<path>     Path to secret file (pubkey/privkey)
  --id=<int>          Id of the proposal
  --accept, --reject  Vote action to cast
  -h, --help          Show this message and exit

```

The vote command ( `chr deployment proposal vote`) allows you to vote on proposals that are linked to your public key.

### proposal list [â€‹](\#proposal-list "Direct link to proposal list")

```codeBlockLines_e6Vv
Usage: chr deployment proposal list [<options>]

  List all proposals that you can vote on

Configuration Properties:
  -cfg, --config=<config>    Alternate path for client configuration file
  -s, --settings=<settings>  Alternate path for project settings file

Deployment:

  Use a configured deployment network

  -d, --network=<text>  Specify which deployment target to use

Options:
  --from=<value>  List proposals from date (YYYY-MM-DD)
  --to=<value>    List proposals to date (YYYY-MM-DD)
  --all           Include all proposals, including ones you can not vote on
  --pending       Only include proposals that are still pending
  -f, --output-format=(table|JSON)
                  Output format
  -h, --help      Show this message and exit

```

The list command ( `chr deployment proposal list`) lists all proposals that you can vote on.

### proposal info [â€‹](\#proposal-info "Direct link to proposal info")

```codeBlockLines_e6Vv
Usage: chr deployment proposal info [<options>]

  Get information of a given proposal

Configuration Properties:
  -cfg, --config=<config>    Alternate path for client configuration file
  -s, --settings=<settings>  Alternate path for project settings file

Deployment:

  Use a configured deployment network

  -d, --network=<text>  Specify which deployment target to use

Options:
  --id=<int>                        Id of the proposal
  -f, --output-format=(table|JSON)  Output format
  -h, --help                        Show this message and exit

```

The info command ( `chr deployment proposal info`) shows the information of a given proposal.

### proposal revoke [â€‹](\#proposal-revoke "Direct link to proposal revoke")

```codeBlockLines_e6Vv
Usage: chr deployment proposal revoke [<options>]

  Revoke/remove a proposal submitted by you

Configuration Properties:
  -cfg, --config=<config>    Alternate path for client configuration file
  -s, --settings=<settings>  Alternate path for project settings file

Deployment:

  Use a configured deployment network

  -d, --network=<text>  Specify which deployment target to use

Options:
  --id=<int>       Id of the proposal
  --secret=<path>  Path to secret file (pubkey/privkey)
  -h, --help       Show this message and exit

```

The revoke command ( `chr deployment proposal revoke`) revokes a proposal submitted by you.

### proposal rename [â€‹](\#proposal-rename "Direct link to proposal rename")

```codeBlockLines_e6Vv
Usage: chr deployment proposal rename [<options>]

  Create a proposal to rename a deployed blockchain

Configuration Properties:
  -cfg, --config=<config>    Alternate path for client configuration file
  -s, --settings=<settings>  Alternate path for project settings file

Deployment:

  Use a configured deployment network

  -d, --network=<text>  Specify which deployment target to use

Options:
  --secret=<path>       Path to secret file (pubkey/privkey)
  --description=<text>  Proposal description
  -n, --name=<text>     New name of the blockchain
  -h, --help            Show this message and exit

```

The rename command ( `chr deployment proposal rename`) creates a proposal to rename a deployed blockchain.

## deployment voterset [â€‹](\#deployment-voterset "Direct link to deployment voterset")

The deployment voterset command ( `chr deployment voterset`) comprises sub-commands that manage voter sets.

```codeBlockLines_e6Vv
Usage: chr deployment voterset [OPTIONS] COMMAND [ARGS]...

  Interact with votersets

â•­â”€ Options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  -h, --help  Show this message and exit                                     â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€ Commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  info               Show information of voter set                           â”‚
â”‚  update             Propose an update of a voter set's members list         â”‚
â”‚  list               List all voter sets                                     â”‚
â”‚  add-dapp-provider  Add a dapp provider to container                        â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

```

### voterset info [â€‹](\#voterset-info "Direct link to voterset info")

```codeBlockLines_e6Vv
Usage: chr deployment voterset info [<options>]

  Show information of voter set

Configuration Properties:
  -cfg, --config=<config>    Alternate path for client configuration file
  -s, --settings=<settings>  Alternate path for project settings file

Deployment:

  Use a configured deployment network

  -d, --network=<text>  Specify which deployment target to use

Options:
  -n, --name=<value>       Name of voter set
  -c, --container=<value>  Name of the container that is governed by the
                           voterset
  -f, --output-format=(table|JSON)
                           Output format
  -h, --help               Show this message and exit

```

The info command ( `chr deployment voterset info`) shows the information about a voter set.

### voterset update [â€‹](\#voterset-update "Direct link to voterset update")

```codeBlockLines_e6Vv
Usage: chr deployment voterset update [<options>]

  Propose an update of a voter set's members list

Configuration Properties:
  -cfg, --config=<config>    Alternate path for client configuration file
  -s, --settings=<settings>  Alternate path for project settings file

Deployment:

  Use a configured deployment network

  -d, --network=<text>  Specify which deployment target to use

Options:
  --secret=<path>          Path to secret file (pubkey/privkey)
  -vs, --voter-set=<text>  Name of existing voter set to update
  --threshold=<int>        New threshold
  --add-member=<value>     Provider pubkey(s) to add to voter set. Separate
                           keys with ','
  --remove-member=<value>  Provider pubkey(s) to remove from voter set.
                           Separate keys with ','
  --description=<text>     Proposal description
  -h, --help               Show this message and exit

```

With the update command ( `chr deployment voterset update`), you can propose an update of a voter sets governor. New
governor must be an existing voter set.

### voterset list [â€‹](\#voterset-list "Direct link to voterset list")

```codeBlockLines_e6Vv
Usage: chr deployment voterset list [<options>]

  List all voter sets

Configuration Properties:
  -cfg, --config=<config>    Alternate path for client configuration file
  -s, --settings=<settings>  Alternate path for project settings file

Deployment:

  Use a configured deployment network

  -d, --network=<text>  Specify which deployment target to use

Options:
  -f, --output-format=(table|JSON)
                          Output format
  -c, --container=<text>  Specify the container to receive the voterset for, If
                          not set it will default to all votersets.
  -h, --help              Show this message and exit

```

The list command ( `chr deployment voterset list`) lists all the voter sets.

### voterset add-dapp-provider [â€‹](\#voterset-add-dapp-provider "Direct link to voterset add-dapp-provider")

```codeBlockLines_e6Vv
Usage: chr deployment voterset add-dapp-provider [<options>]

  Add a dapp provider to container

Configuration Properties:
  -cfg, --config=<config>    Alternate path for client configuration file
  -s, --settings=<settings>  Alternate path for project settings file

Deployment:

  Use a configured deployment network

  -d, --network=<text>  Specify which deployment target to use

Options:
  --secret=<path>              Path to secret file (pubkey/privkey)
  -a, --await / --no-await     Wait for transaction to be included in a block
  -pk, --pubkey=<text>         The public key of the dapp provider to be added
  -cid, --container-id=<text>  Container Identifier to add dapp provider too
  -h, --help                   Show this message and exit

```

The add-dapp-provider command ( `chr deployment voterset add-dapp-provider`) adds a dapp provider to a container.

- [deployment create](#deployment-create)
- [deployment info](#deployment-info)
- [deployment inspect](#deployment-inspect)
- [deployment update](#deployment-update)
- [deployment pause](#deployment-pause)
- [deployment resume](#deployment-resume)
- [deployment remove](#deployment-remove)
- [deployment proposal](#deployment-proposal)
  - [proposal vote](#proposal-vote)
  - [proposal list](#proposal-list)
  - [proposal info](#proposal-info)
  - [proposal revoke](#proposal-revoke)
  - [proposal rename](#proposal-rename)
- [deployment voterset](#deployment-voterset)
  - [voterset info](#voterset-info)
  - [voterset update](#voterset-update)
  - [voterset list](#voterset-list)
  - [voterset add-dapp-provider](#voterset-add-dapp-provider)[Skip to main content](#__docusaurus_skipToContent_fallback)

# Search the documentation

[Search by Algolia](https://www.algolia.com/)[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ”—Rell library APIs**](/pages/rell/index.html)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

The Chromia token bridge facilitates asset transfers between Chromia and Ethereum Virtual Machine (EVM) compatible
blockchains, such as Binance Smart Chain (BSC) Testnet, to enable interoperability between these ecosystems. The
following steps outline how to set up a secure and functional token bridge:

The process includes the following steps:

- ## [Deploy a token contract on an EVM chain (e.g., BSC Testnet)](/bridge/bridge-setup/deploy-token-contract) [â€‹](\#deploy-a-token-contract-on-an-evm-chain-eg-bsc-testnet "Direct link to deploy-a-token-contract-on-an-evm-chain-eg-bsc-testnet")


Start by deploying an ERC20 token smart contract on the EVM chain (e.g., BSC Testnet). This token will serve as the
medium for cross-chain transfers between the EVM chain and Chromia.

- ## [Deploy the bridge contract on the EVM chain](/bridge/bridge-setup/deploy-bridge-contract) [â€‹](\#deploy-the-bridge-contract-on-the-evm-chain "Direct link to deploy-the-bridge-contract-on-the-evm-chain")


Once the token contract is deployed, the next step is to deploy a token bridge contract on the same EVM chain. This
bridge contract will manage the locking and unlocking of tokens during cross-chain transfers and facilitate
interaction with Chromia.

- ## [Allow the token on the bridge contract](/bridge/bridge-setup/allow-token-contract) [â€‹](\#allow-the-token-on-the-bridge-contract "Direct link to allow-the-token-on-the-bridge-contract")


After deploying the bridge contract, you will need to enable your token on the bridge. This process registers the
token and allows it to be used for transfers between the two ecosystems.


- [Deploy a token contract on an EVM chain (e.g., BSC Testnet)](#deploy-a-token-contract-on-an-evm-chain-eg-bsc-testnet)
- [Deploy the bridge contract on the EVM chain](#deploy-the-bridge-contract-on-the-evm-chain)
- [Allow the token on the bridge contract](#allow-the-token-on-the-bridge-contract)[Skip to main content](#__docusaurus_skipToContent_fallback)

Chromia [CLI](https://gitlab.com/chromaway/core-tools/chromia-cli) simplifies the development cycle and deployment of
Rell dapps, where all the needed capability is available in one CLI. It's a command-line tool that provides a way to
interact with the Chromia blockchain using a set of commands.

The Chromia CLI tool is designed to be user-friendly and easy to use. It provides a set of commands that can be used in
a terminal or console window and supports a range of options and flags to customize the behavior of the commands.

For information about installing Chromia CLI, see [Install Chromia CLI](/intro/installation/cli-installation). Once
installed, you can use Chromia CLI to interact with the Chromia blockchain and build decentralized applications and
services.

tip

You can use Chromia CLI in Gitlab CI and Bitbucket Pipeline. Read the
[continuous integration article](https://learn.chromia.com/courses/continuous-integration/introduction) for more
information.[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ“„ï¸Introduction** \\
A default deployment of Filehub is readily available on the Chromia mainnet. You can access the user interface here:](/filehub/filehub-setup/overview)[**ğŸ“„ï¸Deploy Filehub** \\
This topic outlines how to deploy a Filehub instance. Filehub acts as a decentralized solution for managing file storage](/filehub/filehub-setup/deploy-filehub)[**ğŸ“„ï¸Deploy Filechain** \\
This topic outlines how to deploy a Filechain, which serves as a storage solution for managing and storing file chunks](/filehub/filehub-setup/deploy-filechain)[**ğŸ“„ï¸Deploy Filehub and Filechain bundle** \\
A Filechain is inherently dependent on a Filehub, meaning that each Filechain must be deployed in conjunction with a](/filehub/filehub-setup/deploy-bundle)[Skip to main content](#__docusaurus_skipToContent_fallback)

To interact with the Chromia blockchain using the bridge client, you'll need to manage an active `Session` that handles
all Chromia-related queries and operations. However, the bridge client can be initialized without a session at the
start. Here's a step-by-step guide to set up your application using `@chromia/ft4`.

```codeBlockLines_e6Vv
// 1: Setup a connection to postchain through postchain-client
const pcl = await createClient({
  nodeUrlPool: "YOU_NODE_URL_POOL",
  blockchainRid: "YOUR_BLOCKCHAIN_RID",
});

// 2: Create an account
const evmKeyStore = await createWeb3ProviderEvmKeyStore(window.ethereum);
const ad = createSingleSigAuthDescriptorRegistration([AuthFlag.Account, AuthFlag.Transfer], evmKeyStore.id);
const response = await registerAccount(pcl, evmKeyStore, registrationStrategy.open(ad));

// 3: Log in your user
const evmKeyStoreInteractor = createKeyStoreInteractor(pcl, evmKeyStore);
const accounts = await evmKeyStoreInteractor.getAccounts();
const session = await evmKeyStoreInteractor.getSession(accounts[0].id);

```

note

Ensure that you save your `evmKeyStore` in your application state, as some methods in `@chromia/bridge-client` will
require it.

With your `Session` object ready, you can initialize the bridge client. You will also need to provide an EVM Provider,
either a `BrowserProvider` or a `JsonRpcProvider`:

```codeBlockLines_e6Vv
const provider = new BrowserProvider(window.ethereum);
const bcl = await bridgeClient(
  { bridgeAddress: "YOUR_BRIDGE_ADDRESS", tokenAddress: "YOUR_TOKEN_ADDRESS" },
  provider,
  session
);

```

If your application setup prevents having an active `Session` when instantiating the bridge client, you can still set up
the client without it:

```codeBlockLines_e6Vv
const provider = new BrowserProvider(window.ethereum);
const bcl = await bridgeClient({ bridgeAddress: "YOUR_BRIDGE_ADDRESS", tokenAddress: "YOUR_TOKEN_ADDRESS" }, provider);

```

Later, when you have access to the `Session`, you can set it on the client with `setSession(session: Session)`:

```codeBlockLines_e6Vv
bcl.setSession(session);

```[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ”—Postchain APIs**](/pages/postchain-restapi.html)[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ“„ï¸rell.test** \\
rell.test namespace provides types and functions for creating, manipulating, and executing test blocks and](/rell/tests/namespace/)[**ğŸ“„ï¸rell.test.block** \\
rell.test.block type provides methods for creating and executing test blocks within the Rell testing framework.](/rell/tests/namespace/block)[**ğŸ“„ï¸rell.test.tx** \\
rell.test.tx type provides methods for creating and executing test transactions within the Rell testing framework.](/rell/tests/namespace/tx)[**ğŸ“„ï¸rell.test.op** \\
rell.test.op type represents a Rell operation within the Rell testing framework.](/rell/tests/namespace/op)[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ“„ï¸Set up the bridge demo app** \\
This section guides you through cloning the](/bridge/bridge-demo/set-up)[**ğŸ“„ï¸Interact with the bridge frontend app** \\
Start the bridge frontend app:](/bridge/bridge-demo/work-with-frontend)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

This topic outlines how to deploy the token bridge contract on the BSC Testnet. The token bridge enables ERC20 tokens to
be transferred between Chromia and Binance Smart Chain.

## Prerequisites [â€‹](\#prerequisites "Direct link to Prerequisites")

Before starting, ensure you have the following tools and resources:

- [Chromia CLI](/intro/installation/cli-installation) installed
- A deployed [Token contract address](/bridge/bridge-setup/deploy-token-contract)
- **Node.js and Yarn** installed on your system
- **MetaMask**: Installed and configured to
[connect to the BSC Testnet](https://academy.binance.com/en/articles/connecting-metamask-to-binance-smart-chain#How-to-Manually-Add-a-Network-to-MetaMask)
- **BNB for Gas Fees**: Obtain test BNB from the [BSC Testnet Faucet](https://www.bnbchain.org/en/testnet-faucet) to
cover gas fees
- Chromia validator node's public key (for example,
`0324653EAC434488002CC06BBFB7F10FE18991E35F9FE4302DBEA6D2353DC0AB1C`). If you donâ€™t have one, generate it with
[chr keygen](/cli/commands/keygen).

## Step 1: Retrieve nodeâ€™s EVM address [â€‹](\#step-1-retrieve-nodes-evm-address "Direct link to Step 1: Retrieve nodeâ€™s EVM address")

First, obtain the EVM address associated with your Chromia nodeâ€™s public key. Run the following command, replacing
`YOUR_NODE_PUBLIC_KEY` with your actual Chromia node's public key:

```codeBlockLines_e6Vv
chr repl -c 'crypto.eth_pubkey_to_address(x"YOUR_NODE_PUBLIC_KEY")'

```

For example:

```codeBlockLines_e6Vv
chr repl -c 'crypto.eth_pubkey_to_address(x"0324653EAC434488002CC06BBFB7F10FE18991E35F9FE4302DBEA6D2353DC0AB1C")'

```

This will output the address in hexadecimal format:

```codeBlockLines_e6Vv
x"17C5185167401ED00CF5F5B2FC97D9BBFDB7D025"

```

Next, set the `NODE_EVM_ADDRESS` environment variable:

```codeBlockLines_e6Vv
export NODE_EVM_ADDRESS=17C5185167401ED00CF5F5B2FC97D9BBFDB7D025

```

## Step 2: Deploy the contract to BSC Testnet [â€‹](\#step-2-deploy-the-contract-to-bsc-testnet "Direct link to Step 2: Deploy the contract to BSC Testnet")

To deploy the contract to the BSC Testnet, use the following command:

```codeBlockLines_e6Vv
yarn deploy --network bsc_testnet --app $NODE_EVM_ADDRESS --offset 2

```

- `--network bsc_testnet`: Specifies the BSC Testnet as the target for deployment.
- `--app $NODE_EVM_ADDRESS`: Deploys the contract using the EVM address obtained in Step 1.
- `--offset 2`: Sets an offset value for the deployment process.

Upon successful deployment, the terminal will display the addresses of the deployed contracts. For example:

```codeBlockLines_e6Vv
Validator deployed to:  0x01cd3172AA7b70beb6476E72DA509EfE00CD652D
Token bridge deployed to:  0x7EE9dfbDF18c609a5e1AB0180c8A2ec6D473E093
Proxy admin address is:  0x5Ea833bbE9A8afb4381338650DA14497D3728b75

```

tip

Make sure to copy and save the deployed contract addresses for future reference.

- [Prerequisites](#prerequisites)
- [Step 1: Retrieve nodeâ€™s EVM address](#step-1-retrieve-nodes-evm-address)
- [Step 2: Deploy the contract to BSC Testnet](#step-2-deploy-the-contract-to-bsc-testnet)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

The [Chromia bridge client](https://www.npmjs.com/package/@chromia/bridge-client) is a TypeScript library with utilities
for interacting with the Chromia Token Bridge. This topic will walk you through setting up the Chromia bridge client to
facilitate token transfers between Chromia and Ethereum Virtual Machine (EVM) networks.

## Prerequisites [â€‹](\#prerequisites "Direct link to Prerequisites")

Before you begin, ensure you have the following:

- **TokenBridge contract**: The address of a deployed `TokenBridge` contract on an EVM network.
- **ERC20 token contract**: The address of an ERC20 token on the same EVM network.
- **Blockchain RID**: The RID of a Chromia blockchain using the `hbridge` Rell library.

## Configuration checklist [â€‹](\#configuration-checklist "Direct link to Configuration checklist")

- ### Approve ERC20 token [â€‹](\#approve-erc20-token "Direct link to Approve ERC20 token")


The ERC20 token must be approved by the `TokenBridge` contract owner using the `allowToken` function. You can
accomplish this with the `@chromia/bridge-client` using the `allowToken` method:





```codeBlockLines_e6Vv
const contractTransactionResponse = await bcl.allowToken(token);

```

- ### Check spending allowance [â€‹](\#check-spending-allowance "Direct link to Check spending allowance")


Verify the spending allowance with the `checkAllowance` method:





```codeBlockLines_e6Vv
const allowance: bigint = await bcl.checkAllowance();

```

- ### Set blockchain RID [â€‹](\#set-blockchain-rid "Direct link to Set blockchain RID")


Use the `setBlockchainRid` function in the `TokenBridge` contract to set the blockchain RID. You can use the built-in
method `setBlockchainRid` with `@chromia/bridge-client`:





```codeBlockLines_e6Vv
const contractTransactionResponse = await bcl.setBlockchainRid(rid);

```

- ### Validator configuration [â€‹](\#validator-configuration "Direct link to Validator configuration")


Convert the public keys of the validating nodes in the Chromia network to EVM addresses and configure them in the
Validator contract, either during deployment or by calling the `updateValidators` function.


- [Prerequisites](#prerequisites)
- [Configuration checklist](#configuration-checklist)
  - [Approve ERC20 token](#approve-erc20-token)
  - [Check spending allowance](#check-spending-allowance)
  - [Set blockchain RID](#set-blockchain-rid)
  - [Validator configuration](#validator-configuration)[Skip to main content](#__docusaurus_skipToContent_fallback)

Enable your token on the bridge using the command below:

```codeBlockLines_e6Vv
yarn allowToken:bridge --network bsc_testnet --bridge-address 0x7EE9dfbDF18c609a5e1AB0180c8A2ec6D473E093 --token-address 0x22Ea9bF66Ee38E39A333773e584f37216136700A

```

This command successfully registers your token with the bridge contract.

Next, we'll use the [chromia-bridge-demo](https://bitbucket.org/chromawallet/chromia-bridge-demo/src/main/) repository
to configure and interact with the bridge effectively.[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ“„ï¸Configure Filehub** \\
This topic describes the steps to set up and manage a Filehub instance effectively. It covers how to register](/filehub/configure-filehub/filehub-configure)[**ğŸ“„ï¸Work with Filehub** \\
Filehub allows users to store files on-chain and retrieve them using the](/filehub/configure-filehub/filehub-work)[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ“„ï¸System entities** \\
In Rell, once data is stored within block and transaction entities, it becomes immutable, meaning it cannot be](/rell/language-features/systemlib/system-entities)[**ğŸ—ƒï¸Namespaces** \\
4 items](/category/namespaces)[**ğŸ“„ï¸Global functions** \\
Rell has a diverse collection of built-in functions that you can use to perform common tasks and write efficient Rell](/rell/language-features/systemlib/global-functions)[**ğŸ“„ï¸Require function** \\
The require function allows you to verify Boolean conditions, check for null values, or ensure non-empty collections.](/rell/language-features/systemlib/require-function)[**ğŸ“„ï¸Partial functions** \\
You can use a wildcard symbol \* to create a reference to a function, that is, to obtain a value of a function type](/rell/language-features/systemlib/partial-functions)[**ğŸ“„ï¸System queries** \\
rell.getrellversion(): text](/rell/language-features/systemlib/system-queries)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

```codeBlockLines_e6Vv
Usage: chr install [<options>]

  Install library dependencies, if no library specified all will be installed

Configuration Properties:
  -s, --settings=<settings>  Alternate path for project settings file

Options:
  -lib, --library=<library>  Name of library
  -h, --help                 Show this message and exit

```

The install command ( `chr install`) enables you to download and use third-party Rell libraries in your dapp.

```codeBlockLines_e6Vv
libs:
  ft4:
    registry: https://bitbucket.org/chromawallet/ft3-lib/src/
    tagOrBranch: v0.1.5r
    path: rell/src/lib/ft4
    rid: x"7E7D652AE3081E9A71EF870C1926AA65F715CF5FF5F379559C4FD92B6E6EB04F"
    insecure: false

```

### Ssh [â€‹](\#ssh "Direct link to Ssh")

When installing using ssh urls you need to have a ssh-agent running with your key added to it and that the host is added
as a known host.

1. Verify ssh-agent is running `ps aux | grep -v grep | grep ssh-agent`
2. Your agent has your key added to it `ssh-add -l`
3. Host is in "Known Hosts" in your ssh config folder (~/.ssh/known\_hosts)

- [Ssh](#ssh)[Skip to main content](#__docusaurus_skipToContent_fallback)

```codeBlockLines_e6Vv
Usage: chr build [<options>]

  Build an application and create a blockchain configuration

Configuration Properties:
  -s, --settings=<settings>  Alternate path for project settings file

Options:
  -bc, --blockchain=<blockchain>
                          Explicitly specify which blockchain(s) to compile
  -f, --format=(GTV|XML)  Blockchain configuration format
  -h, --help              Show this message and exit

```

The build command ( `chr build`) creates a blockchain configuration for your
[dapp](/intro/terminology#decentralized-application-dapp). By default, it gets placed in the root folder of your
dapp, but you can change it in the [project config file](/intro/configuration/project-config) ( `chromia.yml`) in
`compile:target` and `compile:source`.

- If you are in the working directory where the `chromia.yml` file presides, you can run the following command to create
the blockchain configuration:

```codeBlockLines_e6Vv
chr build

```

- Otherwise, you can set a path for the `chromia.yml` file or specify a different Project Settings file:

```codeBlockLines_e6Vv
chr build --settings chromia.yml

```[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ“„ï¸Install PMC CLI** \\
The Postchain Management Console (PMC) CLI is a command-line interface that submits transactions to the management](/providers/nodes/install-pmc)[**ğŸ“„ï¸Configure provider key pair** \\
On the Chromia network, key pairs have different meanings and responsibilities. As a provider, you typically handle two](/providers/nodes/provider-keypair)[**ğŸ“„ï¸Prepare the node for deployment** \\
Before you start a node, you must install the PostgreSQL database. For more information, see](/providers/nodes/prepare-node)[**ğŸ“„ï¸Enable logging and monitoring** \\
Prometheus](/providers/nodes/logging)[**ğŸ“„ï¸Start a node** \\
To start a node, you need to complete a few prerequisites.](/providers/nodes/start-a-node)[**ğŸ“„ï¸Set up a reverse proxy for TLS** \\
Enabling TLS (Transport Layer Security) is essential for securing all nodes within the network. This can be achieved by](/providers/nodes/setup-tls)[**ğŸ“„ï¸Add node to the network** \\
Register the node](/providers/nodes/add-node)[**ğŸ“„ï¸Configure node properties** \\
This topic outlines node properties that can be configured via properties files or environment variables. For](/providers/nodes/node-config)[**ğŸ“„ï¸Node management API** \\
When postchain is run in managed mode (as it always does with a management chain), the module in bc0 must fulfill a](/providers/nodes/api)[**ğŸ“„ï¸Monitor your node with Prometheus and Grafana** \\
When running a node, it's crucial to set up effective monitoring to ensure quick response times in case of failures and](/providers/nodes/setup-prometheus)[**ğŸ“„ï¸Change the FT4 key** \\
In the Chromia network, the system uses the provider key by default for both controlling the financial FT4 account and](/providers/nodes/change-ft4-key)[**ğŸ“„ï¸Node maintenance guidelines** \\
Regular maintenance of provider nodes helps improve network stability and security by adding new features or fixing](/providers/nodes/node-maintenance-guidelines)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

### Bridge from EVM to Chromia [â€‹](\#bridge-from-evm-to-chromia "Direct link to Bridge from EVM to Chromia")

- #### Approve token spending [â€‹](\#approve-token-spending "Direct link to Approve token spending")


Ensure the user approves token spending by the token bridge:





```codeBlockLines_e6Vv
const approvalResponse = await bcl.approveDepositAmount(BigInt(10));

```

- #### Deposit to Chromia EVM bridge [â€‹](\#deposit-to-chromia-evm-bridge "Direct link to Deposit to Chromia EVM bridge")


Use the `depositToEvmBridgeContract` method, specifying the number of tokens to bridge:





```codeBlockLines_e6Vv
const contractTransactionResponse = await bcl.depositToEvmBridgeContract(BigInt(100));

```

- #### Link EVM account [â€‹](\#link-evm-account "Direct link to Link EVM account")


After a deposit, link the EVM account with the corresponding FT4 account created during the deposit process. Provide
the `evmKeyStore` you created earlier:





```codeBlockLines_e6Vv
const accountLinkingResponse = await bcl.linkEvmEoaAccount(evmKeyStore);

```











note





If the EVM account is linked, it will be returned to the `accountLinkingResponse`. An EVM account can have multiple
FT4 accounts linked to it.


### Bridge from Chromia to EVM [â€‹](\#bridge-from-chromia-to-evm "Direct link to Bridge from Chromia to EVM")

- #### Bridge from Chromia [â€‹](\#bridge-from-chromia "Direct link to Bridge from Chromia")


Call the `bridgeFromChromia` method with the amount and the asset ID:





```codeBlockLines_e6Vv
// Network ID does not need to be provided as it will be fetched from the provider
const transactionResponse = await bcl.bridgeFromChromia(BigInt(10), Buffer.from("YOUR_ASSET_ID", "hex"));

```


### Request withdrawal from EVM bridge [â€‹](\#request-withdrawal-from-evm-bridge "Direct link to Request withdrawal from EVM bridge")

- #### Create a pending withdrawal request [â€‹](\#create-a-pending-withdrawal-request "Direct link to Create a pending withdrawal request")


This needs to be accepted by the user to start the withdrawal process using the `requestEvmWithdraw` method:





```codeBlockLines_e6Vv
const erc20WithdrawalInfo = await bcl.getErc20WithdrawalByTransactionRid(
    transactionResponse.receipt.transactionRid,
    opIndex
);
// Get event proof for withdrawal
const eventProof = await bcl.getWithdrawRequestEventProof(erc20WithdrawalInfo.event_hash);
// Request withdrawal
const requestedWithdraw = await bcl.requestEvmWithdraw(eventProof);

```

- #### Check withdrawal status [â€‹](\#check-withdrawal-status "Direct link to Check withdrawal status")


Depending on the bridge contract configuration, the user must wait a certain number of blocks on EVM to complete their
withdrawal. This can be done using the `getPendingWithdrawFromProof` method:





```codeBlockLines_e6Vv
const { block_number } = await getPendingWithdrawFromProof(eventProof);

```









Once the `block_number` has been reached on the target EVM chain, the user can withdraw their tokens:





```codeBlockLines_e6Vv
const withdrawal = await bcl.evmWithdraw(eventProof.leaf as Buffer);

```


## Additional methods [â€‹](\#additional-methods "Direct link to Additional methods")

- `getErc20Deposits(filter?: DepositFilter, pageSize?: number, pageCursor?: string)`: Returns all deposits specified by
the filter.
- `getErc20Withdrawals(filter?: WithdrawFilter, pageSize?: number, pageCursor?: string)`: Returns all withdrawals from
the EVM bridge specified by the filter.
- `setBlockchainRid(blockchainRid: Buffer)`: Sets the blockchain RID.

- [Bridge from EVM to Chromia](#bridge-from-evm-to-chromia)
- [Bridge from Chromia to EVM](#bridge-from-chromia-to-evm)
- [Request withdrawal from EVM bridge](#request-withdrawal-from-evm-bridge)
- [Additional methods](#additional-methods)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Filehub is a scalable, reliable, and secure storage platform that Chromia's relational blockchain powers. It provides
developers with a decentralized solution for storing and accessing files, ensuring data integrity and availability even
when faced with external disruptions.

## Cost [â€‹](\#cost "Direct link to Cost")

Filehub operates on a fixed payment model for storage. The current price is $0.10 per MB for perpetual storage. Your
files will remain accessible for a minimum of 30 years. Access continues indefinitely with no renewal fees, as long as
the network remains operational.

## File access [â€‹](\#file-access "Direct link to File access")

Everyone can access all files stored in Filehub free of charge. If you want to store private files, you must encrypt
them before upload.

## Getting started with Filehub [â€‹](\#getting-started-with-filehub "Direct link to Getting started with Filehub")

To use Filehub, you need to provide it with CHR from the Economy Chain. A minimum deposit of 1 CHR is required to create
an account.

- If your CHR is currently on an EVM chain, you can create an Economy Chain account and bridge it over using the
[Vault Transfer](https://vault.chromia.com/en/transfer/) feature.
- Once your CHR is on the Economy Chain, you can create an account and transfer your CHR to the Filehub Chain using the
[Vault UI for Filehub](https://vault.chromia.com/en/dapps/dapp/?dapp=17-Filehub).
- Finally, navigate to the [Filehub UI](https://filehub.chromia.com/) and start uploading your files.

## Components [â€‹](\#components "Direct link to Components")

Filehub consists of two fundamental components:

- **Filehub blockchain**: This acts as the central index, tracking files and managing references to data chunks
distributed across multiple Filechains.
- **Filechain blockchain(s)**: These function as the actual blob storage, responsible for persisting file data

### Filehub [â€‹](\#filehub "Direct link to Filehub")

The Filehub blockchain serves as the central indexing system, responsible for:

- Managing the administration and availability of Filechains.
- Selecting the appropriate Filechains for distributing and storing each file chunk.
- Maintaining a comprehensive index of file chunks and their corresponding Filechain locations.
- Handling the billing system for file storage, ensuring proper payment for services.

Filehubâ€™s architecture is modular and scalable. It starts with a single Filehub and two Filechains, with the flexibility
to expand incrementally by adding more Filechains as storage requirements grow. This design supports unlimited
horizontal scaling, increasing both storage capacity and file distribution efficiency.

### Filechain [â€‹](\#filechain "Direct link to Filechain")

The Filechain Blockchain(s) function as blob storage, handling the following tasks:

- Storing file chunks in a secure and decentralized manner.
- Validating payments made to Filehub using
[ICCF (Interchain Confirmation Facility)](/intro/cross-chain/iccf)-proofs.
- Hashing incoming data and verifying it against expected hashes to ensure data integrity.
- Accepting transactions and persisting file chunks on the Filechain blockchain.

Filechain serves strictly as a blob storage solution. It operates without knowledge of file metadata or the
relationships between chunks. Its sole responsibility is to store data chunks and validate their integrity.

## ICCF and anchoring chain [â€‹](\#iccf-and-anchoring-chain "Direct link to ICCF and anchoring chain")

The [ICCF (Interchain Confirmation Facility)](/intro/cross-chain/iccf) facilitates communication between Filehub
and Filechains. This framework ensures that file chunks are only stored on Filechains after payment has been confirmed.

Here's how the process works:

1. **Payment and allocation**: When a user uploads a file to Filehub, the platform allocates storage on a suitable
Filechain and processes the payment.

2. **ICCF proof generation**: Filehub generates an ICCF proof, which is a cryptographic signature verifying that the
file has been allocated and paid for.

3. **Proof submission**: The ICCF proof is submitted to the target Filechain.

4. **Proof verification**: The Filechain independently verifies the ICCF proof to confirm that the payment for the
corresponding file chunk has been completed.


This indirect communication mechanism, facilitated by the ICCF and the anchoring chain, ensures the security and
integrity of the file storage process. By verifying payments before storing file chunks, Filehub prevents unauthorized
access and ensures that users only pay for the storage they use.

- [Cost](#cost)
- [File access](#file-access)
- [Getting started with Filehub](#getting-started-with-filehub)
- [Components](#components)
  - [Filehub](#filehub)
  - [Filechain](#filechain)
- [ICCF and anchoring chain](#iccf-and-anchoring-chain)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

A Filechain is inherently dependent on a Filehub, meaning that each Filechain must be deployed in conjunction with a
Filehub. This project simplifies the process by packaging both Filehub and Filechain as a cohesive unit for deployment.

warning

This deployment is primarily intended for local development and testing purposes, utilizing a "mock" directory chain.
For deployments on actual networks, refer to the independent deployment instructions for [Filehub](/filehub/filehub-setup/deploy-filehub) and
[Filechain](/filehub/filehub-setup/deploy-filechain).

You can set up the [Filehub](/filehub/filehub-setup/deploy-filehub) and [Filechain](/filehub/filehub-setup/deploy-filechain) either as standalone systems or in a
multi-node setup, enhancing redundancy and ensuring higher availability.

## Prerequisites [â€‹](\#prerequisites "Direct link to Prerequisites")

Before starting, ensure you have the following tools and resources:

- [Chromia CLI](/intro/installation/cli-installation)
- Git
- Docker

## Step 1: Run the deploy bundle [â€‹](\#step-1-run-the-deploy-bundle "Direct link to Step 1: Run the deploy bundle")

The deployment script simplifies setting up your local development environment. It accepts three main input parameters:

- `-r` =\> Enable rate limiter for Filehub (1 = enabled, 0 = disabled)
- `-e` =\> Specify which endpoint to use for nodes (e.g., `docker` or `localhost`, defaults to `localhost`)
- `-a` =\> Enable the Gateway API (1 = enabled, 0 = disabled)

##### Example commands: [â€‹](\#example-commands "Direct link to Example commands:")

```codeBlockLines_e6Vv
./start.sh          # Starts the deploy bundle with default settings
./start.sh -r 0     # Rate limiter disabled
./start.sh -e docker  # Node URLs configured for Docker
./start.sh -a 0     # Gateway API disabled
./start.sh -r 0 -a 0 # Both rate limiter and Gateway API disabled
./start.sh -r 0 -e docker -a 0  # Disabled rate limiter & Gateway API, with Docker endpoint

```

The script executes several steps to configure the development environment:

1. **Environment detection:** Identifies the appropriate environment for deployment (local or production).
2. **Reset and clean up:** Cleans up folders and Docker containers to reset the environment to a fresh state.
3. **Repository cloning:** Clones the necessary repositories required for Filehub and Filechain.
4. **Directory chain preparation:** Extracts and installs the necessary packages, then builds the Directory Chain.
5. **Database setup:** Starts a PostgreSQL container to handle the database requirements.
6. **Directory chain launch:** Starts the Directory chain, which manages directory services.
7. **Filehub deployment:** Installs, builds, and deploys the Filehub, which acts as the control hub.
8. **Filechain deployment:** Installs, builds, and deploys the Filechain, which handles the actual file storage.
9. **Gateway API Setup:** Configures and starts the Gateway API container, allowing easy file access via HTTP.

- [Prerequisites](#prerequisites)
- [Step 1: Run the deploy bundle](#step-1-run-the-deploy-bundle)[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ”—Rell masterclass**](https://learn.chromia.com/courses/rell-masterclass/introduction)[**ğŸ”—Understand relationships in Rell**](https://learn.chromia.com/courses/relationships-course/introduction)[**ğŸ”—Write your first dapp on Chromia**](https://learn.chromia.com/courses/book-review/introduction)[**ğŸ”—Create a simple app using Rell and React**](https://learn.chromia.com/courses/my-news-feed/introduction)[Skip to main content](#__docusaurus_skipToContent_fallback)

```codeBlockLines_e6Vv
Usage: chr repl [<options>]

  REPL is used to create a language shell for Rell that takes single user
  inputs, executes them, and returns the result. Inside the repl you can create
  local variables and execute Rell commands, it can be attached to a Rell
  module to be able to inspect a dapp state and execute dapp functionalities.

  Run query commands: To be able to run queries in the shell, a user must have
  a module defined from the start of the repl command in which the query is
  defined. Queries that do not depend on entities can be executed without a
  database connection, and queries that depend on an entity must then have a
  database connection defined.

  Run Operations commands: When a operation is executed from the repl shell,
  the database connection and a module needs to be defined from the start of
  the repl command, to be able to execute an operation it needs added to a
  transaction. This can be done by wrapping it with a test transaction like
  this: rell.test.tx(<your operation>..).run()

Configuration Properties:
  -s, --settings=<settings>  Alternate path for project settings file

Options:
  -m, --module=<module>    Name of module
  --sql-log                Log sql expressions
  --history-file=<path>    Save command history to this file
  --use-db                 If a session towards the configured database should
                           be established
  -c, --command=<command>  Execute a single command
  -r, --raw-output         Will print large object line by line and strings
                           without quotes (deprecated)
  -f, --output-format=(pretty|raw|JSON|XML|YAML)
                           Output format
  -h, --help               Show this message and exit

```

You can use the repl command ( `chr repl`) to run specific Rell methods in the shell, which can be suitable for
troubleshooting.[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ“„ï¸Release notes** \\
\| Release \| Changes/Updates \| Date \|](/rell/rell-releases)[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ“„ï¸Introduction** \\
The Chromia token bridge facilitates asset transfers between Chromia and Ethereum Virtual Machine (EVM) compatible](/bridge/bridge-setup/overview)[**ğŸ“„ï¸Deploy a ERC20 token contract** \\
If you donâ€™t have an existing ERC20 token to deploy, you can use one from the](/bridge/bridge-setup/deploy-token-contract)[**ğŸ“„ï¸Deploy the token bridge contract on BSC Testnet** \\
This topic outlines how to deploy the token bridge contract on the BSC Testnet. The token bridge enables ERC20 tokens to](/bridge/bridge-setup/deploy-bridge-contract)[**ğŸ“„ï¸Allow the token on the bridge contract** \\
Enable your token on the bridge using the command below:](/bridge/bridge-setup/allow-token-contract)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Chromia is a cutting-edge Layer-1 blockchain ecosystem designed for the next generation of high-performance and scalable
decentralized applications (dapps). It enables developers to build dapps that can accommodate millions of users while
providing a smooth and user-friendly experience.

### Top features [â€‹](\#top-features "Direct link to Top features")

- **Gas-free transactions:** Chromia eliminates gas fees, allowing users to interact with dapps for free. This removes
cost barriers and promotes wider adoption.
- **Blockchain data storage:** Store large amounts of data directly on the blockchain, enabling sophisticated
applications like gaming, digital assets, and enterprise solutions to function seamlessly on-chain.
- **Scalable performance:** Each dapp operates on its individual dedicated chain, ensuring high performance without
congestion even during peak usage.

Chromia is the ideal choice for building innovative dapps across various industries, including:

| Dapps | Web3 Gaming | Real-World Assets | DeFi |
| --- | --- | --- | --- |
| DAOs | NFTs | Cloud Storage | Business and Institutions |

### Multichain design [â€‹](\#multichain-design "Direct link to Multichain design")

Chromia's unique multichain design enhances efficiency and scalability. Each decentralized application (dapp) operates
on its own dedicated blockchain, which handles transactions, stores data, and is accessible to network participants who
need to query information. This setup ensures that individual dapps maintain their performance, even during high loads,
without affecting the overall network, thereby preventing global congestion.

Dapps are organized into clusters, with the Cluster Anchoring Chain acting as the central component of each cluster.
When a dapp blockchain generates new blocks, the relevant information is transmitted to the Cluster Anchoring Chain for
validation and security.

The Chromia network supports an unlimited number of dapp clusters, with each adhering to this architecture. All Cluster
Anchoring Chains within these dapp clusters are interconnected with the System Chain, which serves as the fundamental
core of the entire Chromia network.

### On-chain dapps and NFTs [â€‹](\#on-chain-dapps-and-nfts "Direct link to On-chain dapps and NFTs")

Chromia distributes storage and computational resources among provider nodes, allowing dapps to store program logic,
metadata, and entire files directly on-chain. This facilitates the development of intricate and fully decentralized
dapps.

NFTs on Chromia can store all associated metadata and images on-chain, unlike NFT tokens on EVM chains, which are
typically limited in their ability to store metadata and often rely on external services for images and supplementary
data storage.

### Rell programming language [â€‹](\#rell-programming-language "Direct link to Rell programming language")

Chromia leverages Rell, a programming language specifically designed for dapp development within the relational data
model. Rell's concise syntax makes it easy for developers with database experience to build sophisticated and secure
dapps quickly.

### Explore Chromia's architecture [â€‹](\#explore-chromias-architecture "Direct link to Explore Chromia's architecture")

In the next topic, you will explore how Chromia's architecture is designed. You will learn about the main network
entities, how the consensus algorithm works, the primary types of blockchain networks in Chromia, and how the whole
system operates.

For a more in-depth understanding of the Chromia blockchain platform, refer to the
[Chromia White Paper](https://chromia.com/documents/Chromia-_-Platform-white-paper2019.pdf).

- [Top features](#top-features)
- [Multichain design](#multichain-design)
- [On-chain dapps and NFTs](#on-chain-dapps-and-nfts)
- [Rell programming language](#rell-programming-language)
- [Explore Chromia's architecture](#explore-chromias-architecture)[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ“„ï¸Introduction** \\
Here's the list of commands in Chromia CLI:](/cli/commands/introduction)[**ğŸ“„ï¸build** \\
The build command (chr build) creates a blockchain configuration for your](/cli/commands/build)[**ğŸ“„ï¸create-rell-dapp** \\
You can use the create-rell-dapp command (chr create-rell-dapp) to create a new Rell](/cli/commands/create-rell-dapp)[**ğŸ“„ï¸deployment** \\
deployment create](/cli/commands/deployment)[**ğŸ“„ï¸eif** \\
The Ethereum Interoperability Framework (EIF) command chr eif generate-events-config allows you to generate Solidity](/cli/commands/eif)[**ğŸ“„ï¸generate** \\
generate client-stubs](/cli/commands/generate)[**ğŸ“„ï¸install** \\
The install command (chr install) enables you to download and use third-party Rell libraries in your dapp.](/cli/commands/install)[**ğŸ“„ï¸keygen** \\
The keygen command (chr keygen) generates a public and private key pair. By default, the keys are generated with](/cli/commands/keygen)[**ğŸ“„ï¸node** \\
You can use the node command (chr node) to start or update a node with your applications running on it.](/cli/commands/node)[**ğŸ“„ï¸query** \\
You can use the query command (chr query) to test and interact with a chain that's either local or deployed without](/cli/commands/query)[**ğŸ“„ï¸repl** \\
You can use the repl command (chr repl) to run specific Rell methods in the shell, which can be suitable for](/cli/commands/repl)[**ğŸ“„ï¸test** \\
You can use the test command (chr test) to run the tests specified in the test key in the](/cli/commands/test)[**ğŸ“„ï¸tx** \\
You can use the tx (transaction) command (chr tx) in the same way as the query command, but you need to sign it with](/cli/commands/tx)[**ğŸ“„ï¸code** \\
You can use the code command (chr code) for code quality management (formatting and linting).](/cli/commands/code)[**ğŸ“„ï¸multi-signature** \\
You can use the multi-signature command (chr multi-signature) for handling transactions that need multiple signers.](/cli/commands/multi-signature)[**ğŸ“„ï¸tools** \\
You can use the tools command (chr tools) provides a set of miscellaneous tools for various tasks related to Chromia.](/cli/commands/tools)[Skip to main content](#__docusaurus_skipToContent_fallback)

```codeBlockLines_e6Vv
Usage: chr keygen [<options>]

  Generates public/private key pair

File format:
  -f, --file=<path>  Set file to save keypair to explicitly
  --key-id=<value>   Name the generated key with an id
  --dry              Perform dry run, prints keys in terminal and does not save
                     keys to disk

Options:
  -m, --mnemonic=<text>  Mnemonic word list, words separated by space, e.g:
                         "lift employ roast rotate liar holiday sun fever
                         output magnet...""
  -h, --help             Show this message and exit

```

The keygen command ( `chr keygen`) generates a public and private key pair. By default, the keys are generated with
default key id `chromia_key` and saved in the `.chromia` folder as `chromia_key.pubkey` and `chromia_key`.

- To use a key pair by its key ID, set the property `key.id = <key_id>` in your configuration file ( `.chromia/config`).

If your `TEXT` string is `myKey` then the public key is stored as `myKey.pubkey` and private key as `myKey`. To use a
key pair by its key ID, set the property `key.id = <key_id>` in your Chromia configuration ( `.chromia/config`) file.
If the config file does not exist, then you can create one in the `.chromia` folder.
  - **Windows:** `C:\Users\<YourUsername>\.chromia\config`
  - **macOS and Linux:** `/Users/<YourUsername>/.chromia/config` or `/home/<YourUsername>/.chromia/config`
- To recover a key pair from a mnemonic, pass in the mnemonic with `--mnemonic "march aspect pizza treat ..."`.[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

This topic outlines how to deploy a Filehub instance. Filehub acts as a decentralized solution for managing file storage
and indexing across multiple blockchains.

## Prerequisites [â€‹](\#prerequisites "Direct link to Prerequisites")

Before starting, ensure you have the following tools and resources:

- [Chromia CLI](/intro/installation/cli-installation)
- Git

## Step 1: Create a Container [â€‹](\#step-1-create-a-container "Direct link to Step 1: Create a Container")

[Create a container](/intro/deployment/mainnet/get-container) for your Filehub instance.

## Step 2: Prepare `chromia.yml` [â€‹](\#step-2-prepare-chromiayml "Direct link to step-2-prepare-chromiayml")

.Set up your `chromia.yml` file according to your needs.

## Step 3: Deploy blockchain [â€‹](\#step-3-deploy-blockchain "Direct link to Step 3: Deploy blockchain")

Follow the [blockchain deployment guide](/intro/deployment/mainnet/deploy-dapp) to deploy the Filehub blockchain.
This blockchain is crucial for managing file storage and distribution across the connected Filechains.

- [Prerequisites](#prerequisites)
- [Step 1: Create a Container](#step-1-create-a-container)
- [Step 2: Prepare `chromia.yml`](#step-2-prepare-chromiayml)
- [Step 3: Deploy blockchain](#step-3-deploy-blockchain)[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ“„ï¸Local variable declaration** \\
In Rell, local variables play a important role in storing and managing data within a specific scope. They provide a way](/rell/language-features/statements/local-variable)[**ğŸ“„ï¸Basic statements in Rell** \\
In Rell, the fundamental building blocks of programming are encapsulated within basic statements. These statements](/rell/language-features/statements/basic-statements)[**ğŸ“„ï¸If statement** \\
In Rell, the if statement is used to create conditional logic that allows you to execute different blocks of code](/rell/language-features/statements/if-statement)[**ğŸ“„ï¸When statement** \\
In Rell, when statement is similar to switch in C++ or Java, but uses the syntax of when in Kotlin. The when](/rell/language-features/statements/when-statement)[**ğŸ“„ï¸Loop statements** \\
In Rell, loop statements include the for, while, break, and continue statements, each serving distinct purposes](/rell/language-features/statements/loop-statements)[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ“„ï¸Install PMC CLI** \\
This topic contains instructions to install and update Postchain Management Console (PMC) CLI.](/providers/pmc/cli/pmccli-installation)[**ğŸ—ƒï¸Command reference** \\
13 items](/providers/pmc/commands/keygen)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Chromia provides native bridging technology that transfers tokens (ERC20, ERC721) between Ethereum-based chains and the
Chromia ecosystem. The bridging mechanism relies on an internal component called the Ethereum Interoperability Framework
(EIF), designed to source data from EVM chains and submit transactions.

There are two types of bridges:

- **Token Bridge**: An implementation of the bridge that developers can customize to transfer tokens (ERC20, ERC721) to
their dapps running on the Chromia network.
- **Chromia Token Bridge**: The official bridge that enables the transfer of the `CHR` ERC-20 token between EVM chains
and the Chromia network.

Bridges are protected by having withdrawal proofs signed by Chromia nodes through block headers, resembling a
multi-signature setup. If a majority of nodes get compromised, honest nodes can initiate a mass-exit, allowing users to
retrieve their balances based on a prior state. This setup makes it difficult for attackers to gain control over the
bridge's balance.

For demonstration purposes, consider the following infographic that highlights the EIF framework components and the
token bridge:

![eif overview](/img/eif_overview_light.svg)

- **Token Bridge**: Represents a smart contract running on the EVM chain. It carries the necessary business logic to
process deposits to the Chromia network and the release of tokens. When users deposit tokens into the smart contract,
the contract locks them and mints them on the dapp blockchain. During a withdrawal, the bridge burns the tokens, sends
proof of the burn to the token bridge smart contract, and releases the tokens to the userâ€™s address.
- **Event Receiver Chain**: An essential component of the EIF framework, which reads the Token Bridge smart contract
state and writes events to block headers.
- **Dapp #1-3**: Any number of dapps can read events from the Event Receiver Chain using the
[ICMF protocol](/intro/cross-chain/icmf) and handle them accordingly.

Chromia uses the following bridge mechanisms:

- **Lock and mint â€“** Lock assets on the smart contract and mint assets on the destination chain(dapp).

- **Burn and release â€“** Burn assets on the Chromia chain and release assets on the destination chain (EVM smart
contract).


### Lock and mint [â€‹](\#lock-and-mint "Direct link to Lock and mint")

![eif deposit](/img/eif_deposit_light.svg)

1. **Deposit**: Users deposit tokens (ERC20, ERC721) on an EVM-compatible chain, where they are locked in a smart
contract on that chain.
2. **Monitor**: The Event Receiver Chain monitors the deposit event on the EVM smart contract and writes this event to
its ledger.
3. **Detect**: Upon detecting the deposit event, dapp #2 creates, validates, and executes a transaction using a specific
Rell operation called `__evm_block`.
4. **Mint**: This transaction mints equivalent pegged tokens for the user on the Chromia chain.

When the user wishes to withdraw the pegged tokens from Chromia back to the original token on the EVM-compatible chain,
the bridge follows the Burn and release mechanism.

### Burn and release [â€‹](\#burn-and-release "Direct link to Burn and release")

![eif withdrawal](/img/eif_withdrawal_light.svg)

1. **Burn**: The user initiates the withdrawal by burning the token.
2. **Query proof**: The user queries the proof of the withdrawal event.
3. **Request withdrawal**: The user requests withdrawal by sending the withdrawal event data to the EVM smart contract.
4. **Release**: The user claims tokens, and the smart contract releases them.

- [Lock and mint](#lock-and-mint)
- [Burn and release](#burn-and-release)[Skip to main content](#__docusaurus_skipToContent_fallback)

```codeBlockLines_e6Vv
Usage: chr create-rell-dapp [<options>] [<name>]

  Generates a template project

  Template projects:
  Minimal - Minimal working example including sample queries/operations and
  tests.
  Plain - A plain skeleton with empty main and test files.
  Plain-Multi - A plain skeleton with empty main and test files using multiple
  modules.

Options:
  -d, --base-dir=<path>  Directory to generate template project in
  --template=(plain|plain-multi|minimal|plain-library|asset-management)
                         Project template
  -h, --help             Show this message and exit

Arguments:
  <name>  Dapp name

```

You can use the create-rell-dapp command ( `chr create-rell-dapp`) to create a new [Rell](/intro/terminology#rell)
structured "Hello World" project. It creates a [project config file](/intro/configuration/project-config)
( `chromia.yml`), a main module ( `main.rell`) in the `src/` folder, and test files in the `src/test/` folder in your
working directory.

```codeBlockLines_e6Vv
chr create-rell-dapp

```

The project structure is as follows:

```codeBlockLines_e6Vv
|--chromia.yml
|--_src
   |--main.rell
   |--_test
      |--arithmetic_test.rell
      |--data_test.rell

```[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Start the bridge frontend app:

```codeBlockLines_e6Vv
npm run dev

```

Navigate to [http://localhost:5173](http://localhost:5173).

![bridge demo frontend](/img/bridge_demo_ui.png)

### Initialize your account [â€‹](\#initialize-your-account "Direct link to Initialize your account")

Once the app is running, initialize your FT4 account:

1. Press the **Setup** button to create an FT4 account based on your EVM account. This step is only required once.
2. If the page reloads, press the **Login** button to log back in.

### Approve token spending [â€‹](\#approve-token-spending "Direct link to Approve token spending")

Approve the app to spend tokens on your behalf by pressing the **Approve spending of 3000 tokens by the Bridge** button.

### Bridge tokens to Chromia [â€‹](\#bridge-tokens-to-chromia "Direct link to Bridge tokens to Chromia")

To transfer funds from the EVM to the Chromia network, press the **Bridge 3000 tokens to Chromia** button.

### Verify token transfer [â€‹](\#verify-token-transfer "Direct link to Verify token transfer")

After bridging the tokens, verify that the funds have been credited to your FT4 account:

1. Set your `Node`, `ER`, and `Bridge` variables:





```codeBlockLines_e6Vv
export NODE=http://localhost:7740
export ER=6613EA1B36823AA67D65C6104BB93A789089D0E568939FD6CBACCE6AFF1D0859
export BRIDGE=AB889D51EECC3A063B2430084BB6EA5EC3A1EAB866AC62CAA553D8758933CADA

```








   - **`NODE`**: The URL of the local Chromia node that handles transactions and queries.
   - **`ER`**: The RID of the `event_receiver` blockchain, which tracks token deposits and withdrawals.
   - **`BRIDGE`**: The RID of the `demo_bridge` blockchain responsible for managing token bridging between Chromia and
     EVM.
2. Check the deposits:





```codeBlockLines_e6Vv
chr query --api-url $NODE -brid $BRIDGE eif.hbridge.get_erc20_deposits --filter=[null,null,null,null,null] page_size=null page_cursor=null

```

3. Check your FT4 account balance:





```codeBlockLines_e6Vv
chr query --api-url $NODE -brid $BRIDGE ft4.get_asset_balance --account_id='x"5094C958B7B8C47DCCE7B5F0200AC9EEABBA140028662A2BA6178A3EB22B2927"' asset_id='x"04F9118CABA6A2E3E4390FF191B4F46130D7370BBE7E057130810F92B8CE78DE"'

```


### Transfer funds back to EVM [â€‹](\#transfer-funds-back-to-evm "Direct link to Transfer funds back to EVM")

Now that the funds are in your FT4 account, you can transfer them back to the EVM:

1. Press the **Bridge 1500 Tokens to EVM** button.

2. Check for the withdrawal event:





```codeBlockLines_e6Vv
chr query --api-url $NODE -brid $BRIDGE eif.hbridge.get_erc20_withdrawals --filter=[null,null,null,null,null,null,null] page_size=null page_cursor=null

```

3. Press the **Request Withdraw from EVM** button to initiate the withdrawal.

4. Finally, press the **Withdraw from bridge** button to complete the process.


You have successfully set up and configured the bridge demo app to transfer tokens between the EVM and Chromia networks.

- [Initialize your account](#initialize-your-account)
- [Approve token spending](#approve-token-spending)
- [Bridge tokens to Chromia](#bridge-tokens-to-chromia)
- [Verify token transfer](#verify-token-transfer)
- [Transfer funds back to EVM](#transfer-funds-back-to-evm)[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ“„ï¸Identifiers syntax** \\
Identifiers in Rell represent symbols that name variables, functions, and other keywords. Each identifier name must be](/rell/language-features/modules/identifiers-syntax)[**ğŸ“„ï¸Entity** \\
Entities in Rell are persistent data structures that reside in the database, not in memory. This means they offer](/rell/language-features/modules/entity)[**ğŸ“„ï¸Object** \\
An object is similar to an entity, but there can be only one instance of an object:](/rell/language-features/modules/object)[**ğŸ“„ï¸Struct** \\
A struct is similar to an entity, but its instances exist in memory, not in a database.](/rell/language-features/modules/struct)[**ğŸ“„ï¸Enum** \\
Enumeration types, or enums, creates maintainable sets of constants in Rell, enhancing code readability and preventing](/rell/language-features/modules/enum)[**ğŸ“„ï¸Query** \\
Queries provide a controlled way to retrieve data in Rell.](/rell/language-features/modules/query)[**ğŸ“„ï¸Operation** \\
Operations are declared using the operation keyword, followed by a unique operation name and a list of parameters](/rell/language-features/modules/operation)[**ğŸ“„ï¸Function** \\
In Rell, functions streamline repetitive tasks by encapsulating reusable logic, such as validation or data retrieval.](/rell/language-features/modules/function)[**ğŸ“„ï¸Abstract module** \\
Abstract modules and functions allow you to design reusable code components that you can adapt to specific needs within](/rell/language-features/modules/abstract)[**ğŸ“„ï¸Namespace** \\
Namespaces provide essential structure and clarity to your Rell projects, allowing for better organization and](/rell/language-features/modules/namespace)[**ğŸ“„ï¸External module** \\
The @external annotation allows a blockchain to access entities defined in another blockchain in the same container.](/rell/language-features/modules/external)[**ğŸ“„ï¸Mount names** \\
Entities, objects, operations, and queries have mount names:](/rell/language-features/modules/mount)[Skip to main content](#__docusaurus_skipToContent_fallback)

```codeBlockLines_e6Vv
Usage: chr eif [OPTIONS] COMMAND [ARGS]...

  Ethereum Integration Framework commands

â•­â”€ Options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  -h, --help  Show this message and exit                                     â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€ Commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  generate-events-config  Generate solidity events that EIF will listen to   â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

```

# generate-events-config

```codeBlockLines_e6Vv
Usage: chr eif generate-events-config [<options>]

  Generate solidity events that EIF will listen to

Options:
  --abi=<path>         Path to a JSON ABI file or a directory of JSON ABI files
  --events=<text>      Names of the relevant events (Comma separated)
  --target=<path>      Target file to generate events in (defaults to
                       "build/eif-events.yaml")
  --format=(XML|YAML)  Output file format
  -h, --help           Show this message and exit

```

The Ethereum Interoperability Framework (EIF) command `chr eif generate-events-config` allows you to generate Solidity
events related to certain actions within the dapp (for example, user registrations, token transfers, or other important
activities). EIF would monitor and use these events to monitor the Ethereum blockchain and trigger specific responses
when these events occur.[Skip to main content](#__docusaurus_skipToContent_fallback)

A default deployment of Filehub is readily available on the Chromia mainnet. You can access the user interface here:
[Filehub UI](https://filehub.chromia.com), where CHR tokens are used as the payment method for uploading files.

If you'd prefer to set up your own instance of Filehub and deploy custom Filechains, youâ€™re welcome to do so. The
project is open-source, and all the necessary repositories can be found here:
[Filehub Repositories](https://gitlab.com/chromaway/filehub).[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

```codeBlockLines_e6Vv
Usage: chr query [<options>] <queryname> [<args>]...

  Make a query towards a running node

  Examples:
  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
  â”‚# query primitive_args(arg1: integer, arg2: name, arg3: text, arg4:  â”‚
  â”‚byte_array, arg5: my_enum)                                           â”‚
  â”‚chr query primitive_args 'arg1=123' 'arg2=Alice' 'arg3="My Neighbor"'â”‚
  â”‚'arg4=x"AB12"' 'arg5=0'                                              â”‚
  â”‚# query dict_arg(arg: map<text, integer>)                            â”‚
  â”‚chr query dict_arg 'arg=["key": 12]'                                 â”‚
  â”‚# query map_arg(arg: map<my_enum, text>)                             â”‚
  â”‚chr query map_arg 'arg=[[0, "first"],[1, "second"]]'                 â”‚
  â”‚# query struct_arg(arg: my_struct)                                   â”‚
  â”‚chr query struct_arg 'arg=[12, "structs are arrays", x"AB"]'         â”‚
  â”‚                                                                     â”‚
  â”‚# Use -- do avoid additional quotes                                  â”‚
  â”‚chr query my_query -- arg1=foo arg2=x"AB12"                          â”‚
  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

Configuration Properties:
  -cfg, --config=<config>    Alternate path for client configuration file
  -s, --settings=<settings>  Alternate path for project settings file

Node:

  Target a test node

  -brid, --blockchain-rid=<text>  Target Blockchain RID
  --cid=<int>                     Target Blockchain IID
  --api-url=<text>                Target api url

Deployment:

  Use a configured deployment

  -d, --network=<text>      Specify which deployment target to use
  -bc, --blockchain=<text>  Name of blockchain in deployment configuration

Options:
  -f, --output-format=(pretty|raw|JSON|XML|YAML)  Output format
  -h, --help                                      Show this message and exit

Arguments:
  <queryname>  name of the query to make.
  <args>       arguments to pass to the query, passed either as key=value pairs
               or as a single dict. (integer: 123) (big_integer: 1234L)
               (string: foo, "bar") (bytearray: will be encoded using the rell
               notation x"<myByteArray>" and will initially be interpreted as a
               hex-string.) (array: [foo,123]) (dict:
               ["key1":value1,"key2":value2])

```

You can use the query command ( `chr query`) to test and interact with a chain that's either local or deployed without
using a client. You can set a path for the [project config file](/intro/configuration/project-config)
( `chromia.yml`) or specify a different file using `--settings`. In addition to that, you can change between a local and
deployed chain target with the `--deployment` and `--local` flags. The flag is `--local` by default.

## Node [â€‹](\#node "Direct link to Node")

When you start a node, you can see the [**Blockchain RID**](/intro/terminology#blockchain-rid-brid) as the standard
output. An example would look like this:
`Blockchain RID: FC17B67D66F6F35A5D8B75ED3F83AE222FB8C8FCA241624F06285150F10C6BAC`. If you run the node on a different
URL than the default `http://localhost:7740`, you can use the `--api-url` in the `chromia.yml` to specify it.

- To run the query `hello_world` specified in the `main.rell` file.

```codeBlockLines_e6Vv
chr query --blockchain-rid <BlockchainRID> hello_world

```

- If the query has arguments called `foo`, `bar` and `baz`, then the query would look like the following for the values
17, "hello" and "hello world" (quoting of strings is optional if they don't contain whitespace or special characters).

```codeBlockLines_e6Vv
chr query --blockchain-rid <BlockchainRID> hello_world foo=17 bar=hello 'baz="hello world"'

```

## Deployed [â€‹](\#deployed "Direct link to Deployed")

Towards a deployed chain, you can use the same commands as in a local environment, but you need to add a `--network`
(deployment target) and `--blockchain` (name of the chain to query) instead of the `--blockchain-rid`.

```codeBlockLines_e6Vv
chr query --network testnet --blockchain my_rell_dapp hello_world

```

- [Node](#node)
- [Deployed](#deployed)[Skip to main content](#__docusaurus_skipToContent_fallback)

```codeBlockLines_e6Vv
Usage: chr test [<options>]

  Run tests in working directory

Configuration Properties:
  -s, --settings=<settings>  Alternate path for project settings file

Options:
  -bc, --blockchain=<blockchain>
                                Run tests for specified blockchain(s). Can only
                                be a single chain if used together with -m
  -m, --modules=<modules>       Run tests in this module(s) only. Must be the
                                part of the specified modules or its
                                submodules. Comma delimited, will default to
                                all modules either under each selected
                                blockchain or test
  --sql-log                     Log sql expressions
  --tests=<>                    test method pattern
  --use-db / --no-db            If a session towards the configured database
                                should be established
  --test-report                 Generate JUnit XML test reports
  --test-report-dir=<path>      JUnit XML test reports directory (defaults to
                                "build/reports")
  --fail-on-error[=true|false]  Sets test execution to stop on error and
                                override any "failOnError" settings for tests
                                that are in the scope being executed
  -ts, --timestamp              Timestamp on logs
  -h, --help                    Show this message and exit

```

You can use the test command ( `chr test`) to run the tests specified in the `test` key in the
[project config file](/intro/configuration/project-config) ( `chromia.yml`).

- Runs all the tests under the test attribute if the current working directory is where the `chromia.yml` file exists:

```codeBlockLines_e6Vv
chr test

```

- Runs all the tests under the test attribute of a selected Project Settings file:

```codeBlockLines_e6Vv
chr test --settings chromia.yml

```

- Runs a specific test module:

```codeBlockLines_e6Vv
chr test --settings chromia.yml --modules test.data_test

```

- Runs test under test attribute for a specific blockchain:

```codeBlockLines_e6Vv
chr test --settings chromia.yml --blockchain <blockchain name>

```

- Runs all the tests based on the specified text filter:

```codeBlockLines_e6Vv
chr test --tests my_filter

```[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

This section guides you through cloning the
[chromia-bridge-demo](https://bitbucket.org/chromawallet/chromia-bridge-demo/src/main/) repository and configuring the
app to interact with your deployed token and bridge contracts.

## Clone the bridge demo repository [â€‹](\#clone-the-bridge-demo-repository "Direct link to Clone the bridge demo repository")

Begin by cloning the [chromia-bridge-demo](https://bitbucket.org/chromawallet/chromia-bridge-demo/src/main/) repository
to your local machine:

```codeBlockLines_e6Vv
git clone https://bitbucket.org/chromawallet/chromia-bridge-demo.git
cd chromia-bridge-demo

```

## Configure the `event_receiver` chain [â€‹](\#configure-the-event_receiver-chain "Direct link to configure-the-event_receiver-chain")

### Set the token bridge contract address [â€‹](\#set-the-token-bridge-contract-address "Direct link to Set the token bridge contract address")

Open the `./rell/chromia.yml` file and specify the token bridge contract address:

```codeBlockLines_e6Vv
blockchains:
  event_receiver:
    eif:
      chains:
        bsc:
          contracts: 0x7EE9dfbDF18c609a5e1AB0180c8A2ec6D473E093

```

### Install the FT4 Rell library [â€‹](\#install-the-ft4-rell-library "Direct link to Install the FT4 Rell library")

Install the required library for your project:

```codeBlockLines_e6Vv
chr install

```

### Build and run the event receiver [â€‹](\#build-and-run-the-event-receiver "Direct link to Build and run the event receiver")

To obtain the blockchain RID, build and start the event receiver:

```codeBlockLines_e6Vv
chr build
chr node start --name event_receiver --node-properties config/node-config.properties --wipe

```

You should see output indicating that the event receiver has started successfully:

```codeBlockLines_e6Vv
Starting node with pubkey: 0338BB1915D6DD2E343524CF48CFBD2B53DB2A099D44FAD1D1206F516872754542
INFO  2024-09-20 23:10:55.962 - [main] PostchainNode Exposing Prometheus metrics on port 9090
...
Starting blockchain event_receiver with brid 6613EA1B36823AA67D65C6104BB93A789089D0E568939FD6CBACCE6AFF1D0859 on id 0

```

## Configure the `bridge_demo` chain [â€‹](\#configure-the-bridge_demo-chain "Direct link to configure-the-bridge_demo-chain")

### Update the `bridge_demo` config [â€‹](\#update-the-bridge_demo-config "Direct link to update-the-bridge_demo-config")

In the same `./rell/chromia.yml` file, set the **blockchains > bridge\_demo > icmf.receiver > local > bc-rid** to the
blockchain RID obtained from the event receiver:

```codeBlockLines_e6Vv
bridge_demo:
  module: main
  config:
    ...
    icmf:
      receiver:
        local:
          - bc-rid: x"6613EA1B36823AA67D65C6104BB93A789089D0E568939FD6CBACCE6AFF1D0859"
            topic: "L_evm_block_events"

```

### Set ERC20 token properties [â€‹](\#set-erc20-token-properties "Direct link to Set ERC20 token properties")

Update the ERC20 token properties in the same file, specifying `bsc_asset_network_id` as `97`:

```codeBlockLines_e6Vv
bridge_demo:
  moduleArgs:
    main:
      bsc_asset_network_id: 97
      # Add other properties as needed

```

### Build the `bridge_demo` chain [â€‹](\#build-the-bridge_demo-chain "Direct link to build-the-bridge_demo-chain")

After updating the configuration, build and run the bridge demo chain:

```codeBlockLines_e6Vv
chr build
chr node start --node-properties config/node-config.properties

```

You should see both chains starting successfully:

```codeBlockLines_e6Vv
Starting blockchain event_receiver with brid 6613EA1B36823AA67D65C6104BB93A789089D0E568939FD6CBACCE6AFF1D0859 on id 0
Starting blockchain bridge_demo with brid AB889D51EECC3A063B2430084BB6EA5EC3A1EAB866AC62CAA553D8758933CADA on id 1

```

## Initialize the `bridge_demo` chain [â€‹](\#initialize-the-bridge_demo-chain "Direct link to initialize-the-bridge_demo-chain")

### Initialize the chain [â€‹](\#initialize-the-chain "Direct link to Initialize the chain")

To initialize the `bridge_demo` chain, run the following command:

```codeBlockLines_e6Vv
chr tx --api-url http://localhost:7740 -brid AB889D51EECC3A063B2430084BB6EA5EC3A1EAB866AC62CAA553D8758933CADA init

```

### Set the blockchain RID on the bridge contract [â€‹](\#set-the-blockchain-rid-on-the-bridge-contract "Direct link to Set the blockchain RID on the bridge contract")

To configure the bridge demo blockchain RID on the token bridge contract, follow these steps:

1. Navigate to the contract directory:





```codeBlockLines_e6Vv
cd postchain-eif/postchain-eif-contracts

```

2. Run the command to set the blockchain RID:

Execute the following command, replacing the placeholder values as needed:





```codeBlockLines_e6Vv
yarn setBlockchainRid:bridge --network bsc_testnet --address 0x7EE9dfbDF18c609a5e1AB0180c8A2ec6D473E093 --blockchain-rid AB889D51EECC3A063B2430084BB6EA5EC3A1EAB866AC62CAA553D8758933CADA

```


This command updates the token bridge contract with the specified blockchain RID, enabling it to interact with the
designated blockchain.

## Configure the frontend app [â€‹](\#configure-the-frontend-app "Direct link to Configure the frontend app")

### Copy and update environment variables [â€‹](\#copy-and-update-environment-variables "Direct link to Copy and update environment variables")

Copy the environment configuration file for the bridge frontend app:

```codeBlockLines_e6Vv
cp ./bridgefrontend/.env.local ./bridgefrontend/.env

```

Update the following variables in the `.env` file:

- `VITE_BRID`: Set this to the blockchain RID obtained from your event receiver (e.g.,
`6613EA1B36823AA67D65C6104BB93A789089D0E568939FD6CBACCE6AFF1D0859`).
- `VITE_BRIDGE_ADDRESS`: Set this to the deployed token bridge contract address (e.g.,
`0x7EE9dfbDF18c609a5e1AB0180c8A2ec6D473E093`).
- `VITE_TOKEN_ADDRESS`: Set this to the deployed token contract address (e.g.,
`0x22Ea9bF66Ee38E39A333773e584f37216136700A`).

### Run the bridge frontend app [â€‹](\#run-the-bridge-frontend-app "Direct link to Run the bridge frontend app")

Navigate to the `bridgefrontend` directory, install the dependencies, and start the app:

```codeBlockLines_e6Vv
cd ./bridgefrontend
pnpm install
pnpm run dev

```

![bridge demo frontend](/img/bridge_demo_frontend.png)

Now youâ€™re all set up to use the bridge demo app.

- [Clone the bridge demo repository](#clone-the-bridge-demo-repository)
- [Configure the `event_receiver` chain](#configure-the-event_receiver-chain)
  - [Set the token bridge contract address](#set-the-token-bridge-contract-address)
  - [Install the FT4 Rell library](#install-the-ft4-rell-library)
  - [Build and run the event receiver](#build-and-run-the-event-receiver)
- [Configure the `bridge_demo` chain](#configure-the-bridge_demo-chain)
  - [Update the `bridge_demo` config](#update-the-bridge_demo-config)
  - [Set ERC20 token properties](#set-erc20-token-properties)
  - [Build the `bridge_demo` chain](#build-the-bridge_demo-chain)
- [Initialize the `bridge_demo` chain](#initialize-the-bridge_demo-chain)
  - [Initialize the chain](#initialize-the-chain)
  - [Set the blockchain RID on the bridge contract](#set-the-blockchain-rid-on-the-bridge-contract)
- [Configure the frontend app](#configure-the-frontend-app)
  - [Copy and update environment variables](#copy-and-update-environment-variables)
  - [Run the bridge frontend app](#run-the-bridge-frontend-app)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

```codeBlockLines_e6Vv
Usage: chr tx [<options>] <opname> [<args>]...

  Make a transaction towards a node.

  Supports both specifying the target node using url and brid/id or from a
  deployment which is specified in the chromia.yml This will post the
  transaction asynchronously unless --await is specified, in which it will wait
  until transaction has been included in a block.

  FT4 compatibility: To make a transaction towards a dapp that uses
  ft-authentication, use the --ft-auth flag. This only works if the signer
  keypair is connected to a ft-account with the correct authentication rules.
  Use --ft-account-id to explicitly state which account to use if keypair is
  connected to more than one account. Node: This does not work with
  evm-authentication

  ICCF: To verify a transaction using ICCF, specify the tx-rid to verify using
  --iccf-tx and which chain id the transaction was processed. The command will
  both construct and insert a iccf_proof operation prior to the user operation
  but will also add the the transaction as a gtx_transaction as first argument
  to the user operation.

  Examples:
  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
  â”‚# operation primitive_args(arg1: integer, arg2: name, arg3: text, arg4:â”‚
  â”‚byte_array, arg5: my_enum)                                             â”‚
  â”‚chr tx primitive_args 123 Alice \"My Neighbor\" x\"AB12\" 0            â”‚
  â”‚# operation dict_arg(arg: map<text, integer>)                          â”‚
  â”‚chr tx dict_arg '["key": 12]'                                          â”‚
  â”‚# operation map_arg(arg: map<my_enum, text>)                           â”‚
  â”‚chr tx map_arg '[[0, "first"],[1, "second"]]'                          â”‚
  â”‚# operation struct_arg(arg: my_struct)                                 â”‚
  â”‚chr tx struct_arg '[12, "structs are arrays", x"AB"]'                  â”‚
  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

Configuration Properties:
  -cfg, --config=<config>    Alternate path for client configuration file
  -s, --settings=<settings>  Alternate path for project settings file

Node:

  Target a test node

  -brid, --blockchain-rid=<text>  Target Blockchain RID
  --cid=<int>                     Target Blockchain IID
  --api-url=<text>                Target api url

Deployment:

  Use a configured deployment

  -d, --network=<text>      Specify which deployment target to use
  -bc, --blockchain=<text>  Name of blockchain in deployment configuration

FT compatible dapps options:
  --ft-auth               Adds ft4.ft_auth operation for FT-compatible dapps
  --ft-account-id=<text>  Explicitly specify which account to use

Options:
  --secret=<path>           Path to secret file (pubkey/privkey)
  -a, --await / --no-await  Wait for transaction to be included in a block
  -nop                      Adds a nop to the transaction
  --iccf-tx=<text>          Constructs a ICCF-proof for this tx-rid and inserts
                            iccf_proof operation to the transaction. This will
                            also add the tx as a gtx_transaction as first
                            argument to the operation
  --iccf-source=<value>     Blockchain RID for the chain which the tx to be
                            confirmed has taken place
  -h, --help                Show this message and exit

Arguments:
  <opname>  name of the operation to execute.
  <args>    arguments to pass to the operation. (integer: 123) (big_integer:
            1234L) (string: foo, "bar") (bytearray: will be encoded using the
            rell notation x"<myByteArray>" and will initially be interpreted as
            a hex-string.) (array: [foo,123]) (dict:
            ["key1":value1,"key2":value2])

```

You can use the tx (transaction) command ( `chr tx`) in the same way as the query command, but you need to sign it with
your key pair. It can interact with either a local (Node) or deployed chain without the use of a client.

You can set a path for the [project config file](/intro/configuration/project-config) ( `chromia.yml`) or specify a
different file with the use of `--settings`. In addition to that, you can change between a local and deployed chain
target with the `--deployment` and `--local` flags. The flag is `--local` by default. Use the flag `-a` or `--await` to
wait for the confirmation or rejection of the transaction. To make the transaction hash unique, use the `- nop` flag if
you need to do the same transaction multiple times.

## Node [â€‹](\#node "Direct link to Node")

You can see the [**Blockchain RID**](/intro/terminology#blockchain-rid-brid) of the local node in the sout. An
example would look like the following:
`Blockchain RID: FC17B67D66F6F35A5D8B75ED3F83AE222FB8C8FCA241624F06285150F10C6BAC` If you are running the node on a
different URL than the default `http://localhost:7740`, you can use the `--api-url` in the `chromia.yml` to specify it.

- To perform a transaction with the operation `set_name` specified in the `main.rell` file.

```codeBlockLines_e6Vv
chr tx --blockchain-rid <BlockchainRID> --secret .secret set_name "string:name->bob"

```

- If you want to pass a dictionary as an argument, you have to single quote it to avoid incorrect shell parsing.

```codeBlockLines_e6Vv
chr tx set_name '["key1":value1,"key2":value2]'

```

## Deployed [â€‹](\#deployed "Direct link to Deployed")

Towards a deployed chain, you can do the same commands but need to add a `--name` (Deployment target) and `--blockchain`
(Name of the chain to query) instead of the `--blockchain-rid`.

```codeBlockLines_e6Vv
chr tx --network testnet --blockchain my_rell_dapp --secret .secret set_name "string:name->bob"

```

- [Node](#node)
- [Deployed](#deployed)[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ“„ï¸Simple types** \\
In Rell, there are several simple data types to represent different kinds of data. They're not composed of other data](/rell/language-features/types/simple-types)[**ğŸ“„ï¸Complex types** \\
Complex data types in the Rell programming language provide advanced features and capabilities beyond basic types like](/rell/language-features/types/complex-types)[**ğŸ“„ï¸Collection types** \\
Rell supports the following collection types:](/rell/language-features/types/collection-types)[**ğŸ“„ï¸Iterables** \\
Iterable values introduce a unified concept for processing sequences in various data structures. While the compiler uses](/rell/language-features/types/iterables)[**ğŸ“„ï¸Virtual types** \\
Virtual types use Merkle trees to efficiently verify data integrity and selectively retrieve specific elements.](/rell/language-features/types/virtual-types)[**ğŸ“„ï¸Subtypes** \\
In Rell, the concept of subtypes enhances code flexibility and reusability by allowing seamless assignment between](/rell/language-features/types/sub-types)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

```codeBlockLines_e6Vv
Usage: chr tools [OPTIONS] COMMAND [ARGS]...

  Miscellaneous tools

â•­â”€ Options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  -h, --help  Show this message and exit                                     â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€ Commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  gtv  Decode and convert GTV data                                           â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

```

You can use the tools command ( `chr tools`) provides a set of miscellaneous tools for various tasks related to Chromia.

## tools gtv [â€‹](\#tools-gtv "Direct link to tools gtv")

```codeBlockLines_e6Vv
Usage: chr tools gtv [<options>]

  Decode and convert GTV data

  Use --hex option or pipe binary GTV data to the command.

  Examples:
  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
  â”‚chr gtv --hex A41A3018300A0C0161A2050C03464F4F300A0C0162A2050C03424152â”‚
  â”‚chr gtv --output-format yaml < data.gtv                               â”‚
  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

Options:
  --hex=<hex>                                     Hex encoded GTV data
  -f, --output-format=(pretty|raw|JSON|XML|YAML)  Output format
  -h, --help                                      Show this message and exit

```

The gtv command `chr tools gtv` allows you to decode and convert GTV data.

- [tools gtv](#tools-gtv)[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ“„ï¸Values** \\
Rell offers various data types for managing information in your dapps. Here's an overview of the fundamental types](/rell/language-features/expressions/overview)[**ğŸ“„ï¸Operators** \\
Member access](/rell/language-features/expressions/operators)[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ“„ï¸Overview** \\
Rell provides several built-in functions for database operations. Rell allows both the comma notation and the and](/rell/language-features/database/overview)[**ğŸ“„ï¸Create statement** \\
Must specify all attributes that don't have default values:](/rell/language-features/database/create)[**ğŸ“„ï¸Update statement** \\
You can use operators @, @?, @\*, @+ to specify cardinality, like for the at-operator. A run-time error occurs if](/rell/language-features/database/update)[**ğŸ“„ï¸Delete statement** \\
You can use operators @, @?, @\*, @+ to specify cardinality, like for the at-operator. A run-time error occurs if](/rell/language-features/database/delete)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

This topic describes the steps to set up and manage a Filehub instance effectively. It covers how to register
Filechains, toggle file storage payments on or off, and establish cross-chain asset payments. Proper setup ensures
streamlined operations in file storage, payment handling, and Filechain management.

## Step 1: Initialize Filehub [â€‹](\#step-1-initialize-filehub "Direct link to Step 1: Initialize Filehub")

Start by initializing your Filehub with the required parameters. These should include the URL for the Directory Node and
the specific blockchain RID for your Filehub instance.

note

Make sure to install the filehub package via npm:

```codeBlockLines_e6Vv
npm install filehub

```

```codeBlockLines_e6Vv
const filehub = new Filehub({
  directoryNodeUrlPool: DIRECTORY_NODE_URL_POOL, // URL for Directory Node
  blockchainRid: FILEHUB_BLOCKCHAIN_RID, // Blockchain RID for the Filehub
});

```

## Step 2: Set up admin privileges [â€‹](\#step-2-set-up-admin-privileges "Direct link to Step 2: Set up admin privileges")

Use the private key of the Filehub or Filechain administrator to grant admin privileges, depending on which operations
you need to perform.

note

Make sure to install the [postchain-client](https://www.npmjs.com/package/postchain-client) package via npm if you
haven't already:

```codeBlockLines_e6Vv
npm install postchain-client

```

```codeBlockLines_e6Vv
const admin = newSignatureProvider({ privKey: FILEHUB_ADMIN_PRIVKEY });
const filehubAdministrator = new FilehubAdministrator(filehub, admin);

```

## Step 3: Register a Filechain [â€‹](\#step-3-register-a-filechain "Direct link to Step 3: Register a Filechain")

To enable a Filechain for file storage operations, register it with your Filehub. Providing an EVM address during
registration assigns administrative control over the Filechain and allows for fee collection.

```codeBlockLines_e6Vv
await filehubAdministrator.registerFilechain(
  FILECHAIN_BLOCKCHAIN_RID, // Unique RID for Filechain
  FILECHAIN_ADMIN_EVM_ADDRESS // Admin EVM address for the Filechain
);

```

## Step 4: Enable/Disable a Filechain [â€‹](\#step-4-enabledisable-a-filechain "Direct link to Step 4: Enable/Disable a Filechain")

You can disable a Filechain when its storage capacity is full or for maintenance purposes. Once disabled, the Filechain
will not accept any new file storage requests. Re-enable it when it is ready to handle new file uploads.

```codeBlockLines_e6Vv
// Disable a Filechain
await filehubAdministrator.disableFilechain(FILECHAIN_BLOCKCHAIN_RID);

// Enable a Filechain
await filehubAdministrator.enableFilechain(FILECHAIN_BLOCKCHAIN_RID);

```

## Step 5: Configure payment systems [â€‹](\#step-5-configure-payment-systems "Direct link to Step 5: Configure payment systems")

Configure the asset for file storage payments. Ideally, select an asset from the Economy Chain for this purpose.

```codeBlockLines_e6Vv
await filehubAdministrator.configureCrosschainAsset(ft4Asset, issuingChain);

```

## Step 6: Enable/Disable payments [â€‹](\#step-6-enabledisable-payments "Direct link to Step 6: Enable/Disable payments")

Administrators have the ability to enable or disable payments for file storage. Disabling payments stops file uploads
until you enable payments again.

```codeBlockLines_e6Vv
// Enable payments for file storage
await filehubAdministrator.enablePayments();

// Disable payments for file storage
await filehubAdministrator.disablePayments();

```

After completing these steps, your Filehub will be equipped to manage file storage, handle payments, and oversee
Filechain operations efficiently. For more detailed configurations and integrations, consult the Filehub API
documentation.

- [Step 1: Initialize Filehub](#step-1-initialize-filehub)
- [Step 2: Set up admin privileges](#step-2-set-up-admin-privileges)
- [Step 3: Register a Filechain](#step-3-register-a-filechain)
- [Step 4: Enable/Disable a Filechain](#step-4-enabledisable-a-filechain)
- [Step 5: Configure payment systems](#step-5-configure-payment-systems)
- [Step 6: Enable/Disable payments](#step-6-enabledisable-payments)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Filehub allows users to store files on-chain and retrieve them using the
[Filehub NPM package](https://www.npmjs.com/package/filehub). A Gateway is also available for easy file access,
supporting various use cases such as images, videos, and static websites.

## Filehub client [â€‹](\#filehub-client "Direct link to Filehub client")

### Fetching a file [â€‹](\#fetching-a-file "Direct link to Fetching a file")

To retrieve a file stored in Filehub, use the following code:

```codeBlockLines_e6Vv
const { Filehub } = require("filehub");
const filehub = new Filehub({
  directoryNodeUrlPool: DIRECTORY_NODE_URL_POOL,
  blockchainRid: FILEHUB_BLOCKCHAIN_RID,
});

const file = await filehub.getFile(fileHash);

```

### Storing a file [â€‹](\#storing-a-file "Direct link to Storing a file")

To store a file in Filehub, utilize the following example:

```codeBlockLines_e6Vv
const { Filehub, FsFile } = require("filehub");
const filehub = new Filehub({
  directoryNodeUrlPool: DIRECTORY_NODE_URL_POOL,
  blockchainRid: FILEHUB_BLOCKCHAIN_RID,
});

const file = FsFile.fromData(buffer, { contentType: "image/jpeg" });
await filehub.storeFile(ft4Session, file);

```

## Payment model [â€‹](\#payment-model "Direct link to Payment model")

Filehub operates on a one-time payment model, charging users **$0.10 per megabyte** for permanent file storage. Unlike
traditional storage solutions that may rely on random hard drives with uncertain longevity, Filehub ensures that files
are fully stored on-chain, providing a guarantee of long-term accessibility.

note

Currently, Filehub operates on a general-purpose cluster, which is not specifically optimized for storage needs. As a
result, the available storage capacity is somewhat limited. The initial release of Filehub aims to support projects on
Chromia while providing early adopters an opportunity to explore its capabilities and potential applications. Looking
ahead, we anticipate the introduction of dedicated storage-optimized clusters on the mainnet, which would enable us to
significantly reduce storage costs for users.

## Filehub APIs [â€‹](\#filehub-apis "Direct link to Filehub APIs")

Filehub offers a robust API for managing Filechains, facilitating file storage, and configuring payments. Key operations
include:

- **Registering a Filechain**: Assign a new Filechain with administrative privileges.
- **Enabling/Disabling Filechains**: Control the availability of Filechains based on storage requirements.
- **Managing Payments**: Enable or disable payments for file storage and configure the assets used for transactions.

#### Example [â€‹](\#example "Direct link to Example")

Hereâ€™s how to register a new Filechain using the Filehub Administrator API:

```codeBlockLines_e6Vv
const filehub = new Filehub({
  directoryNodeUrlPool: DIRECTORY_NODE_URL_POOL,
  blockchainRid: FILEHUB_BLOCKCHAIN_RID,
});

const admin = newSignatureProvider({ privKey: FILEHUB_ADMIN_PRIVKEY });
const filehubAdministrator = new FilehubAdministrator(filehub, admin);

// Register a Filechain
await filehubAdministrator.registerFilechain(FILECHAIN_BLOCKCHAIN_RID, FILECHAIN_ADMIN_EVM_ADDRESS);

```

- [Filehub client](#filehub-client)
  - [Fetching a file](#fetching-a-file)
  - [Storing a file](#storing-a-file)
- [Payment model](#payment-model)
- [Filehub APIs](#filehub-apis)[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ—ƒï¸Types** \\
6 items](/category/types)[**ğŸ—ƒï¸Module definitions** \\
12 items](/category/module-definitions)[**ğŸ—ƒï¸Expressions** \\
2 items](/category/expressions)[**ğŸ—ƒï¸Statements** \\
5 items](/category/statements)[**ğŸ—ƒï¸Database operations** \\
4 items](/category/database-operations)[**ğŸ—ƒï¸System library** \\
6 items](/category/system-library)[**ğŸ“„ï¸Comments** \\
Rell supports single-line and multi-line (block) comments.](/rell/language-features/comments)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

```codeBlockLines_e6Vv
Usage: chr multi-signature [OPTIONS] COMMAND [ARGS]...

  Handle transactions with need of multiple signers

â•­â”€ Options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  -h, --help  Show this message and exit                                     â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€ Commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  create  Creates a new transaction for multi signature and signs it with    â”‚
â”‚          your key                                                           â”‚
â”‚  sign    Sign a existing transaction with your key                          â”‚
â”‚  send    Send a fully signed transaction                                    â”‚
â”‚  view    View a existing transaction                                        â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

```

You can use the multi-signature command ( `chr multi-signature`) for handling transactions that need multiple signers.

## multi-signature create [â€‹](\#multi-signature-create "Direct link to multi-signature create")

```codeBlockLines_e6Vv
Usage: chr multi-signature create [<options>] <opname> [<args>]...

  Creates a new transaction for multi signature and signs it with your key

Configuration Properties:
  -cfg, --config=<config>    Alternate path for client configuration file
  -s, --settings=<settings>  Alternate path for project settings file

Node:

  Target a test node

  -brid, --blockchain-rid=<text>  Target Blockchain RID
  --cid=<int>                     Target Blockchain IID
  --api-url=<text>                Target api url

Deployment:

  Use a configured deployment

  -d, --network=<text>      Specify which deployment target to use
  -bc, --blockchain=<text>  Name of blockchain in deployment configuration

FT compatible dapps options:
  --ft-auth               Adds ft4.ft_auth operation for FT-compatible dapps
  --ft-account-id=<text>  Explicitly specify which account to use
  -id, --auth-descriptor-id=<text>
                          Explicitly specify which auth descriptor id to use

Options:
  --secret=<path>        Path to secret file (pubkey/privkey)
  --signers-file=<path>  Path to file containing public keys of signers
                         (pubkey1=x,pubkey2=y,...)
  --target=<path>        Path where file should be saved
  -h, --help             Show this message and exit

Arguments:
  <opname>  name of the operation to execute.
  <args>    arguments to pass to the operation. (integer: 123) (big_integer:
            1234L) (string: foo, "bar") (bytearray: will be encoded using the
            rell notation x"<myByteArray>" and will initially be interpreted as
            a hex-string.) (array: [foo,123]) (dict:
            ["key1":value1,"key2":value2])

```

The create command `chr multi-signature create` allows you to create a new transaction for multi signature and signs it
with your key.

## multi-signature sign [â€‹](\#multi-signature-sign "Direct link to multi-signature sign")

```codeBlockLines_e6Vv
Usage: chr multi-signature sign [<options>]

  Sign a existing transaction with your key

Configuration Properties:
  -cfg, --config=<config>  Alternate path for client configuration file

Options:
  -f, --file=<path>   Path to file of transaction
  --secret=<path>     Path to secret file (pubkey/privkey)
  --target=<path>     Path where file should be saved
  --file-name=<text>  Override default name of output file
  -h, --help          Show this message and exit

```

The sign command `chr multi-signature sign` allows you to sign a existing transaction with your key.

## multi-signature send [â€‹](\#multi-signature-send "Direct link to multi-signature send")

```codeBlockLines_e6Vv
Usage: chr multi-signature send [<options>]

  Send a fully signed transaction

Configuration Properties:
  -cfg, --config=<config>    Alternate path for client configuration file
  -s, --settings=<settings>  Alternate path for project settings file

Node:

  Target a test node

  -brid, --blockchain-rid=<text>  Target Blockchain RID
  --cid=<int>                     Target Blockchain IID
  --api-url=<text>                Target api url

Deployment:

  Use a configured deployment

  -d, --network=<text>      Specify which deployment target to use
  -bc, --blockchain=<text>  Name of blockchain in deployment configuration

Options:
  --secret=<path>           Path to secret file (pubkey/privkey)
  -a, --await / --no-await  Wait for transaction to be included in a block
  -f, --file=<path>         Path to file of transaction
  -h, --help                Show this message and exit

```

The send command `chr multi-signature send` allows you to send a fully signed transaction.

## multi-signature view [â€‹](\#multi-signature-view "Direct link to multi-signature view")

```codeBlockLines_e6Vv
Usage: chr multi-signature view [<options>]

  View a existing transaction

Options:
  -f, --file=<path>  Path to file of transaction
  -h, --help         Show this message and exit

```

The view command `chr multi-signature view` allows you to view a existing transaction.

- [multi-signature create](#multi-signature-create)
- [multi-signature sign](#multi-signature-sign)
- [multi-signature send](#multi-signature-send)
- [multi-signature view](#multi-signature-view)[Skip to main content](#__docusaurus_skipToContent_fallback)

```codeBlockLines_e6Vv
Usage: chr code [OPTIONS] COMMAND [ARGS]...

  Code quality management (formatting, linting)

â•­â”€ Options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  -h, --help  Show this message and exit                                     â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€ Commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  lint    Analyze Rell code to find potential issue and coding style         â”‚
â”‚          violations. Configurable using .rell_lint file                     â”‚
â”‚  format  Automatically format Rell code. Configurable using .rell_format    â”‚
â”‚          file                                                               â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

```

You can use the code command ( `chr code`) for code quality management (formatting and linting).

# code lint

```codeBlockLines_e6Vv
Usage: chr code lint [<options>]

  Analyze Rell code to find potential issue and coding style violations.
  Configurable using .rell_lint file

Configuration Properties:
  -s, --settings=<settings>  Alternate path for project settings file

Options:
  --source-dir=<path>           source directory
  -fo, --formatter-options=<path>
                                Formatter options file (default '.rell_format')
  -lo, --linter-options=<path>  Linter options file (default '.rell_lint')
  --fix                         Fix all auto-fixable issues
  -h, --help                    Show this message and exit

```

The lint command `chr code lint` allows you to analyze Rell code to find potential issue and coding style.

# code format

```codeBlockLines_e6Vv
Usage: chr code format [<options>]

  Automatically format Rell code. Configurable using .rell_format file

Configuration Properties:
  -s, --settings=<settings>  Alternate path for project settings file

Options:
  --source-dir=<path>  source directory
  --file=<path>        single Rell file
  -fo, --formatter-options=<path>
                       Formatter options file (default '.rell_format')
  -h, --help           Show this message and exit

```

The format command `chr code format` allows you to automatically format Rell code. It can be configured by using
`.rell_format`.[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

If you donâ€™t have an existing ERC20 token to deploy, you can use one from the
[Postchain EIF Contracts repository](https://gitlab.com/chromaway/core/postchain-eif/-/tree/dev/postchain-eif-contracts/).
In this example, we will deploy the `ALICE` token using its
[contract](https://gitlab.com/chromaway/core/postchain-eif/-/blob/dev/postchain-eif-contracts/contracts/token/AliceToken.sol).

## Prerequisites [â€‹](\#prerequisites "Direct link to Prerequisites")

Before proceeding, ensure you have the following:

- **ERC20 token contract**: Use the `ALICE` token or any other ERC20 contract.
- **Node.js and Yarn**: Ensure both are installed on your system.
- **MetaMask**: Install and configure MetaMask, and
[connect it to the BSC Testnet](https://academy.binance.com/en/articles/connecting-metamask-to-binance-smart-chain#How-to-Manually-Add-a-Network-to-MetaMask).
- **BNB for gas fees**: Obtain some BNB for gas fees from the
[BSC Testnet Faucet](https://www.bnbchain.org/en/testnet-faucet).

## Step 1: Clone the `postchain-eif-contracts` repository [â€‹](\#step-1-clone-the-postchain-eif-contracts-repository "Direct link to step-1-clone-the-postchain-eif-contracts-repository")

First, clone the repository containing the token contracts:

```codeBlockLines_e6Vv
git clone https://gitlab.com/chromaway/core/postchain-eif.git
cd postchain-eif/postchain-eif-contracts

```

## Step 2: Install dependencies [â€‹](\#step-2-install-dependencies "Direct link to Step 2: Install dependencies")

Install all required project dependencies by running the following command:

```codeBlockLines_e6Vv
yarn install

```

tip

If you encounter any issues, try removing the `yarn.lock` file and regenerating it with the following commands:

```codeBlockLines_e6Vv
rm yarn.lock
yarn install

```

## Step 3: Set up environment variables [â€‹](\#step-3-set-up-environment-variables "Direct link to Step 3: Set up environment variables")

Youâ€™ll need to create a `.env` file to store sensitive information, such as your mnemonic and API keys.

Create the `.env` file by copying the example:

```codeBlockLines_e6Vv
cp .env.example .env

```

Edit the `.env` file with your details:

```codeBlockLines_e6Vv
MNEMONIC="your mnemonic phrase"
BSC_TESTNET_RPC_URL="https://data-seed-prebsc-1-s1.binance.org:8545/"

```

- **`MNEMONIC`**: This is the mnemonic from your
[MetaMask](https://support.metamask.io/privacy-and-security/how-to-reveal-your-secret-recovery-phrase/) wallet or
another wallet you control.
- **`BSC_TESTNET_RPC_URL`**: URL for the Binance Smart Chain (BSC) Testnet.

## Step 4: Compile the contract [â€‹](\#step-4-compile-the-contract "Direct link to Step 4: Compile the contract")

Before deploying, ensure the contract is compiled:

```codeBlockLines_e6Vv
yarn compile

```

This will generate the compiled contract artifacts.

## Step 5: Deploy the `ALICE` token to BSC Testnet [â€‹](\#step-5-deploy-the-alice-token-to-bsc-testnet "Direct link to step-5-deploy-the-alice-token-to-bsc-testnet")

To deploy the `ALICE` ERC20 token contract, use the provided deployment script from the repository:

```codeBlockLines_e6Vv
yarn deploy:alice --network bsc_testnet

```

- `deploy:alice`: This script handles the deployment of the `ALICE` token contract.
- `--network bsc_testnet`: Specifies that the contract should be deployed to the Binance Smart Chain (BSC) Testnet.

Upon a successful deployment, the terminal will display the contract's address. For example:

```codeBlockLines_e6Vv
token deployed to:  0x22Ea9bF66Ee38E39A333773e584f37216136700A

```

tip

Be sure to copy and save the deployed contract address for later use.

- [Prerequisites](#prerequisites)
- [Step 1: Clone the `postchain-eif-contracts` repository](#step-1-clone-the-postchain-eif-contracts-repository)
- [Step 2: Install dependencies](#step-2-install-dependencies)
- [Step 3: Set up environment variables](#step-3-set-up-environment-variables)
- [Step 4: Compile the contract](#step-4-compile-the-contract)
- [Step 5: Deploy the `ALICE` token to BSC Testnet](#step-5-deploy-the-alice-token-to-bsc-testnet)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Here's the list of commands in Chromia CLI:

```codeBlockLines_e6Vv
Usage: chr [OPTIONS] COMMAND [ARGS]...

â•­â”€ Options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  --generate-completion=(bash|zsh|fish)                                      â”‚
â”‚  --version                              Show the version and exit           â”‚
â”‚  -h, --help                             Show this message and exit          â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€ Commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  build             Build an application and create a blockchain             â”‚
â”‚                    configuration                                            â”‚
â”‚  create-rell-dapp  Generates a template project                             â”‚
â”‚  deployment        Create and maintain deployments                          â”‚
â”‚  eif               Ethereum Integration Framework commands                  â”‚
â”‚  generate          Generate client stubs and documentation for a rell       â”‚
â”‚                    project                                                  â”‚
â”‚  install           Install library dependencies, if no library specified allâ”‚
â”‚                    will be installed                                        â”‚
â”‚  keygen            Generates public/private key pair                        â”‚
â”‚  node              Interact with a test node                                â”‚
â”‚  query             Make a query towards a running node                      â”‚
â”‚  repl              REPL is used to create a language shell for Rell that    â”‚
â”‚                    takes single user inputs, executes them, and returns the â”‚
â”‚                    result.                                                  â”‚
â”‚  test              Run tests in working directory                           â”‚
â”‚  tx                Make a transaction towards a node.                       â”‚
â”‚  code              Code quality management (formatting, linting)            â”‚
â”‚  multi-signature   Handle transactions with need of multiple signers        â”‚
â”‚  tools             Miscellaneous tools                                      â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

```

note

The default option of using Chromia CLI to interact with the Chromia blockchain is `--use-db`. If you want to use it
without the database, then use `--no-db`.

## Set up auto completion [â€‹](\#set-up-auto-completion "Direct link to Set up auto completion")

The command `chr --generate-completion [bash|zsh|fish]` generates shell-specific completion scripts. It enhances the
command-line experience when using the `chr` command by providing auto-completion suggestions for command names,
options, and arguments.

You need to provide one of the specified shell options ( `bash`, `zsh`, or `fish`) to indicate which type of completion
script you want to generate. You have to choose the corresponding option depending on the shell you use.

For example:

- `chr --generate-completion bash >> ~/chr.sh` generates a file with Bash completion script for the `chr` command.
- `chr --generate-completion zsh >> ~/chr.zsh` generates a file with Zsh completion script for the `chr` command.
- `chr --generate-completion fish >> ~/chr.fish` generates a file with Fish completion script for the `chr` command.

These generated files shall then be sourced or included in your respective shell configuration files (such as `.bashrc`,
`.zshrc`, or `config.fish`) to enable auto-completion for the `chr` command whenever you use that shell.

note

You can also use the first two letters of each command and subcommands as a command shortcut. For example, `chr de cr`
is the same as `chr deployment create`.

- [Set up auto completion](#set-up-auto-completion)[Skip to main content](#__docusaurus_skipToContent_fallback)

FT4 provides tools to easily manage your assets, such as tokens, on the Chromia blockchain. You can register new assets,
track their details, and transfer them across different blockchains.

[FT4 allows you to register and track assets with important details like name, symbol, and supply. You can register assets using either the admin operation or custom methods, making it easy to manage and transfer them within the system.](/ft4/asset-management/asset) [FT4 allows asset transfers within the same blockchain (on-chain) and across different blockchains in the Chromia network (cross-chain). It also supports transfers to EVM-compatible blockchains like Ethereum through a bridge, expanding asset usability across multiple platforms.](/ft4/asset-management/transfer-assets)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

```codeBlockLines_e6Vv
Usage: chr generate [OPTIONS] COMMAND [ARGS]...

  Generate client stubs and documentation for a rell project

â•­â”€ Options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  -h, --help  Show this message and exit                                     â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€ Commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  client-stubs  Generates client code for a rell dapp                        â”‚
â”‚  graph         Generates entity relation graphs in mermaid format           â”‚
â”‚  docs-site     Generate a documentation site for a dapp ontology            â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

```

## generate client-stubs [â€‹](\#generate-client-stubs "Direct link to generate client-stubs")

```codeBlockLines_e6Vv
Usage: chr generate client-stubs [<options>]

  Generates client code for a rell dapp

Configuration Properties:
  -s, --settings=<settings>  Alternate path for project settings file

kotlin:
  --package=<text>  Name of package

Options:
  -m, --module=<text>  Explicitly set which modules to generate code for.
                       Separate modules with ','
  -d, --target=<path>  Directory to generate code in
  --kotlin, --typescript, --javascript
                       Language to generate client for
  -h, --help           Show this message and exit

```

The client-stubs command ( `chr generate client-stubs`) generates code that can be used to communicate with the Rell
backend.

## generate graph [â€‹](\#generate-graph "Direct link to generate graph")

```codeBlockLines_e6Vv
Usage: chr generate graph [<options>]

  Generates entity relation graphs in mermaid format

Configuration Properties:
  -s, --settings=<settings>  Alternate path for project settings file

Options:
  -m, --module=<text>  Explicitly set which modules to generate code for.
                       Separate modules with ','
  -d, --target=<path>  Directory to generate code in
  --mdx                Surround with mdx tags
  --entity-relation / --class-diagram
                       Presented as entity relation diagram or class diagram
  -h, --help           Show this message and exit

```

The graph command ( `chr generate graph`) generates mermaid graphs, helping to visualize the entity relations of a dapp.

Using the `--entity-relation`/ `--class-diagram` options, you can decide whether to present each entity as a class or a
database entity.

If the graph is intended to be shown in a markdown file, you can use the `--mdx` flag to wrap the generated code in a
code block. This is useful, for example, when including the graph in a [docasaurus](https://docusaurus.io) site or
[Github Wiki](https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/creating-diagrams).

## generate docs-site [â€‹](\#generate-docs-site "Direct link to generate docs-site")

```codeBlockLines_e6Vv
Usage: chr generate docs-site [<options>]

  Generate a documentation site for a dapp ontology

Configuration Properties:
  -s, --settings=<settings>  Alternate path for project settings file

Options:
  -d, --target=<path>   Directory to generate code in
  -i, --include=<text>  Libs to actively include in the navigation of the
                        generated docs site, by default all are excluded. To
                        include a library, the full identifier must be
                        specified as an example for the library foo, the
                        inclusion of it would be lib.foo
  -h, --help            Show this message and exit

```

The generate docs-site command ( `chr generate docs-site`) generates a complete site that documents the API of your dapp.

Configure the output by adding a `docs` section to `chromia.yml`:

chromia.yml

```codeBlockLines_e6Vv
docs:
  title: My Rell Dapp
  footerMessage: Â© 2024 Copyright MyCompany
  customStyleSheets:
    - my-styles.css
  customAssets:
    - my-logo.png
  additionalContent:
    - my-doc.md
  sourceLink:
    remoteUrl: https://github.com/my-org/my-repo/blob/main/src
    remoteLineSuffix: "#L"

```

For more information on the configuration properties, see [project config](/intro/configuration/project-config).

The generated site contains JS code to provide a navigation bar. Although you can open the `index.html` page in your
browser, the best experience is achieved by hosting the site on a web server.

This can be done using docker:

```codeBlockLines_e6Vv
docker run -dit --name my-docs-site -p 8080:80 -v "$PWD":/usr/local/apache2/htdocs/ httpd:2.4

```

Or, if you already have a node-js project:

```codeBlockLines_e6Vv
npm install http-server
npx http-server

```

- [generate client-stubs](#generate-client-stubs)
- [generate graph](#generate-graph)
- [generate docs-site](#generate-docs-site)[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ“„ï¸chain\_context** \\
The chaincontext.args field contains the module arguments specified in the chromia.yml configuration file. The moduleargs field must be defined as a user-defined struct within the entry point module named modulename. Access to the args field is only possible if the moduleargs struct is defined.](/rell/language-features/systemlib/namespaces/chain_context)[**ğŸ“„ï¸op\_context** \\
You can only use system namespace op\_context in an operation or a function called from an operation, but not in a query.](/rell/language-features/systemlib/namespaces/op_context)[**ğŸ“„ï¸crypto** \\
Namespace used for cryptographic functions.](/rell/language-features/systemlib/namespaces/crypto)[**ğŸ“„ï¸meta** \\
Gets meta-information (like the mount name of an operation).](/rell/language-features/systemlib/namespaces/meta)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

The release notes lists all new features, resolved issues, and known issues of Chromia CLI in chronological order.

## Chromia CLI 0.20.13 [â€‹](\#chromia-cli-02013 "Direct link to Chromia CLI 0.20.13")

Released on November 6, 2024.

| New features | Fixed issues |
| --- | --- |
| **Error messaging**<br> \- Improved error messages. <br>**Static web building**<br> \- Enables building static web content without Rell sources. <br>**GTV data tool**<br> \- New `chr tools gtv` command added for GTV data decoding and conversion. | \- Static web hosting support in `chr node`. <br> \- Prevents invalid XML characters in blockchain configuration. <br> \- Explicit file type and name selection required for key storage to avoid accidental key overwrites. <br> \- Corrected help text formatting. |

## Chromia CLI 0.21.0 [â€‹](\#chromia-cli-0210 "Direct link to Chromia CLI 0.21.0")

Released on October 23, 2024.

| New features | Fixed issues |
| --- | --- |
| **Multi-signature transaction support**<br> \- `chr multi-signature create` for creating multi-signature transactions with specified signers and signature initialization. <br> \- `chr multi-signature sign` enables users to add signatures with customizable keypair options. <br> \- `chr multi-signature send` allows submission of fully signed transactions. <br> \- `chr multi-signature view` to display multi-signature transaction details. <br>**Static web content packaging**<br> \- Static web content can be packaged into blockchain configurations for direct Chromia node serving (requires Postchain 3.21+). <br>**Java 21 dependency**<br> \- Updated package managers now include a Java 21 dependency for `chr` execution. Users can control the Java version via the `RELL_JAVA` environment variable. | \- Exit status code is now 1 instead of 0 when the project settings file is not found. <br> \- Prevents escaping of non-ASCII and regular Unicode characters in `query` command raw output. <br>**Formatter fixes**<br> \- Fixed extra space after the first parenthesis in `at` expressions. <br> \- Doc comments are no longer lifted onto the same line as the previous definition when lacking additional newline. |

## Chromia CLI 0.20.14 [â€‹](\#chromia-cli-02014 "Direct link to Chromia CLI 0.20.14")

Released on September 26, 2024.

| New features | Fixed issues |
| --- | --- |
| **Client stub documentation**<br> \- Rell docs comments are now transformed into JS/TS/Kotlin docs comments when generating client stubs. <br>**Test flag**<br> \- A new `--timestamp` flag for tests allows including timestamps in terminal output for execution duration tracking. <br>**Deployment renaming**<br> \- New command `chr deployment proposal rename` creates a proposal to change the name of a deployed blockchain. | \- Fixed an issue where whitespace was incorrectly added after the first and before the last parenthesis in a multiline `"where"` expression. <br> \- Updated Chromia model to disallow hyphens in blockchain names, ensuring compatibility with directory chain specification. |

## Chromia CLI 0.20.13 [â€‹](\#chromia-cli-02013-1 "Direct link to Chromia CLI 0.20.13")

Released on September 11, 2024.

| New features | Fixed issues |
| --- | --- |
| **YAML anchoring**<br> \- Anchored values in the config file now respect the original type when included in attributes. <br> \- Recursively anchored values in the config file now respect the original type when included in attributes. <br>**Formatter improvements**<br> \- Rell files created with `chr create-rell-dapp` are now formatted according to default settings. | Removed unsupported SQL modules from the `chromia.yml` schema. <br>**Formatter fixes**<br> \- Fixed an issue where the formatter added an extra newline after a Rell docs comment when followed by an annotation. <br> \- Resolved an issue where whitespace was incorrectly added after the first and before the last parenthesis in a multiline `"what"` expression. |

## Chromia CLI 0.20.12 [â€‹](\#chromia-cli-02012 "Direct link to Chromia CLI 0.20.12")

Released on August 30, 2024.

| New features | Fixed issues |
| --- | --- |
| **Java 21 upgrade**<br> \- Upgraded to Java 21, which is now required for `chr`. <br>**Rell version update**<br> \- Updated to Rell 0.14.1. <br>**Documentation generation**<br> \- Excludes all libraries from navigation pages by default when generating docs with `chr generate docs-site`. To include a library, use `--include=lib.<name of lib>`. <br>**Custom GTX modules**<br> \- Allows custom GTX modules in blockchain config to be deployed. <br>**New command: `chr deployment voterset add-dapp-provider`**<br> \- Enables users with the Dapp Provider role to add others to the role within the network. | Resolved an issue displaying null bridges after failed deployments. <br>**Plugins and package upgrades**<br> \- Updated several plugins and packages: <br> \-\- Dokka plugin 0.2.7 <br> \-\- Rell Maven plugin 0.12.3 <br> \-\- Rell Gradle plugin 0.3.3 <br> \-\- Codegen 0.14.2 <br> \- Java 21 and Rell 0.14.1 upgrades applied across plugins. |

## Chromia CLI 0.20.9 [â€‹](\#chromia-cli-0209 "Direct link to Chromia CLI 0.20.9")

Released on August 20, 2024.

| New features | Fixed issues |
| --- | --- |
| **Voterset and proposal functions**<br> \- Adds two functions (experimental) for interacting with votersets and proposals for deployed dapps: <br> \-\- `chr deployment voterset` to manage your own votersets and view others' votersets. <br> \-\- `chr deployment proposal` to manage proposals within votersets accessible to your pubkey. <br>**Rell compile version**<br> \- Updated the default Rell compile version to 0.13.14, aligning with mainnet. Custom target versions can be specified in `chromia.yml` under `compile:rellVersion`. | N/A |

## Chromia CLI 0.20.8 [â€‹](\#chromia-cli-0208 "Direct link to Chromia CLI 0.20.8")

Released on August 12, 2024.

| New features | Fixed issues |
| --- | --- |
| N/A | Updated to the latest formatter to fix syntax errors. |

## Chromia CLI 0.20.7 [â€‹](\#chromia-cli-0207 "Direct link to Chromia CLI 0.20.7")

Released on August 12, 2024.

| New features | Fixed issues |
| --- | --- |
| **Code lint and format updates**<br> \- `chr code lint` and `chr code format` commands now ignore libraries defined in `chromia.yml` by default. To run these commands on external libraries, use the `--source-dir` option to specify the library path. | N/A |

## Chromia CLI 0.20.6 [â€‹](\#chromia-cli-0206 "Direct link to Chromia CLI 0.20.6")

Released on August 1, 2024.

| New features | Fixed issues |
| --- | --- |
| **Rell linter and formatter**<br> \- `chr code lint` analyzes Rell code for potential issues and coding style violations, configurable via `.rell_lint` file. <br> \- `chr code format` automatically formats Rell code, configurable via `.rell_format` file. | \- Documentation generator now includes doc comments of child attributes on the parent page. <br> \- Improved formatter handling of newlines after single-line comments. <br> \- Enhanced error message when attempting to create a deployment for an already defined chain in `chromia.yml`. |

## Chromia CLI 0.20.4 [â€‹](\#chromia-cli-0204 "Direct link to Chromia CLI 0.20.4")

Released on July 11, 2024.

| New features | Fixed issues |
| --- | --- |
| N/A | Fixed an issue in docs generation where the `@see` tag in user Rell docs caused duplicate text. |

## Chromia CLI 0.20.3 [â€‹](\#chromia-cli-0203 "Direct link to Chromia CLI 0.20.3")

Released on July 08, 2024.

| New features | Fixed issues |
| --- | --- |
| **User-defined docs**<br> \- `chr generate docs-site` now includes user-defined docs comments in the generated documentation site. | `chr tx` now waits for transaction confirmation by default. Use `--no-await` to skip waiting. |

## Chromia CLI 0.20.2 [â€‹](\#chromia-cli-0202 "Direct link to Chromia CLI 0.20.2")

Released on June 18, 2024.

| New features | Fixed issues |
| --- | --- |
| **Example usage documentation**<br> \- Added documentation for `query` and `tx` commands, including examples of how to use complex argument types. | \- Fixed code generation for boolean Rell types, now correctly typed as `number` in TypeScript queries and operations (input and return). <br> \- Code generation now exits with a non-zero exit code if unsuccessful. |

## Chromia CLI 0.20.1 [â€‹](\#chromia-cli-0201 "Direct link to Chromia CLI 0.20.1")

Released on June 05, 2024.

| New features | Fixed issues |
| --- | --- |
| **New config property**<br> \- Added `add_primary_key_to_header` to config, defaulting to `true` (impacts `brid` for chains). <br>**JSON output support**<br> \- `deployment inspect` and `deployment info` commands now support JSON output with the new argument --output-format=(table \|JSON), defaulting to table format. Automatically defaults to JSON when output is piped. | \- Renamed `--url` flag to `--api-url` for `deployment info/inspect` commands for consistency. <br> \- Improved `chr install` speed by up to 15%. |

## Chromia CLI 0.20.0 [â€‹](\#chromia-cli-0200 "Direct link to Chromia CLI 0.20.0")

Released on May 30, 2024.

| New features | Fixed issues |
| --- | --- |
| **Enhanced output formatting**<br> \- Added pretty print for `chr query` results. <br> \- New `--output-format` flag for `chr repl` and `chr query`, supporting JSON, XML, and raw output. <br> \- `chr repl` command now supports input piping. <br>**Configuration validation**<br> \- `chr deployment update` now signs configuration validation requests to restrict execution to blockchain owners. <br>**Documentation generation**<br> \- `chr generate docs-site` now includes source links in generated documentation. <br>**Blockchain RID configuration**<br> \- Blockchain RIDs can now be configured as either strings or byte arrays in the deployment model. | \- Fixed issue where `deployment update` with multiple chains only validated the first chain in the input. <br> \- Clarified JSON schema descriptions for Chromia model and corrected typos. <br> \- Updated deployment commands to use the target network to define default chains if no blockchains are specified. <br> \- Improved TypeScript stubs in `chr generate client-stubs` to better align with `postchain-client`, reducing linter warnings. |

## Chromia CLI 0.19.1 [â€‹](\#chromia-cli-0191 "Direct link to Chromia CLI 0.19.1")

Released on May 16, 2024.

| New features | Fixed issues |
| --- | --- |
| N/A | Resolved a bug in `chr node start` where library chains caused a null pointer exception (NPE). Library chains are now filtered out from `chr node start` and `chr node update`. |

## Chromia CLI 0.19.0 [â€‹](\#chromia-cli-0190 "Direct link to Chromia CLI 0.19.0")

Released on May 13, 2024.

| New features | Fixed issues |
| --- | --- |
| **Library support**<br> \- New YAML field ( `blockchains::type`) now supports configuration as either `blockchain` or `library`. <br> \- `chr create-rell-dapp --template plain-library` creates a library skeleton. <br> \- Libraries can now be compiled by configuring a blockchain as a library, e.g., `blockchains.my_lib.type: library`. <br>**Library structure requirements**<br> \- Libraries must be located in `lib/<name>` and match the blockchain name in the YAML. <br> \- Root module ( `lib.<name>`) must exist, and everything in `lib/<name>` is considered part of the library. <br>**Configuration setting update**<br> \- `revolt_when_should_build_block` is set to `true` by default to align with upcoming directory chain requirements. <br>**Dependency updates**<br> \- Updated dependencies: <br> \-\- Rell 0.13.12 <br> \-\- Postchain 3.15.19 <br> \-\- Postchain-Chromia 3.15.19 | This version impacts previously calculated blockchain RIDs due to updated configuration. |

## Chromia CLI 0.18.2 [â€‹](\#chromia-cli-0182 "Direct link to Chromia CLI 0.18.2")

Released on May 02, 2024.

| New features | Fixed issues |
| --- | --- |
| **Internal improvements**<br>\- Added exposed function to easily print configuration properties (internal use). | Properly reads from the `key.id` property when loading configuration. |

## Chromia CLI 0.18.1 [â€‹](\#chromia-cli-0181 "Direct link to Chromia CLI 0.18.1")

Released on May 02, 2024.

| New features | Removed features |
| --- | --- |
| **Key management enhancements**<br> \- New `--key-id` option for `Keygen` command allows users to store keys in `.chromia` folder in `$SYS_HOME` as `"myKeyId"` and `"myKeyId.pubkey"` (default: `chromia_key`). <br> \- Config property `key.id` can now be set to easily switch between keys. <br> \- Renamed `--save` option to `--file` in `Keygen` command. <br> \- For deployment and transaction commands, `--secret` option takes precedence over `key.id` in configuration. | **Deprecated key recovery removal**<br> \- Deprecated key recovery for keys generated pre-CLI version 0.15.0 removed. Users should test recovery of their keypair with the mnemonic. <br> \- Users needing old key pair recovery are recommended to install an older version of Chromia CLI. |

## Chromia CLI 0.17.4 [â€‹](\#chromia-cli-0174 "Direct link to Chromia CLI 0.17.4")

Released on April 16, 2024.

| New features | Fixed issues |
| --- | --- |
| Updated Rell version to [0.13.11](https://gitlab.com/chromaway/rell/-/blob/dev/doc/release-notes/0.14.0.txt?ref_type=heads). | N/A |

## Chromia CLI 0.17.3 [â€‹](\#chromia-cli-0173 "Direct link to Chromia CLI 0.17.3")

Released on April 12, 2024.

| New features | Fixed issues |
| --- | --- |
| **Auto-configuration**<br>\- Automatically sets `mininterblockinterval` based on configuration rules in directory chain. | \- Updates `brid` property under `icmf` to `bc-rid` for ICMF runtime compatibility. <br> \- Improved Dokka generation for namespaces and mount names, where namespaces are treated as modules and mount names appear in signatures when `@mount` is used. <br> \- Reduced Chromia CLI disk size by 50%. |

## Chromia CLI 0.17.2 [â€‹](\#chromia-cli-0172 "Direct link to Chromia CLI 0.17.2")

Released on April 10, 2024.

| New features | Fixed issues |
| --- | --- |
| **Experimental Windows support**<br> \- Added native support for Windows users via `scoop` ( [scoop.sh](https://scoop.sh/)). <br> \- Command: `scoop bucket add chromia https://gitlab.com/chromaway/core-tools/scoop-chromia/`<br> \- Command: `scoop install chr`<br>**Compatibility and updates**<br> \- `--ft-auth` updated for compatibility with FT4 version 0.4.0+. <br> \- Updated Rell code generation to 0.13.5, fixing NPE for partially named tuples in query return types. <br> \- Updated EIF to 0.4.1 to resolve EIF configuration validation issue. <br> \- New `strictGtvConversion` option in `chromia.yml` under `compile` property to configure strict GTV conversion. | \- Fixed issue with `repl` on Mac. <br> \- Fixed deployment bug where Rell versions higher than the target cluster supported were deployed. |

## Chromia CLI 0.17.1 [â€‹](\#chromia-cli-0171 "Direct link to Chromia CLI 0.17.1")

Released on April 05, 2024.

| New features | Fixed issues |
| --- | --- |
| \- Updated Rell version to [0.13.10](https://gitlab.com/chromaway/rell/-/blob/dev/doc/release-notes/0.14.0.txt?ref_type=heads). <br> \- Added `--fail-on-error` flag for the `test` command, overriding local `test:failOnError` configuration. | \- Updated Dokka plugin to 0.1.2 to fix broken links for anonymous functions. <br> \- Updated code generation to 0.13.4 to remove shadowing warnings in Kotlin stubs. <br> \- Set `compile:quiet` default to `false` for more verbose build messages in the terminal. Users can set it to `true` to suppress warnings. |

## Chromia CLI 0.17.0 [â€‹](\#chromia-cli-0170 "Direct link to Chromia CLI 0.17.0")

Released on March 25, 2024.

| New features | Fixed issues |
| --- | --- |
| **Split client stubs and graph generation**<br> \- `chr generate client-stubs` for client stubs and `chr generate graph` for mermaid graphs. <br> \- Deprecated `chr generate-client-stubs` in favor of separate commands. <br>**Documentation generation**<br> \- New command: `chr generate docs-site`, enabling static API reference pages for dApps. <br>**Aggregation and expression syntax**<br> \- Added annotations for `list`, `set`, and `map` aggregation on `at-expressions`. <br> \- New `at-expression` join syntax. <br>**Dependency updates**<br> \- Updated to Postchain 3.15.5 and Rell 0.13.9. | N/A |

## Chromia CLI 0.16.3 [â€‹](\#chromia-cli-0163 "Direct link to Chromia CLI 0.16.3")

Released on March 15, 2024.

| New features | Fixed issues |
| --- | --- |
| \- Added support for big integer values in `chromia.yml` with a capital "L" suffix (e.g., `1234L`). <br> \- Reintroduced schema validation for configuration files. See the full schema [here](https://gitlab.com/chromaway/core-tools/chromia-cli/-/blob/dev/chromia-build-tools/src/main/resources/chromia-model-schema.json?ref_type=heads). | \- Verified that the Rell version in `chromia.yml` matches the highest supported version for the target cluster during deployment updates. <br> \- Updated `jgit` dependency to address a security vulnerability. |

## Chromia CLI 0.16.2 [â€‹](\#chromia-cli-0162 "Direct link to Chromia CLI 0.16.2")

Released on March 12, 2024.

| New features | Fixed issues |
| --- | --- |
| \- Temporarily removed support for big integer values in `chromia.yml`. <br> \- Rolled back the new parsing module to the previous version that works with anchors and references in YAML files. | N/A |

## Chromia CLI 0.16.1 [â€‹](\#chromia-cli-0161 "Direct link to Chromia CLI 0.16.1")

Released on March 11, 2024.

| New features | Fixed issues |
| --- | --- |
| \- Added support for big integer values in `chromia.yml` with a capital "L" suffix (e.g., `1234L`). <br> \- Introduced economic chain support with the "Get Lease Information" command. This feature allows users to get lease information by container ID or public key (currently hidden but available under `chr deployment lease-info`). <br> \- Updated the directory-chain version to 1.35.0. <br> \- Updated Postchain to version 3.15.3. | \- Standardized the message output for `chr start` when all blockchains have started, now showing "Node is initialized". <br> \- Fixed stacktrace errors in YAML parsing and improved error messages when configuration files have issues. |

## Chromia CLI 0.16.0 [â€‹](\#chromia-cli-0160 "Direct link to Chromia CLI 0.16.0")

Released on February 05, 2024.

| New features | Fixed issues |
| --- | --- |
| \- Added `chr node start --directory-chain-mock`, which provides a directory chain mock for use in integration tests and manual testing of frontend clients. <br> \- Enabled cross-chain transfers with FT4 and client-side usage of ICCF via node discovery features. | N/A |

## Chromia CLI 0.15.3 [â€‹](\#chromia-cli-0153 "Direct link to Chromia CLI 0.15.3")

Released on January 29, 2024.

| New features | Fixed issues |
| --- | --- |
| \- Added a prefilled `.gitignore` file to all templates created by `create-rell-dapp`. <br> \- Introduced a directory to wrap the generated code. The directory is named after the project name, or `my-rell-dapp` by default if no project name is provided. | Replaced all references to "hello" as the default blockchain name with `my_rell_dapp` if no project name is provided. |

## Chromia CLI 0.15.2 [â€‹](\#chromia-cli-0152 "Direct link to Chromia CLI 0.15.2")

Released on January 25, 2024.

| New features | Fixed issues |
| --- | --- |
| N/A | Added support for FT version 0.2.+ when using `--ft-auth` in `chr tx`. |

## Chromia CLI 0.15.1 [â€‹](\#chromia-cli-0151 "Direct link to Chromia CLI 0.15.1")

Released on January 18, 2024.

| New features | Fixed issues |
| --- | --- |
| N/A | Fixed bug where `chr test` failed for a blockchain test when ICMF was configured. |

## Chromia CLI 0.15.0 [â€‹](\#chromia-cli-0150 "Direct link to Chromia CLI 0.15.0")

Released on January 17, 2024.

| New features | Fixed issues |
| --- | --- |
| \- Added support for ICCF when running a test node with `chr node start`. <br> \- Enabled unit tests with ICCF using `chr test`. <br> \- Introduced support for sending ICCF proofs using `--iccf-tx` and `--iccf-source` in `chr tx`. (Note: ICCF proof operations are not verified in the test framework). <br> \- Improved argument parsing for `chr tx/query`, now supporting nested structures (e.g., dicts are encoded as `[key: value]`). | \- Disabled git progress monitor when running `chr install` non-interactively (e.g., in CI). <br> \- Fixed `start` script to work for Alpine Linux and Busybox Docker images (version 0.14.3). <br> \- Reverted to using BIP for key generation in `Keygen` (version 0.14.3). <br> \- Fixed issue where global config overrides command-line input for `--cid` in `chr tx/query` (version 0.14.3). |

## Chromia CLI 0.14.2 [â€‹](\#chromia-cli-0142 "Direct link to Chromia CLI 0.14.2")

Released on December 18, 2023.

| New features | Fixed issues |
| --- | --- |
| \- Postchain 3.14.14, postchain-chromia 3.14.8, directory 1.30.0, postchain-client 3.12.1. <br> \- Added Chromia.yml validation schema to the repo. | \- Fixed issue with the `CHR_LOG_LEVEL` environment variable to properly set the log level for `chr node start`. <br> \- Fixed concurrency issue where messages were lost due to a concurrency problem when using ICMF with a test node. |

## Chromia CLI 0.14.1 [â€‹](\#chromia-cli-0141 "Direct link to Chromia CLI 0.14.1")

Released on December 06, 2023.

| New features | Fixed issues |
| --- | --- |
| N/A | Reverted the explicit choice of test scope ( `-bc` or no `-bc`), so now `chr test` runs all test modules and all blockchains by default. |

## Chromia CLI 0.14.0 [â€‹](\#chromia-cli-0140 "Direct link to Chromia CLI 0.14.0")

Released on December 05, 2023.

| New features | Fixed issues |
| --- | --- |
| \- Added ICMF support for `chr node start` (EXPERIMENTAL). <br> ( **Note**: Unprocessed messages will be lost during node restart, and the process may crash with an `OutOfMemoryException` if too many messages are sent. This is for testing, not production use.) <br> \- Enabled compression of files for networks running the Management chain during `chr deployment create/update`. <br> \- Added support for running tests on a selected module using `--module` for blockchain tests in `chr test`. <br> \- Increased robustness of `chr tx` for the `--ft-auth` flag. | N/A |

## Chromia CLI 0.13.4 [â€‹](\#chromia-cli-0134 "Direct link to Chromia CLI 0.13.4")

Released on November 28, 2023.

| New features | Fixed issues |
| --- | --- |
| N/A | Fixed JavaScript typo in `generate-client-stubs`. |

## Chromia CLI 0.13.3 [â€‹](\#chromia-cli-0133 "Direct link to Chromia CLI 0.13.3")

Released on November 28, 2023.

| New features | Fixed issues |
| --- | --- |
| Updated `Keygen` to conform to BIP39 and BIP32 standards. | N/A |

## Chromia CLI 0.13.2 [â€‹](\#chromia-cli-0132 "Direct link to Chromia CLI 0.13.2")

Released on November 15, 2023.

| New features | Fixed issues |
| --- | --- |
| \- Added Rell 0.13.5 release notes. <br> \- Shows unit test duration. <br> \- `REPL` now uses the GTV output format. | \- Exits with code 1 when a query/transaction fails in `chr repl`. <br> \- Prints an info message when a blockchain is successfully removed from a container. |

## Chromia CLI 0.13.0 and CLI 0.13.1 [â€‹](\#chromia-cli-0130-and-cli-0131 "Direct link to Chromia CLI 0.13.0 and CLI 0.13.1")

Released on November 08, 2023.

| New features | Fixed issues |
| --- | --- |
| \- Reads API URL and BRID from `.chromia/config` file. <br> \- Added the `-c` option to `chr repl` command to allow execution of a single command. <br> \- New command: `chr deployment remove` to remove deployed blockchain from a container. <br> \- Template flag for `chr create-rell-dapp` with options: `Minimal`, `Plain`, `Plain-Multi`. <br> \- Codegen 0.12.0: Added option to generate mermaid entity relation diagrams. | \- Fixed issue where `chr repl` did not print intro text when using the `-c` flag (bug from 0.13.0). <br> \- Fixed `chr repl` to exit with status code 1 when it fails with the `-c` flag (bug from 0.13.0). <br> \- Fixed default log level to be set as `info` instead of `debug` (macOS-specific bug). |

- [Chromia CLI 0.20.13](#chromia-cli-02013)
- [Chromia CLI 0.21.0](#chromia-cli-0210)
- [Chromia CLI 0.20.14](#chromia-cli-02014)
- [Chromia CLI 0.20.13](#chromia-cli-02013-1)
- [Chromia CLI 0.20.12](#chromia-cli-02012)
- [Chromia CLI 0.20.9](#chromia-cli-0209)
- [Chromia CLI 0.20.8](#chromia-cli-0208)
- [Chromia CLI 0.20.7](#chromia-cli-0207)
- [Chromia CLI 0.20.6](#chromia-cli-0206)
- [Chromia CLI 0.20.4](#chromia-cli-0204)
- [Chromia CLI 0.20.3](#chromia-cli-0203)
- [Chromia CLI 0.20.2](#chromia-cli-0202)
- [Chromia CLI 0.20.1](#chromia-cli-0201)
- [Chromia CLI 0.20.0](#chromia-cli-0200)
- [Chromia CLI 0.19.1](#chromia-cli-0191)
- [Chromia CLI 0.19.0](#chromia-cli-0190)
- [Chromia CLI 0.18.2](#chromia-cli-0182)
- [Chromia CLI 0.18.1](#chromia-cli-0181)
- [Chromia CLI 0.17.4](#chromia-cli-0174)
- [Chromia CLI 0.17.3](#chromia-cli-0173)
- [Chromia CLI 0.17.2](#chromia-cli-0172)
- [Chromia CLI 0.17.1](#chromia-cli-0171)
- [Chromia CLI 0.17.0](#chromia-cli-0170)
- [Chromia CLI 0.16.3](#chromia-cli-0163)
- [Chromia CLI 0.16.2](#chromia-cli-0162)
- [Chromia CLI 0.16.1](#chromia-cli-0161)
- [Chromia CLI 0.16.0](#chromia-cli-0160)
- [Chromia CLI 0.15.3](#chromia-cli-0153)
- [Chromia CLI 0.15.2](#chromia-cli-0152)
- [Chromia CLI 0.15.1](#chromia-cli-0151)
- [Chromia CLI 0.15.0](#chromia-cli-0150)
- [Chromia CLI 0.14.2](#chromia-cli-0142)
- [Chromia CLI 0.14.1](#chromia-cli-0141)
- [Chromia CLI 0.14.0](#chromia-cli-0140)
- [Chromia CLI 0.13.4](#chromia-cli-0134)
- [Chromia CLI 0.13.3](#chromia-cli-0133)
- [Chromia CLI 0.13.2](#chromia-cli-0132)
- [Chromia CLI 0.13.0 and CLI 0.13.1](#chromia-cli-0130-and-cli-0131)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

```codeBlockLines_e6Vv
Usage: chr node [OPTIONS] COMMAND [ARGS]...

  Interact with a test node

â•­â”€ Options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  -h, --help  Show this message and exit                                     â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€ Commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  start   Starts a test node                                                 â”‚
â”‚  update  Updates a running test node                                        â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

```

You can use the node command ( `chr node`) to start or update a node with your applications running on it.

## node start [â€‹](\#node-start "Direct link to node start")

To start your node, you use ( `chr node start`).

```codeBlockLines_e6Vv
Usage: chr node start [<options>]

  Starts a test node

  If a blockchain has already been started on the configured database schema,
  the configuration will be added to the next height such that the node will be
  started with the new config. Use --wipe to wipe the database schema upon
  startup and thus enforce starting the chain from height=0.

Configuration Properties:
  -s, --settings=<settings>  Alternate path for project settings file

Options:
  -bc, --blockchain-config=<path>
                                 Manually specify which blockchain-configs to
                                 run
  --name=<name>                  Only start specified blockchains (multiple)
  -p=<key=value>                 Override any property value (usage: -p
                                 key=value)
  -np, --node-properties=<path>  Full path to override node properties file
  --directory-chain-mock         Adds a blockchain on ID 0 that responds to the
                                 cluster management api and anchoring api. Used
                                 together with integration tests involving
                                 frontend clients. Can be used with node
                                 discovery features, ICCF and cross-chain
                                 transfers using the FT-protocol
  --sql-log                      Log sql expressions
  --wipe / --no-wipe             If a database should be wiped before startup
  -h, --help                     Show this message and exit

```

By default, it starts each [blockchain](/intro/terminology#blockchain) under the `blockchains` key in your
[project config file](/intro/configuration/project-config) ( `chromia.yml`).

- If you are in the working directory where the `chromia.yml` presides:

```codeBlockLines_e6Vv
chr node start

```

- You can set a path for the Project Settings file or specify a different file:

```codeBlockLines_e6Vv
chr node start --settings chromia.yml

```

- If you instead want to start a node from a build, you can refer to the blockchain config file:

```codeBlockLines_e6Vv
chr node start --blockchain-config build/my_rell_dapp.xml

```

You can use the `--wipe` option to reset the database before execution and use the `-np` or `--node-properties` if you
want to override the default [node](/intro/terminology#node) settings.

You can use the `--name` option to specify which blockchain to start from the blockchains set in `chromia.yml`. If you
have specified multiple blockchains, you can chain them to start multiple blockchains at once.

```codeBlockLines_e6Vv
#chromia.yml

blockchains:
  foo:
    module: main
  bar:
    module: main
...

```

- Start one blockchain named `foo`:

```codeBlockLines_e6Vv
chr node start --name foo

```

- Start two blockchains named `foo` and `bar`:

```codeBlockLines_e6Vv
chr node start --name foo --name bar

```

## node update [â€‹](\#node-update "Direct link to node update")

To make updates to a local running node, you use ( `chr node update`):

```codeBlockLines_e6Vv
Usage: chr node update [<options>]

  Updates a running test node

  Will add a configuration to a block height 5 higher that current height for
  the running blockchain. Make sure this command is executed with exactly the
  same chromia.yml and arguments as was used when starting the node using chr
  node start to make sure configurations are added to the correct chain ids.

Configuration Properties:
  -s, --settings=<settings>  Alternate path for project settings file

Options:
  -bc, --blockchain-config=<path>
                                 Manually specify which blockchain-configs to
                                 run
  --name=<name>                  Only start specified blockchains (multiple)
  -p=<key=value>                 Override any property value (usage: -p
                                 key=value)
  -np, --node-properties=<path>  Full path to override node properties file
  --directory-chain-mock         Adds a blockchain on ID 0 that responds to the
                                 cluster management api and anchoring api. Used
                                 together with integration tests involving
                                 frontend clients. Can be used with node
                                 discovery features, ICCF and cross-chain
                                 transfers using the FT-protocol
  -n, --preemption=<int>         Update the configuration at a height this many
                                 blocks into the future
  -h, --help                     Show this message and exit

```

- [node start](#node-start)
- [node update](#node-update)[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ“„ï¸FT4 changelog** \\
All notable changes to this project will be documented in this file.](/ft4/releases/ft4)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

FT4 offers extensive asset management capabilities, supporting multiple types of assets within the same ecosystem. Each
asset is tracked within the `asset` table, which maintains all necessary metadata about the asset, such as its name,
symbol, and total supply.

Asset registration is a crucial process within the FT4 framework on the Chromia blockchain. It involves defining and
initializing new assets (such as tokens) that will be used within the system, ensuring that each asset has a unique
identity, associated metadata, and is properly tracked across different accounts.

The process of asset registration is essential because it formalizes the creation of tokens or other digital assets on
the blockchain, allowing them to be used in transactions, held in accounts, and transferred securely. It also provides
critical information about the asset, such as its symbol, total supply, and decimal precision, which are necessary for
users and dApps to interact with the asset properly.

There are two primary ways to register assets in FT4: using the built-in admin operation or by writing a custom
operation. Both methods achieve the same goal but allow for different levels of customization and control over the
registration process.

warning

Admin operations are enabled by importing the admin module and should not be used in production.

## Asset definition [â€‹](\#asset-definition "Direct link to Asset definition")

Assets are defined using the following structure:

```codeBlockLines_e6Vv
entity asset {
   key id: byte_array;
   name;
   key symbol: text;
   decimals: integer;
   issuing_blockchain_rid: byte_array;
   icon_url: text;
   type: text = ASSET_TYPE_FT4;
   mutable total_supply: big_integer;
}

```

This table tracks key asset properties such as:

- **Name**: The asset's name.
- **Symbol**: The asset's ticker or symbol.
- **Decimals**: The number of decimal places the asset supports.
- **Total supply**: The total amount of the asset in circulation, which can be mutable.

## Balances [â€‹](\#balances "Direct link to Balances")

The `balance` table tracks how much of each asset is held by each account. This allows for efficient querying of account
balances and ensures that the system keeps track of asset ownership.

```codeBlockLines_e6Vv
entity balance {
  key accounts.account, asset;
  mutable amount: big_integer;
}

```

- [Asset definition](#asset-definition)
- [Balances](#balances)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

One of the core features of FT4 is the ability to use multiple key pairs or accounts to control a single account.

**Auth descriptors** are a mechanism that defines the authorized key pairs and their associated permissions for
interacting with accounts on the blockchain. They enable features like multi-signature security and granular access
control, allowing for secure and flexible management of account access.

### Types of auth descriptors [â€‹](\#types-of-auth-descriptors "Direct link to Types of auth descriptors")

1. **Single-signature auth descriptor**: This involves a single signer who is identified by either a native Chromia
public key or an Ethereum Virtual Machine (EVM) account address for cross-chain signatures.
2. **Multi-signature auth descriptor**: This allows multiple signers to manage an account. Each signer is identified by
either a public key (for Chromia) or an EVM account address (for Ethereum integration).

### Flexible account management with multiple auth descriptors [â€‹](\#flexible-account-management-with-multiple-auth-descriptors "Direct link to Flexible account management with multiple auth descriptors")

Each `auth_descriptor` defines who can access the account and what they are allowed to do. FT4 supports multiple types
of auth descriptors, including single-signature and multi-signature setups. This makes FT4 suitable for a range of use
cases, from personal wallets to shared or multi-party accounts.

To manage performance and prevent excessive data on the blockchain, there is a limit on the number of authorization
descriptors an account can have. By default, this is set to 10, but it can be configured by developers to meet the needs
of their dapp:

```codeBlockLines_e6Vv
blockchains:
  my_rell_dapp:
    module: main
    moduleArgs:
      lib.ft4.core.accounts:
        auth_descriptor:
          max_number_per_account: 4

```

## Authorization flags and operation control [â€‹](\#authorization-flags-and-operation-control "Direct link to Authorization flags and operation control")

Authorization flags (auth flags) are a critical component of FT4's security model. These flags define which actions a
user can perform on an account. If an auth descriptor lacks the necessary flag, any operation attempting to use that
descriptor will be rejected.

### Built-in authorization flags [â€‹](\#built-in-authorization-flags "Direct link to Built-in authorization flags")

- **Transfer (T) flag**: Required for token transfer operations.
- **Account (A) flag**: Required for FT4 account operations, such as adding or deleting auth descriptors.

In addition to the built-in flags, dApps can create custom auth flags tailored to their specific needs. While the flags
can technically be any string, itâ€™s recommended to use shorter flags for better performance.

## Expiration rules for auth descriptors [â€‹](\#expiration-rules-for-auth-descriptors "Direct link to Expiration rules for auth descriptors")

FT4 allows for fine-grained control over access by supporting expiration rules for auth descriptors. These rules govern
the lifespan or usability of the descriptor, offering extra security by limiting the duration or usage of certain access
privileges.

### Supported expiration rules [â€‹](\#supported-expiration-rules "Direct link to Supported expiration rules")

- **Block height**: The descriptor becomes invalid after a specific block height is reached.
- **Block time**: The descriptor expires after a certain block time.
- **Number of authorizations**: The descriptor expires after it has been used a predefined number of times.

Note that descriptors created when an account is first set up cannot have expiration rules to ensure that there is
always a way to manage the account. The maximum number of expiration rules that can be set per auth descriptor is
configurable (default is 8).

```codeBlockLines_e6Vv
blockchains:
  my_rell_dapp:
    module: main
    moduleArgs:
      lib.ft4.core.accounts:
        max_auth_descriptor_rules: 4

```

# Authentication with FT4 accounts

Authentication in dapps is essential for verifying if a user has permission to perform specific actions. While the
process is straightforward with regular Rell applications, it becomes more complex with FT4 due to support for native
and EVM signatures and multiple keys for an FT4 account. However, the complexity is abstracted, and authentication can
be easily implemented using the `authenticate` operation.

## Operation signing [â€‹](\#operation-signing "Direct link to Operation signing")

FT4 supports both EVM and non-EVM signatures (Chromia only). Every operation has a signature message being signed in
case EVM is used. In case of non-EVM signatures, the whole transaction is signed.

- [Types of auth descriptors](#types-of-auth-descriptors)
- [Flexible account management with multiple auth descriptors](#flexible-account-management-with-multiple-auth-descriptors)
- [Authorization flags and operation control](#authorization-flags-and-operation-control)
  - [Built-in authorization flags](#built-in-authorization-flags)
- [Expiration rules for auth descriptors](#expiration-rules-for-auth-descriptors)
  - [Supported expiration rules](#supported-expiration-rules)
- [Operation signing](#operation-signing)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

To write unit tests for [Rell](/intro/terminology#rell) code, use test module. You need to use the `@test`
annotation to define a test module.

```codeBlockLines_e6Vv
@test module;

function test_foo() {
    assert_equals(2 + 2, 4);
}

function test_bar() {
    assert_equals(2 + 2, 5);
}

```

All functions in a test module that start with `test_` (and a function called exactly `test`) are test functions that're
executed when you run the test module.

If the module has the "\_test" suffix, it becomes a test module for the module that bears the same name without the
suffix. For example, if the module name is `program`, the test module is `program_test`.

To run a test module, use the test command ( `chr test`):

```codeBlockLines_e6Vv
chr test --settings chromia.yml --modules my_test_module

```

For more information, see the [chr test](/cli/commands/test) topic. Each test function gets executed independently
of others, and a summary gets printed at the end:

```codeBlockLines_e6Vv
TEST RESULTS:

my_test_module:test_foo OK
my_test_module:test_bar FAILED

SUMMARY: 1 FAILED / 1 PASSED / 2 TOTAL

***** FAILED *****

```

### Test module (file `data_test.rell`): [â€‹](\#test-module-file-data_testrell "Direct link to test-module-file-data_testrell")

```codeBlockLines_e6Vv
@test module;
import data;

function test_add_user() {
    assert_equals(data.user @* {}(.name), list<text>());

    val tx = rell.test.tx(data.add_user('Bob'));
    assert_equals(data.user @* {}(.name), list<text>());

    tx.run();
    assert_equals(data.user @* {}(.name), ['Bob']);
}

```

### Example of a test module [â€‹](\#example-of-a-test-module "Direct link to Example of a test module")

Here's an example of a test module:

```codeBlockLines_e6Vv
@test module;
import main;

function test_init(){

    assert_equals((main.user @* {}(.username)).size(),0);
    assert_equals((main.balance @* {}(.user)).size(),0);
    rell.test.tx().op(main.init(rell.test.pubkeys.alice)).run();
    assert_equals(main.user @* {}(.username).size(),1);
    assert_equals(main.balance@{.user == main.user @ { .pubkey == rell.test.pubkeys.alice}}(.amount),1000000);

}

function test_register_user(){

    rell.test.tx().op(main.init(rell.test.pubkeys.alice)).run();
    assert_equals(main.user @* {}(.username).size(),1);
    rell.test.tx().op(main.register_user(rell.test.pubkeys.alice,rell.test.pubkeys.bob,"bob",100)).sign(rell.test.keypairs.alice).run();
    assert_equals(main.user @* {}(.username).size(),2);
    assert_equals(main.user @ {.pubkey == rell.test.pubkeys.bob}(.username),"bob");
    assert_equals(main.balance@{.user == main.user @ {.pubkey == rell.test.pubkeys.bob}}(.amount),100);
}

function test_blocks(){

    val tx1 = rell.test.tx().op(main.init(rell.test.pubkeys.alice));
    val tx2 = rell.test.tx().op(main.register_user(rell.test.pubkeys.alice,rell.test.pubkeys.bob,"bob",100)).sign(rell.test.keypairs.alice);
    val tx3 = rell.test.tx().op(main.create_channel(rell.test.pubkeys.alice,"channel 1")).sign(rell.test.keypairs.alice);
    rell.test.block().tx(tx1).tx(tx2).tx(tx3).run();
    val tx4 = rell.test.tx().op(main.add_channel_member(rell.test.pubkeys.alice,"channel 1","bob")).sign(rell.test.keypairs.alice);
    rell.test.block().tx(tx4).run();
}

```

Unit tests also display the duration of each test case and the overall test suite duration.

```codeBlockLines_e6Vv
    TEST RESULTS:

    OK tests.foobar:test_foo (0.005s)

    FAILED tests.foobar:test_fail_require (0.001s)
    FAILED tests.foobar:test_fail_assert_equals (0.001s)

    SUMMARY: 2 FAILED / 1 PASSED / 3 TOTAL (0.007s)

```

tip

For information on writing integration tests using Rell and TypeScript, visit the
[Chromia learning platform](https://learn.chromia.com/courses/rell-integration-test/introduction).

- [Test module (file `data_test.rell`):](#test-module-file-data_testrell)
- [Example of a test module](#example-of-a-test-module)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

FT4 provides powerful tools for managing accounts in a decentralized environment. Each account is represented by an ID,
which serves as a unique identifier within the system. The architecture supports the management of accounts by multiple
users, each of whom can have different levels of access and control.

## Account structure [â€‹](\#account-structure "Direct link to Account structure")

Each account is defined as an entity:

```codeBlockLines_e6Vv
entity account {
  key id: byte_array;
  index type: text;
}

```

## Multi-user account management [â€‹](\#multi-user-account-management "Direct link to Multi-user account management")

Accounts can be controlled by more than one user through a system of auth descriptors ( `account_auth_descriptor`). These
descriptors specify who is allowed to perform specific actions on the account and what rules or conditions govern that
access. This allows for the creation of shared accounts, where different parties have different privileges.

```codeBlockLines_e6Vv
entity account_auth_descriptor {
   id: byte_array;
   key account, id;
   index id;
   auth_type;
   args: byte_array;
   rules: byte_array;
   mutable ctr: integer;
   created: timestamp;
}

```

## Account registration [â€‹](\#account-registration "Direct link to Account registration")

Account registration ensures that users can interact securely with decentralized applications (dapps), perform
transactions, and manage their assets. Each account serves as a unique identity on the blockchain, enabling secure
ownership, transfer of assets, and participation in decentralized processes.

FT4 offers multiple ways to register accounts, including a general registration framework and an admin-level operation
for more specific use cases. Custom operations can also be defined for more advanced needs. The method you choose
depends on the type of control, permissions, and registration strategy required for your dapp.

### Account registration framework [â€‹](\#account-registration-framework "Direct link to Account registration framework")

For most dapps, the **account registration framework** provided by the FT4 library is the recommended approach. It
offers a flexible, secure, and scalable system to create new accounts, supporting a variety of strategies that cater to
different business models and security needs. The framework simplifies the process for developers, providing pre-built
solutions for common registration scenarios.

#### Registration strategies [â€‹](\#registration-strategies "Direct link to Registration strategies")

The account registration framework supports the following strategies:

- **Open:** Anyone can call the `register_account()` operation to create an account without any restrictions.
- **Transfer strategy**: Users must perform a transfer to the account address before they can create an account. The
transfer strategy has three sub-strategies:
  - **Open**: The user can claim the entire deposit to their newly created account.
  - **Fee**: Part of the transferred assets is collected as a fee to the chain's fee account, and the user can only
    claim the remaining assets to their account.
  - **Subscription**: Similar to the fee strategy, but the user needs to periodically renew their subscription by paying
    the subscription fee to keep using their account.

To enable a specific strategy, import the corresponding module into your Rell file and configure it in the `chromia.yml`
file. The modules are named as follows:

- `lib.ft4.core.accounts.strategies.open` (open strategy)
- `lib.ft4.core.accounts.strategies.transfer.open` (transfer open strategy)
- `lib.ft4.core.accounts.strategies.transfer.fee` (transfer fee strategy)
- `lib.ft4.core.accounts.strategies.transfer.subscription` (transfer subscription strategy)

## Rate limiter [â€‹](\#rate-limiter "Direct link to Rate limiter")

The account module has a feature to enable rate-limiting in its operations for spam prevention.

The client accumulates one "operation point" every `rate_limit_recovery_time` milliseconds, up to
`rate_limit_max_points`. You spend one operation point for each authenticated operation.

You can configure this with module args for the `lib.ft4.core.accounts` module like this:

```codeBlockLines_e6Vv
blockchains:
  my_rell_dapp:
    module: main
    moduleArgs:
      lib.ft4.core.accounts:
        rate_limit:
          max_points: 10
          recovery_time: 5000
          points_at_account_creation: 1

```

| **Argument** | **Description** | **Default value** |
| --- | --- | --- |
| max\_points | is the maximum number of operation points that can accumulate (and, therefore, the maximum number of transactions you can do at once). | 10 |
| recovery\_time | (Milliseconds) is the cooling period before an account can receive one operation point. | 5000 |
| points\_at\_account\_creation | The points that an account has at the moment of its creation (0 is min). | 1 |

- [Account structure](#account-structure)
- [Multi-user account management](#multi-user-account-management)
- [Account registration](#account-registration)
  - [Account registration framework](#account-registration-framework)
- [Rate limiter](#rate-limiter)[Skip to main content](#__docusaurus_skipToContent_fallback)

FT4 authentication utilizes auth descriptors to define key pairs, permissions, and multi-signature security. Custom auth
handlers enable flexible user authorization across FT and EVM signers. Multi-signature transactions require multiple
approvals and can be managed using chr commands for creation, signing, and sending.

[Auth descriptors in FT4 define key pairs and permissions for blockchain accounts, enabling multi-signature security and access control. They include rules for when the descriptor is valid, ensuring secure account management.](/ft4/backend/auth-descriptors-and-rules) [FT4 authentication is enabled using auth.add\_auth\_handler, defining operation scopes and flags. Custom\\
authentication messages and resolvers allow flexible and secure user authorization across different signers (FT and\\
EVM).](/ft4/backend/auth) [Multi-signature transactions require multiple approvals, created using chr multi-signature create with a signers file. Signatures are added using chr multi-signature sign and sent with chr multi-signature send after all signatures are collected.](/ft4/backend/multi-sig)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

This section showcases practical examples demonstrating how to use the client library. These scripts provide valuable
insights into the library's functionality, even though the complete documentation is still under development.

Import statements are omitted for brevity, as IDEs will automatically identify the necessary ones.

While the scripts are mostly complete, they may not be ready to run. `await` can only be used in functions and modules,
and you'd never run these scripts as standalone applications. Defining variables like key pairs and IDs will be
necessary when implementing these examples in your projects.

## Create a connection [â€‹](\#create-a-connection "Direct link to Create a connection")

This code demonstrates how to connect to the blockchain using the client library. This connection allows you to retrieve
data through queries but can't perform operations that modify the blockchain state. This is similar to having no wallet
access in the context of Ethereum Virtual Machines (EVMs). You can call `view` and `pure` functions (queries), but not
others (operations).

```codeBlockLines_e6Vv
const url = "http://localhost:7740";
const client = await createClient({
  nodeURLPool: url,
  blockchainIID: 0,
});

// This can be used for most queries
// Code completion will allow you to check what's available
const connection = createConnection(client);

//Example:
const account = await connection.getAccountById("5E2488889F72939DD4D0A034FB91893ACBF14C7EDBCEF2A9F5C621A07169EAD2");

// This account will unlock new queries for us.
// You can't call operations with it! You haven't given access to
// any keypair here. Use code completion to check what's available!

//Example:
const balances = await account.getBalances();

```

## Dealing with paginated entries [â€‹](\#dealing-with-paginated-entries "Direct link to Dealing with paginated entries")

When you retrieve a large number of entities, they are often delivered in batches called `PaginatedEntity`. This helps
manage the amount of data transferred at once. To retrieve the next batch, you must query again, specifying the starting
point.

```codeBlockLines_e6Vv
const url = "http://localhost:7740";
const client = await createClient({
  nodeUrlPool: url,
  blockchainIid: 0,
});
const connection = createConnection(client);

// This is a paginated query:
// It will contain 100 entries and a cursor pointing to the next page
const assetsPage1 = await connection.getAllAssets();

console.log(assetsPage1.data);
// [asset1, asset2, ..., asset100]

// If I only need 3 assets, I can limit the number of entries per page
const assetsPage1Short = await connection.getAllAssets(3);

// I want the next three now:
const assetsPage2Short = await connection.getAllAssets(3, assetsPage1Short.nextCursor);

```

## Authenticating an account [â€‹](\#authenticating-an-account "Direct link to Authenticating an account")

This section explains how users can access their accounts on the blockchain using a Web3 provider like
[MetaMask](https://metamask.io). This method lets users securely interact with their accounts through familiar
interfaces without exposing private keys. When an account has been registered with the Web3 provider (through the auth
server or other means), it'll have an auth descriptor that allows that EVM address to operate over it. This can then be
used to create an instance of an authenticated account:

```codeBlockLines_e6Vv
const url = "http://localhost:7740";
const client = await createClient({
  nodeUrlPool: url,
  blockchainIid: 0,
});

//Interact with Metamask or similar...
const { getSession } = createKeyStoreInteractor(
  client,
  await createWeb3ProviderEvmKeyStore(window.ethereum) // If the user has the MetaMask browser plugin installed, it will decorate the `window` object with the `ethereum` property
);

//... to retrieve the session...
const session = await getSession(accountId);

//... which lets us use the AuthenticatedAccount object...
await session.account.burn(assetId, amount);

//... and do low level calls with our account
await session.call(op("my_op", arg1, arg2));

```

## Automatic signatures [â€‹](\#automatic-signatures "Direct link to Automatic signatures")

In specific scenarios, you should streamline the user experience by minimizing the need for manual transaction signing.
This is especially relevant for routine, low-risk transactions that don't pose significant security threats.

In this case, the wallet can authorize a session that signs them in the background. You should limit the authorization
of this background session so that it only performs zero-threat operations. The
[login management](/ft4/auth/authentication) section better explains this scenario.

Suppose you defined a new flag for zero-threat transactions and called it `0`. You can see
[here](/ft4/auth/authentication) how that can be done: `flags = ["0"]` would allow you to do so. This is how you
get a session that asks you to connect to MetaMask and makes you approve the session for automatic signature of
operations with flag `0`.

```codeBlockLines_e6Vv
const url = "http://localhost:7740";
const client = await createClient({
  nodeUrlPool: url,
  blockchainIiD: 0,
});

//Interact with Metamask or similar...
const keyStoreInteractor = createKeyStoreInteractor(client, await createWeb3ProviderEvmKeyStore(window.ethereum));

// Since we do not specify an expiry time, this session will, by default, expire after one day.
const { session } = await keyStoreInteractor.login({
  accountId: id,
  flags: ["0"], //allow any `0`-flag operation without asking for a signature
});

//Now you can call any operation:

//this has "T" flag. It will require a Metamask signature
session.account.transfer(/*parameters*/);

//this has "A" flag. It will require a Metamask signature
session.account.addAuthDescriptor(/*parameters*/);

//suppose this has "0" flag. It will NOT require a Metamask signature
session.call(op("my_0_flag_operation" /*parameters*/));

//suppose this has "0" AND "T" flag. It WILL require a Metamask signature
session.call(op("my_0_and_T_flag_operation" /*parameters*/));

```

## Signatures [â€‹](\#signatures "Direct link to Signatures")

This section covers advanced topics related to signatures and signature providers. It's intended for developers familiar
with these concepts. You can safely skip this section for standard postchain + EVM usage.

This example demonstrates creating a simple signature provider from a generated key pair; all the mentioned functions
are exported from `postchain-client` package:

```codeBlockLines_e6Vv
//this is a simple key pair
//it has a pubKey and a privKey property
const kp = encryption.makeKeyPair();

//this is a signature provider
//it hides away the privKey by only exposing
//pubKey and sign()
const sp = newSignatureProvider(kp);

//you can also create it without ever touching the keypair
const sp2 = newSignatureProvider();

//in both cases, the privateKey is on the machine. If you need
//to sign with a different solution (e.g. an already generated
//keypair from a different app or a hardware wallet) you need
//to create your own signatureProvider. It's quite easy:
/*
const sp3 = {
    pubKey: Buffer.from("032846C2EDB843E37D63A128C033788C924D30C5BA51FE8E7AD81A2D748839F2B0", "hex")
    sign: async (digest: Buffer) => {
        //custom code to sign
        return signature
    }
}
*/
//the sign function is async to allow the code to wait for user interaction.

```

## Using admin functions [â€‹](\#using-admin-functions "Direct link to Using admin functions")

Admin functions are powerful tools that grant complete control over the blockchain. These functions should never be used
in production client applications, as that would leak the admin private keys, giving everyone full access to the
Postchain. However, these functions can be useful for setup code, testing, and other specific applications.

```codeBlockLines_e6Vv
const url = "http://localhost:7740";
const client = await createClient({
  nodeURLPool: url,
  blockchainIID: 0,
});

const adminSigProv = newSignatureProvider(
  encryption.makeKeyPair("2AC313A8384F319058C578F0E46A9871EACE285EA9144166D80FACE635713D39")
);

const accountSignatureProvider = newSignatureProvider();

const authDesc = createSingleSigAuthDescriptorRegistration(["A", "T"], accountSignatureProvider.pubKey);

await registerAccountAdmin(client, adminSigProv, authDesc);

```

## Complex transactions [â€‹](\#complex-transactions "Direct link to Complex transactions")

Sometimes, you need to be able to make a more complex transaction. For example, when trying to submit a transaction that
needs to be signed by multiple users, they may also use different signature types. This can be achieved by using the
transaction builder, which can be acquired from a `session`:

```codeBlockLines_e6Vv
const tb = session.transactionBuilder();

```

See [previous section](#authenticating-an-account) for information about creating a `session`.

Let's say that we've an account that is created with a multisig auth descriptor that uses two EVM signatures to sign,
and we want to add a new single auth descriptor to this account that uses FT signatures to sign. This scenario is
complex as we first need to sign the transaction with the EVM keys and then with the FT key. However, we still need the
FT signer to be listed as the signer of the transaction. From the perspective of one of the EVM signers, such a
transaction can be built and signed like this:

```codeBlockLines_e6Vv
// Create a session using an authenticator that represents one of the EVM signers
const tx = await session
  // Get a transaction builder
  .transactionBuilder()
  // List the ft signers that will sign this operation. No need to list the other EVM signer,
  // as it is part of the main auth descriptor so it will happen automatically
  .add(addAuthDescriptor(adToAdd), {
    signers: [ftSigner(ftPubkey)],
  })
  // When we build the transaction, it will be signed using the key that is wrapped in `authenticator`
  .build();

```

When we've done the above, we will have a transaction that's signed by the first EVM key. The signers we listed when we
added the operation will also be listed as signers on the operation, but since we don't have their keys, we cannot add
their signatures. Instead, we need to take this newly built transaction and send it to them. Once they receive the
transaction, they can sign it like:

```codeBlockLines_e6Vv
const tx = /* Aquire the tx */
const signedTx = await session.sign(tx)

```

In the above code, the caller passes the partially signed transaction produced in the previous step. The code looks the
same regardless of whether the user tries to sign with EVM or FT signing. The function will automatically determine the
correct signature scheme based on the data stored in the `session` object.

caution

Note that while the orders in which the signers sign the transaction don't matter, all the EVM signers need to sign the
transaction before any of the FT signers do. Trying to sign with FT signers before all EVM signatures have been added
will result in an error.

- [Create a connection](#create-a-connection)
- [Dealing with paginated entries](#dealing-with-paginated-entries)
- [Authenticating an account](#authenticating-an-account)
- [Automatic signatures](#automatic-signatures)
- [Signatures](#signatures)
- [Using admin functions](#using-admin-functions)
- [Complex transactions](#complex-transactions)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In the FT4 library, a "lock account" functions as a secure storage for assets that users should not be able to access
temporarily. This is useful in situations like staking or auction bids, where assets are still owned by users but are
restricted from active use.

## Lock account overview [â€‹](\#lock-account-overview "Direct link to Lock account overview")

A lock account is identified by a specific account type:

```codeBlockLines_e6Vv
val ACCOUNT_TYPE_LOCK = "FT4_LOCK";

```

- **Purpose**: Lock accounts restrict access to assets without transferring ownership.
- **Usage scenarios**: Staking, auction participation, or other scenarios where users need to commit assets but are not
allowed to spend them.

An `account_link` entity is created to maintain the relationship between the main account and the lock account. This
entity stores:

- **account**: The original account holding the asset.
- **secondary**: The lock account.
- **type**: The purpose of the lock (e.g., "staking" or "auction").

### Creating a lock account [â€‹](\#creating-a-lock-account "Direct link to Creating a lock account")

To create a lock account associated with a given account and lock type, use the `ensure_lock_account` function:

```codeBlockLines_e6Vv
function ensure_lock_account(type: text, accounts.account): accounts.account {
  // logic to ensure a lock account exists or create one
}

```

- **Parameters**:
  - `type`: The lock type (e.g., "staking").
  - `account`: The userâ€™s main account.
- **Returns**: The lock account for the specified user account and type.

### Retrieving lock accounts [â€‹](\#retrieving-lock-accounts "Direct link to Retrieving lock accounts")

To retrieve all lock accounts associated with a particular account, use `get_lock_accounts`:

```codeBlockLines_e6Vv
function get_lock_accounts(accounts.account) {
  // logic to retrieve lock accounts
}

```

This function returns all lock accounts linked to the specified user account.

For retrieving only lock accounts with a non-zero balance, use:

```codeBlockLines_e6Vv
function get_lock_accounts_with_non_zero_balances(accounts.account) {
  // logic to retrieve lock accounts with assets
}

```

## Locking and unlocking assets [â€‹](\#locking-and-unlocking-assets "Direct link to Locking and unlocking assets")

The following functions allow assets to be locked (restricted from use) or unlocked (restored for use).

### Locking assets [â€‹](\#locking-assets "Direct link to Locking assets")

To lock assets, transferring them to the lock account, use `lock_asset`:

```codeBlockLines_e6Vv
function lock_asset(type: text, accounts.account, assets.asset, amount: big_integer) {
  // logic to transfer assets to lock account
}

```

- **Parameters**:
  - `type`: The type of lock (e.g., "staking").
  - `account`: The main account from which assets are being locked.
  - `asset`: The asset type to lock.
  - `amount`: The quantity of the asset to lock.

This function restricts access to the specified amount of assets by transferring them to the lock account.

### Unlocking assets [â€‹](\#unlocking-assets "Direct link to Unlocking assets")

To unlock assets, returning them to the main account, use `unlock_asset`:

```codeBlockLines_e6Vv
function unlock_asset(type: text, accounts.account, assets.asset, amount: big_integer) {
  // logic to transfer assets back to main account
}

```

- **Parameters**:
  - `type`: The type of lock (e.g., "staking").
  - `account`: The main account where assets will be returned.
  - `asset`: The asset type to unlock.
  - `amount`: The quantity of the asset to unlock.

This function restores access to assets by transferring them from the lock account back to the main account.

## Viewing locked balances [â€‹](\#viewing-locked-balances "Direct link to Viewing locked balances")

FT4 provides functions to check locked asset balances:

### Retrieve locked balances by type [â€‹](\#retrieve-locked-balances-by-type "Direct link to Retrieve locked balances by type")

Use `get_locked_asset_balance` to get balances for a specific asset type in various lock accounts:

```codeBlockLines_e6Vv
function get_locked_asset_balance(
  accounts.account,
  assets.asset,
  types: list<text>? = null,
  page_size: integer? = null,
  page_cursor: text? = null
) {
  // logic to retrieve paginated asset balances by lock type
}

```

### Retrieve aggregated locked balance of an asset [â€‹](\#retrieve-aggregated-locked-balance-of-an-asset "Direct link to Retrieve aggregated locked balance of an asset")

For the total balance of a locked asset across all lock types, use `get_locked_asset_aggregated_balance`:

```codeBlockLines_e6Vv
function get_locked_asset_aggregated_balance(
  accounts.account,
  assets.asset,
  types: list<text>? = null
) {
  // logic to retrieve aggregated locked balance for a specific asset
}

```

### Retrieve all locked balances of all assets [â€‹](\#retrieve-all-locked-balances-of-all-assets "Direct link to Retrieve all locked balances of all assets")

Use `get_locked_asset_balances` to retrieve locked balances for all assets:

```codeBlockLines_e6Vv
function get_locked_asset_balances(
  accounts.account,
  types: list<text>? = null,
  page_size: integer? = null,
  page_cursor: text? = null
) {
  // logic to retrieve all locked balances with pagination
}

```

### Retrieve aggregated locked balances of all assets [â€‹](\#retrieve-aggregated-locked-balances-of-all-assets "Direct link to Retrieve aggregated locked balances of all assets")

To get the total locked amounts for each asset across all lock types, use:

```codeBlockLines_e6Vv
function get_locked_asset_aggregated_balances(
  accounts.account,
  types: list<text>? = null,
  page_size: integer? = null,
  page_cursor: text? = null
) {
  // logic to retrieve aggregated balances for all assets with pagination
}

```

These functions allow querying of both specific and aggregated locked balances, offering flexibility in tracking and
managing locked assets.

- [Lock account overview](#lock-account-overview)
  - [Creating a lock account](#creating-a-lock-account)
  - [Retrieving lock accounts](#retrieving-lock-accounts)
- [Locking and unlocking assets](#locking-and-unlocking-assets)
  - [Locking assets](#locking-assets)
  - [Unlocking assets](#unlocking-assets)
- [Viewing locked balances](#viewing-locked-balances)
  - [Retrieve locked balances by type](#retrieve-locked-balances-by-type)
  - [Retrieve aggregated locked balance of an asset](#retrieve-aggregated-locked-balance-of-an-asset)
  - [Retrieve all locked balances of all assets](#retrieve-all-locked-balances-of-all-assets)
  - [Retrieve aggregated locked balances of all assets](#retrieve-aggregated-locked-balances-of-all-assets)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

FT4 assets on Chromia can be transferred both **on-chain** (within a single blockchain) and **cross-chain** (across
different blockchains within the Chromia network).

## On-chain transfers [â€‹](\#on-chain-transfers "Direct link to On-chain transfers")

On-chain transfers refer to transactions that occur within the same blockchain. These are the standard transfers where
assets are moved from one account to another on the same chain, securely and efficiently.

## Cross-chain transfers [â€‹](\#cross-chain-transfers "Direct link to Cross-chain transfers")

Chromiaâ€™s multi-chain architecture allows assets to be transferred between blockchains within the Chromia network. This
is known as a **cross-chain transfer**. Even though these transactions span different blockchains, they remain within
the Chromia ecosystem.

## Transfer to EVM environments [â€‹](\#transfer-to-evm-environments "Direct link to Transfer to EVM environments")

In addition to on-chain and cross-chain transfers within Chromia, the platform also supports **cross-environment**
**transfers** to **EVM-compatible blockchains** such as Ethereum, Binance Smart Chain, and others. This is facilitated
through a bridge that connects Chromiaâ€™s native assets to the EVM ecosystem.

### EVM bridge [â€‹](\#evm-bridge "Direct link to EVM bridge")

The Chromia-EVM bridge allows FT4 assets to be transferred to and from Ethereum and other EVM-based blockchains. This
expands the utility of FT4 assets, enabling their use in external decentralized finance (DeFi) platforms, NFT
marketplaces, and other applications within the EVM world.

For detailed information on how the bridge works and how to transfer assets between Chromia and EVM environments, refer
to the EVM Bridge Documentation.

- [On-chain transfers](#on-chain-transfers)
- [Cross-chain transfers](#cross-chain-transfers)
- [Transfer to EVM environments](#transfer-to-evm-environments)
  - [EVM bridge](#evm-bridge)[Skip to main content](#__docusaurus_skipToContent_fallback)

FT4 enables smooth asset transfers within the Chromia network, supporting stages like init\_transfer, apply\_transfer, and
complete\_transfer. Cross-chain assets can be registered and tracked, ensuring they meet validation requirements like
unique IDs and issuing chains. Transfers rely on secure asset registration, origin chain validation, and ICCF anchoring
for efficient cross-chain routing.

[FT4 enables seamless asset transfers across blockchains within the Chromia network. It supports asset minting, origin tracking, and transfer stages like init\_transfer, apply\_transfer, and complete\_transfer.](/ft4/backend/introduction) [FT4 enables registering, tracking, and transferring assets across blockchains. The register\_crosschain\_asset\\
function ensures assets are linked to their origin and meet validation requirements like unique IDs and issuing\\
chains.](/ft4/backend/cross-chain-assets) [FT4 facilitates seamless asset transfers between chains using operations like init\_transfer, apply\_transfer, and complete\_transfer. Transfers rely on asset registration, origin chain validation, and ICCF anchoring for secure and efficient routing.](/ft4/backend/cross-chain-transfers)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Cross-chain transfers enable seamless asset movements between multiple blockchains. Within the Chromia network,
cross-chain transfers are an integral part of the FT4 protocol.

## Why cross-chain transfers? [â€‹](\#why-cross-chain-transfers "Direct link to Why cross-chain transfers?")

Cross-chain transfers empower applications and users to:

- **Expand Reach**: Operate within the Chromia network across multiple chains.
- **Enhance Liquidity**: Facilitate asset transfers within the Chromia network.
- **Maintain Security**: Asset structures enable easier tracking of asset flows.

## Key components [â€‹](\#key-components "Direct link to Key components")

- **FT4 assets**: Chromia's asset standard can be either internally minted or externally originated.

- **Origin chains**: The parent chain from which an asset can be received.

- **Operations**: `init_transfer`, `apply_transfer`, and `complete_transfer` constitute the stages of a cross-chain
transfer.


- [Why cross-chain transfers?](#why-cross-chain-transfers)
- [Key components](#key-components)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

The subscription fee strategy allows a dapp to implement a recurring payment model.

#### Two ways to implement subscriptions: [â€‹](\#two-ways-to-implement-subscriptions "Direct link to Two ways to implement subscriptions:")

- **Automatic activation:** Users transfer a set amount of a specified token upon registering. If the transferred amount
meets the minimum requirement, their account is created with the subscription active.
- **Self-serve activation:** Users with existing tokens on another chain can transfer the subscription fee directly.

#### Benefits of subscriptions: [â€‹](\#benefits-of-subscriptions "Direct link to Benefits of subscriptions:")

- **Recurring revenue:** Provides a predictable income stream to support dapp sustainability.
- **Easy setup:** Simple implementation offers clear advantages to users.

### Getting started [â€‹](\#getting-started "Direct link to Getting started")

A code example with tests is available [here](https://bitbucket.org/chromawallet/fee-samples/src/main/subscription/).

To begin, expand the app configuration as shown below.

```codeBlockLines_e6Vv
lib.ft4.core.accounts.strategies.transfer:
  rules:
    - sender_blockchain: x"0000000000000000000000000000000000000000000000000000000000000000"
      sender: "*"
      recipient: "*"
      asset:
        - name: "MyTestAsset"
        min_amount: 100L
      timeout_days: 60
      strategy:
      - "subscription"
lib.ft4.core.accounts.strategies.transfer.subscription:
  asset:
    - name: "MyTestAsset" # issued by current blockchain # OR id: x"C633343E4AA3213EA92158648F11BA8DFF606C6CAC80614CFA5F45E57367F823"
    amount: 10L
  subscription_period_days: 30
  free_operations:
    - some_free_operation

```

This configuration includes two main settings, `strategies.transfer` and `strategies.transfer.subscription`. The example
above specifies the following:

1. **Transfer strategy:** For any sender and recipient on any blockchain, transactions involving the "MyTestAsset" asset
with a minimum amount of 100 coins can request a subscription. The timeout period is set to 60 days.
2. **Subscription strategy:** The subscription price is set at 10 "MyTestAsset" coins for a 30-day period. Users may
perform `some_free_operation` even without an active subscription.

To test the configuration above, refer to the provided
[tests](https://bitbucket.org/chromawallet/fee-samples/src/main/subscription/src/test/subscription_test.rell).

- [Getting started](#getting-started)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

The FT4 library allows managing various assets, each potentially having its own precision and formatting requirements,
which are governed by specific parameters and functions as outlined below.

## Asset structure [â€‹](\#asset-structure "Direct link to Asset structure")

An asset in this system is defined by several attributes:

- **ID**: A unique identifier ( `byte_array`) required to have a fixed length of 32 bytes.
- **Name** and **Symbol**: Display properties ( `text`) with a maximum length of 1024 characters.
- **Decimals**: Specifies the precision of the asset, affecting how raw amounts are interpreted.
- **Type**: Indicates the type of the asset, with a default value of `ASSET_TYPE_FT4`.
- **Issuing blockchain**: Identifies the origin blockchain of the asset.
- **Total supply**: A mutable field representing the total supply ( `big_integer`) of the asset, modifiable during
minting or burning operations.

## Number formatting of asset amounts [â€‹](\#number-formatting-of-asset-amounts "Direct link to Number formatting of asset amounts")

### Decimals and amount representation [â€‹](\#decimals-and-amount-representation "Direct link to Decimals and amount representation")

The `decimals` attribute for each asset dictates how amounts should be displayed to users. Raw values are adjusted
according to the number of decimal places set for the asset. For example, an amount of `10000`:

- **Decimals = 1**: Interpreted as `1000.0`
- **Decimals = 2**: Interpreted as `100.00`

### Formatting function [â€‹](\#formatting-function "Direct link to Formatting function")

The function `format_amount_with_decimals(amount: big_integer, decimals: integer)` is used to format raw amounts into
readable strings by adjusting them according to the assetâ€™s decimals:

- **Input parameters**:
  - `amount`: The raw value of the asset balance ( `big_integer`).
  - `decimals`: The number of decimal places ( `integer`) specified by the asset.
- **Output**: A formatted `text` string representing the amount.

If `decimals` is zero, the amount is returned as-is. If `decimals` is greater than zero, the function formats the amount
by inserting a decimal point accordingly. This ensures amounts display correctly in a way that aligns with the asset's
intended precision.

### Example usage [â€‹](\#example-usage "Direct link to Example usage")

- `format_amount_with_decimals(11, 2)` will output `"0.11"`.

### Validation [â€‹](\#validation "Direct link to Validation")

The `decimals` attribute is validated through `validate_asset_decimals(decimals: big_integer)`, ensuring it lies within
the range `[0, 78]`.

## Amount validation [â€‹](\#amount-validation "Direct link to Amount validation")

The system uses specific constraints on amounts to ensure compliance with blockchain standards:

- **Maximum value**: `max_asset_amount`, which limits any asset-related amount to avoid overflow issues in EVM `int256`
compatibility.
- **Positive amounts**: `require_zero_exclusive_asset_amount_limits(value: big_integer, name: text)` enforces non-zero,
positive values for any amount field. Attempts to operate with amounts outside this range will throw an error.

## Balance management and amount calculation [â€‹](\#balance-management-and-amount-calculation "Direct link to Balance management and amount calculation")

Balances are managed in the following ways:

- **Increase bBalance**: The `increase_balance(account, asset, amount)` function increases a given account's balance for
a specified asset by a certain amount, adjusting the balance record accordingly. If the balance does not yet exist, it
creates a new balance entity.
- **Deduct balance**: The `deduct_balance(account, asset, amount)` function reduces the balance for a specified asset
and account. It validates that the account holds sufficient assets before performing the deduction, deleting the
balance record if the balance reaches zero.

### Error handling in balance management [â€‹](\#error-handling-in-balance-management "Direct link to Error handling in balance management")

Errors such as `"INSUFFICIENT BALANCE"` are thrown if an account attempts to deduct more than its current balance.
Additionally, `"INVALID AMOUNT"` errors may occur if balance management functions are called with values outside allowed
bounds.

## Cross-chain asset compatibility [â€‹](\#cross-chain-asset-compatibility "Direct link to Cross-chain asset compatibility")

Cross-chain assets are recognized through the `issuing_blockchain_rid` field, identifying the original blockchain for
assets. Transactions involving minting or burning on non-origin chains will throw `"UNAUTHORIZED MINTING"` or
`"UNAUTHORIZED BURNING"` errors, enforcing asset integrity across chains.

- [Asset structure](#asset-structure)
- [Number formatting of asset amounts](#number-formatting-of-asset-amounts)
  - [Decimals and amount representation](#decimals-and-amount-representation)
  - [Formatting function](#formatting-function)
  - [Example usage](#example-usage)
  - [Validation](#validation)
- [Amount validation](#amount-validation)
- [Balance management and amount calculation](#balance-management-and-amount-calculation)
  - [Error handling in balance management](#error-handling-in-balance-management)
- [Cross-chain asset compatibility](#cross-chain-asset-compatibility)[Skip to main content](#__docusaurus_skipToContent_fallback)

FT4 accounts can be registered with open, fixed, or subscription fee strategies, each offering flexible access options.
auth descriptors control account access, while account\_link manages relationships between accounts for scenarios like
staking and asset locking.

[Register FT4 accounts using strategies like open, fee, or subscription. Admin operations allow authorized users to create accounts directly, while custom operations enable tailored registration with enhanced security measures.](/ft4/backend/overview) [The open fee strategy allows free account creation and exploration, making it ideal for early-stage development and\\
community building. However, it may be prone to abuse and is not suitable for long-term use. Itâ€™s the default\\
setting in many dapps.](/ft4/backend/open) [The fixed fee strategy charges a set fee for actions like account creation or transactions, ensuring simplicity and\\
transparency. This approach fosters trust, simplifies financial management, and encourages user loyalty.](/ft4/backend/fixed) [The subscription fee strategy enables recurring payments for dapp access, creating a predictable revenue stream with\\
easy setup. It supports both automatic and self-serve activation methods for user convenience.](/ft4/backend/subscription) [Accounts can have multiple auth descriptors, with one main descriptor controlling access. Descriptors can be\\
replaced and linked to the account with specific rules, while the main descriptor cannot be deleted.](/ft4/backend/accounts-and-auth-descriptors) [The account\_link entity manages relationships between accounts, supporting scenarios such as staking, asset locking, and auctions. It enables flexible workflows with secure asset handling for both user-controlled and system-managed accounts.](/ft4/backend/account-linking)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Each query in FT4 has pagination enabled by default. The query will return a paged result containing the result and the
cursor to fetch the next page.

The pagination system revolves around two key components:

1. **`page_cursor`**: Points to the position in the data where the next page should begin.
2. **`paged_result`**: Contains the data for the current page and a cursor for fetching the next page.

You can use this utility in queries where paginated results are needed, enabling the front-end to request data page by
page.

### Key functions and structures [â€‹](\#key-functions-and-structures "Direct link to Key functions and structures")

- **`page_cursor`**: A struct that keeps track of the position of the last item retrieved.
- **`pagination_result`**: Represents a single element of a paginated result containing data of the fetched result and
the rowid.
- **`paged_result`**: Represents the full response of a paginated query. Contains a list of data and a cursor to fetch
the next page.
- **`encode_cursor` & `decode_cursor`**: Functions that encode and decode a `page_cursor` into a Base64 string for
easier management.
- **`fetch_data_size`**: Determines the page size based on the request and module configuration.
- **`make_page`**: Creates a paginated response from a list of data, and ensures the page size is respected.
- **`before_rowid`**: Retrieves the `rowid` of the last retrieved element from the cursor, used to determine where the
next page should start.

- [Key functions and structures](#key-functions-and-structures)[Skip to main content](#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

The open fee strategy allows users to create accounts and explore the dapp completely free of charge. This approach is
ideal for:

- **Early-stage development:** Gathering valuable feedback and building a user base during the initial testing phases.
- **Community building:** Fostering a vibrant community by removing barriers to entry and encouraging participation.

#### Benefits of open fees: [â€‹](\#benefits-of-open-fees "Direct link to Benefits of open fees:")

- **Frictionless user acquisition:** Attracts users quickly with a free and easy onboarding process.
- **Community growth:** Encourages user interaction and helps build a strong community around the dapp.
- **Brand awareness:** Increases brand recognition and awareness early on.

#### Important considerations: [â€‹](\#important-considerations "Direct link to Important considerations:")

- **Potential for abuse:** Open access can be susceptible to spam or malicious activity. Implementing safeguards may be
necessary at a later stage.
- **Limited for production:** This strategy may not be suitable for long-term or secure operation.

The open fee model is the default setting in all dapps out of the box, so no additional configuration is required.[Skip to main content](#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.[Skip to main content](#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In the FT4 library, cross-chain assets are assets that originate on one blockchain but can be registered, tracked, and
transferred across other chains in the ecosystem.

## Cross-chain Asset Registration [â€‹](\#cross-chain-asset-registration "Direct link to Cross-chain Asset Registration")

Cross-chain assets must be registered on a receiving chain to be used there. The **`register_crosschain_asset`**
function handles this registration, ensuring that assets from other blockchains are properly linked to their origin and
available on the new chain. This function is marked as `Unsafe` because it could potentially register numerous assets
and thus impact storage requirements.

### Registration Requirements and Parameters [â€‹](\#registration-requirements-and-parameters "Direct link to Registration Requirements and Parameters")

When registering a cross-chain asset, certain criteria must be met to ensure the asset's uniqueness and proper linkage
to its origin chain. Below are the key parameters required for registration:

- **`asset_id`**: A unique identifier for the asset.
- **`name`**: The name of the asset, which should be concise and unique within the network to prevent conflicts.
- **`symbol`**: A short identifier, like a ticker, to represent the asset.
- **`decimals`**: Specifies the precision (number of decimal places) of the asset, within an acceptable range (0â€“78).
- **`issuing_blockchain_rid`**: The blockchain where the asset was initially created.
- **`origin_blockchain_rid`**: The origin chain providing the asset to the current chain, often the same as the issuing
chain but can differ in complex scenarios.
- **`icon_url`**: Optional URL for the assetâ€™s icon.
- **`type`**: Specifies the asset type, typically set to `core.asset.ASSET_TYPE_FT4`.
- **`uniqueness_resolver`**: An optional byte array used to avoid conflicts in cases where uniqueness cannot be
guaranteed by other parameters alone.

**Note**: The `register_crosschain_asset` function includes several validations, such as checking ID length, type
conformity, and icon URL validity.

### Validation Constraints [â€‹](\#validation-constraints "Direct link to Validation Constraints")

This function has built-in checks to prevent registration errors or misuse:

- **Origin and Issuing Chain Constraints**:
  - The `origin_blockchain_rid` must not be the current chain, ensuring the asset is from an external source.
  - Similarly, the `issuing_blockchain_rid` cannot be the current chain, as an asset issued locally does not qualify as
    a cross-chain asset.
- **Asset ID Validation**:
  - Validates asset ID length (32 bytes) and ensures the name, symbol, and uniqueness resolver fall within specified
    length limits.

## Avoiding name conflicts [â€‹](\#avoiding-name-conflicts "Direct link to Avoiding name conflicts")

To avoid conflicts in asset names and symbols across multiple chains, Chromia enforces several rules:

- **Uniqueness of `name` and `symbol`**: These identifiers must be unique within the blockchain network. This uniqueness
prevents ambiguity when the same asset name or symbol exists across multiple chains.
- **`uniqueness_resolver`**: In situations where name conflicts are still possible (for example, in multi-chain
scenarios with similar assets), the `uniqueness_resolver` can be used to enforce distinctness. This byte array acts as
an extra layer to ensure that even assets with the same name or symbol have a unique identifier.

## Structure of Cross-chain Asset Management [â€‹](\#structure-of-cross-chain-asset-management "Direct link to Structure of Cross-chain Asset Management")

Chromiaâ€™s cross-chain asset management relies on two core structures: the **`asset_origin` entity** and **blockchain**
**accounts** for tracking cross-chain balances.

### `asset_origin` Entity [â€‹](\#asset_origin-entity "Direct link to asset_origin-entity")

The `asset_origin` entity links each cross-chain asset to its originating blockchain, enabling proper routing and
tracking when assets are transferred across chains.

- **`assets.asset`**: The cross-chain asset being registered.
- **`origin_blockchain_rid`**: The identifier for the originating blockchain, establishing the origin chain that
supplies this asset to the current chain.

### Blockchain Accounts [â€‹](\#blockchain-accounts "Direct link to Blockchain Accounts")

Blockchain accounts in Chromia serve as balance trackers for cross-chain transfers. Each downstream chain maintains a
**blockchain account** to track incoming and outgoing balances for tokens from upstream chains.

#### Key Characteristics of Blockchain Accounts [â€‹](\#key-characteristics-of-blockchain-accounts "Direct link to Key Characteristics of Blockchain Accounts")

- **Balance Management**: When tokens are transferred to or from downstream chains, the blockchain account's balance is
adjusted accordingly.
- **Account Type**: Each blockchain account is set to a specific account type, `ACCOUNT_TYPE_BLOCKCHAIN`, which
designates it as a blockchain account rather than a user or business account.

The function **`ensure_blockchain_account`** ensures that a blockchain account exists for each downstream chain,
creating it as necessary and assigning it the correct type.

## Example of Cross-chain Asset Registration [â€‹](\#example-of-cross-chain-asset-registration "Direct link to Example of Cross-chain Asset Registration")

When registering an asset from an external chain, the registration function call might look like the following:

```codeBlockLines_e6Vv
register_crosschain_asset(
    asset_id = "unique-asset-id",
    name = "CrossChainToken",
    symbol = "CCT",
    decimals = 18,
    issuing_blockchain_rid = "upstream-chain-rid",
    icon_url = "https://example.com/icon.png",
    type = "ft4",
    uniqueness_resolver = "resolver-bytes",
    origin_blockchain_rid = "parent-chain-rid"
)

```

In this example:

- The function verifies the uniqueness and validity of the asset parameters.
- Checks are made to ensure the asset comes from an external source ( `origin_blockchain_rid`).
- A new `asset_origin` entity is created, linking `CrossChainToken` to its origin chain, `parent-chain-rid`.

- [Cross-chain Asset Registration](#cross-chain-asset-registration)
  - [Registration Requirements and Parameters](#registration-requirements-and-parameters)
  - [Validation Constraints](#validation-constraints)
- [Avoiding name conflicts](#avoiding-name-conflicts)
- [Structure of Cross-chain Asset Management](#structure-of-cross-chain-asset-management)
  - [`asset_origin` Entity](#asset_origin-entity)
  - [Blockchain Accounts](#blockchain-accounts)
- [Example of Cross-chain Asset Registration](#example-of-cross-chain-asset-registration)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

The `account_link` entity is a versatile structure designed to represent a relationship between two accounts. This
entity can be customized for various purposes by developers, enabling the management of complex account interactions
such as staking, locking, or auction-related transactions.

## Overview [â€‹](\#overview "Direct link to Overview")

The `account_link` can be leveraged in scenarios where assets are held temporarily in a non-user-controlled account, or
in cases where accounts must be linked for internal management or governance reasons. This flexibility allows developers
to implement custom workflows and control mechanisms that support both user-controlled and system-controlled accounts.

## Structure [â€‹](\#structure "Direct link to Structure")

### Entity definition: `account_link` [â€‹](\#entity-definition-account_link "Direct link to entity-definition-account_link")

The entity's structure allows it to store essential details of the relationship between accounts. Hereâ€™s an outline of
the fields and their purposes:

- **Primary account ( `accounts.account`)**: Represents the main or initiating account in the relationship. Typically,
this is a user account.
- **Secondary account ( `secondary: accounts.account`)**: The target or secondary account in the relationship, often a
non-user-controlled account used for specific purposes.
- **Relationship type ( `type: text`)**: A description of the relationship, specified as text. Common examples include
terms like `"stake"` or `"bid"`.

#### Indices [â€‹](\#indices "Direct link to Indices")

- **Primary key**: `(account, secondary)` â€” Uniquely identifies the link between a specific primary and secondary
account.
- **Secondary index**: `(secondary, type)` â€” Facilitates efficient querying based on the secondary account and
relationship type.

* * *

## Usage scenarios [â€‹](\#usage-scenarios "Direct link to Usage scenarios")

This entity is intended for scenarios where temporary control of assets or relationships between accounts is needed,
especially when assets should be beyond the immediate control of the primary user account. Here are some typical use
cases:

1. **Lock accounts**:
   - Lock accounts allow assets to be held temporarily, with users having limited or no access.
   - **Example**: Staking tokens in a contract that prevents immediate withdrawal, using a custom lock account type
     defined as `ACCOUNT_TYPE_LOCK`.
2. **Bidding and auction**:
   - Bids in auctions often require assets to be held by the system to prevent immediate access by the bidder.
   - **Example**: An auction system where bid amounts are locked until the auction concludes, utilizing a
     system-controlled secondary account.
3. **System-controlled accounts**:
   - Many types of operations require system-level accounts to hold assets on behalf of users, without allowing users to
     reclaim them freely.
   - **Example**: A service or governance system managing assets with specific rules for accessibility or control.
4. **Custom non-user account types**:
   - Developers can define accounts that users may only control under certain conditions or with specific permissions.
   - **Example**: An escrow account controlled by a smart contract, where a user may release funds only after predefined
     conditions are met.

## Implementation notes [â€‹](\#implementation-notes "Direct link to Implementation notes")

- **Customizability**: The `account_link` entity is deliberately flexible. It allows any relationship type to be defined
based on the applicationâ€™s needs.
- **Security and access control**: Since non-user accounts can hold assets beyond a user's immediate reach, implementing
secure access and control mechanisms is recommended for any application that leverages this entity.
- **On-chain transparency**: By storing the relationship on-chain, applications using this entity can audit account
links, ensuring transparency and accountability in asset management and user interactions.

## Related modules [â€‹](\#related-modules "Direct link to Related modules")

### Locking and account types [â€‹](\#locking-and-account-types "Direct link to Locking and account types")

- **`core.assets.locking`**: Provides examples of lock accounts, including details on how assets can be secured in
non-user accounts.
- **`core.accounts.account.type`**: Offers more information on custom account types and their potential use in creating
accounts with limited user control.

## Example definition [â€‹](\#example-definition "Direct link to Example definition")

```codeBlockLines_e6Vv
entity account_link {
    key account, secondary;
    index secondary, type;

    // Primary account in the relationship, typically a user account.
    accounts.account;

    // Secondary account, often a system or non-user account.
    secondary: accounts.account;

    // Describes the type of relationship, e.g., "stake", "bid".
    type: text;
}

```

- [Overview](#overview)
- [Structure](#structure)
  - [Entity definition: `account_link`](#entity-definition-account_link)
- [Usage scenarios](#usage-scenarios)
- [Implementation notes](#implementation-notes)
- [Related modules](#related-modules)
  - [Locking and account types](#locking-and-account-types)
- [Example definition](#example-definition)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In the FT4 library, accounts function as digital identities, enabling users to transfer assets, interact with dapps, and
sign transactions. Account registration allows the system to securely identify and authenticate users, supporting access
control mechanisms that let users or administrators define permissions for actions an account can perform. This approach
is crucial for maintaining security, preventing unauthorized access, and ensuring that resources such as assets or data
remain accessible only to the rightful owner.

## Account registration framework [â€‹](\#account-registration-framework "Direct link to Account registration framework")

For most dapps, the **account registration framework** provided by the FT4 library is the recommended approach. This
framework offers a flexible, secure, and scalable system for creating new accounts, supporting various strategies
tailored to different business models and security requirements. The framework simplifies the developer experience,
offering pre-built solutions for common registration scenarios.

### Registration strategies [â€‹](\#registration-strategies "Direct link to Registration strategies")

The account registration framework supports several strategies:

- **Open:** Anyone can call the `register_account()` operation to create an account without restrictions.
- **Transfer strategy**: Users must perform a transfer to the account address before creating an account. The transfer
strategy includes three sub-strategies:
  - **Open**: Users can claim the entire deposit to their newly created account.
  - **Fee**: Part of the transferred assets is collected as a fee to the chain's fee account, allowing users to claim
    only the remaining assets.
  - **Subscription**: Similar to the fee strategy, but users need to periodically renew their subscription by paying the
    subscription fee to maintain account access.

To enable a specific strategy, import the corresponding module into the Rell file and configure it in the `chromia.yml`
file. The modules are named as follows:

- `lib.ft4.core.accounts.strategies.open` (open strategy)
- `lib.ft4.core.accounts.strategies.transfer.open` (transfer open strategy)
- `lib.ft4.core.accounts.strategies.transfer.fee` (transfer fee strategy)
- `lib.ft4.core.accounts.strategies.transfer.subscription` (transfer subscription strategy)

#### Transfer strategy [â€‹](\#transfer-strategy "Direct link to Transfer strategy")

To use any of the transfer strategies, certain `moduleArgs` must first be configured in the `chromia.yml` file under the
key:

```codeBlockLines_e6Vv
lib.ft4.core.accounts.strategies.transfer

```

Under this key, settings must be specified, including which chains are permitted to make transfers to the chain and
which assets are accepted. Configuring these parameters helps prevent potential DOS attacks and spam from untrusted
chains. Here is an example configuration:

```codeBlockLines_e6Vv
lib.ft4.core.accounts.strategies.transfer:
  rules:
    - sender_blockchain: # List of blockchain rids from which we will accept transfers
      - x"08B02E0E14B634031FDF2ED3FD78E7410A5849CD28"
    sender: * # Anyone on the specified blockchain can send us assets
    recipient: * # They can send assets to anyone on this chain
    asset: # List of assets that can be sent from this chain
      - name: CHR # Name of the asset (id can also be used instead)
        min_amount: 5L # If transfer is of less than this value, then the transfer will be rejected
    timeout_days: 30 # After this many days, the sender is allowed to recall the transfer if it hasn't been claimed
    strategy: # List of transfer strategies to enable
      - "fee"
      - "open"

```

In this example, every user on a specified Chromia blockchain is allowed to send a minimum of 5 CHR to any user on the
receiving blockchain. If the transfer recipient does not have an existing account, they can create one using either the
`open` or `fee` strategy. This configuration enables granular control over which blockchains can send assets and create
accounts.

If only the `open` strategy is enabled, additional configurations are not required. However, the `open` strategy may not
provide optimal spam protection, as it could allow the creation of numerous accounts with minimal assets. For enhanced
protection, using an alternative strategy, such as the `fee` strategy, is recommended.

To configure the `fee` strategy, additional steps are required beyond the initial setup. First, import the strategy in
the main `module.rell` file

```codeBlockLines_e6Vv
import lib.ft4.accounts.strategies.transfer.fee;

```

Then, configure the strategy by specifying the valid asset(s) for payments, the fee amount, and the destination for the
fee payment. This is done by adding a configuration under the `moduleArgs` key in the `chromia.yml` file:

```codeBlockLines_e6Vv
lib.ft4.core.accounts.strategies.transfer.fee:
  asset:
    - id: x"b31ba66a11a28930d948c8f959cc306184096d1ee858542e765a139b3c79b1aa" # We can specify an asset by id
      amount: 2L # How much of this asset to pay
    - name: test1 # we can specify an asset by name, this will refer to an asset issued by this chain
      amount: 1L
    - issuing_blockchain_rid: x"6403ccac0c67f7cb6af78e5e15b3aaebb2b42370f0d12e099ed01fa5a068f9fb" # We can also specify assets issued by a different chain, even if the names are the same
      name: test1
      amount: 3L
  fee_account: x"023c72addb4fdf09af94f0c94d7fe92a386a7e70cf8a1d85916386bb2535c7b1b1" # All fees will be collected into this account

```

In the configuration above, users can pay the fee using one of three assets, with varying amounts depending on the
asset. This flexibility can accommodate value differences between assets or encourage payment with a preferred asset.
Additionally, the account for fee collection is specified, which should typically be controlled by the dapp owner.

caution

The `amount` set for an asset must be lower than the `min_amount` specified for that asset. If the `amount` is set too
high, users may accidentally send an insufficient amount, preventing account creation until the transfer timeout is
reached. They would then need to recall and repeat the transfer with the correct amount.

For account registration using a transfer strategy, a transfer must first be made to the account. If the user already
holds an account with enough assets, they may initiate the transfer themselves, or a friend might perform it on their
behalf, functioning as an invitation system.

info

To see an example of account registration using the `transfer open` strategy, explore the
[Transfer open strategy account registration demo](https://bitbucket.org/chromawallet/ft3-lib/src/development/examples/register-account-transfer-open/).

## Register with FT4 admin operation [â€‹](\#register-with-ft4-admin-operation "Direct link to Register with FT4 admin operation")

For scenarios requiring greater control or direct intervention, Chromia offers the **FT4 admin operation**. This
admin-level operation allows authorized administrators to create accounts directly, bypassing the user-driven
registration process.

### Why Use the admin operation? [â€‹](\#why-use-the-admin-operation "Direct link to Why Use the admin operation?")

Admin operations are intended for cases requiring stricter control over account creation, such as when developers or
dapp owners need to create accounts for system users, team members, or to initiate specific business processes. Unlike
user-led registrations, admin operations can bypass certain checks and constraints, enabling direct management of the
blockchain environment.

However, admin operations are not recommended for production environments, as they may introduce security risks if not
carefully managed. If an admin operation is necessary, consider building a custom admin module tailored to the specific
requirements of the dapp.

warning

Admin operations are enabled by importing the admin module and should not be used in production.

### Admin vs. non-admin operations [â€‹](\#admin-vs-non-admin-operations "Direct link to Admin vs. non-admin operations")

- **Admin operations**: These provide broader permissions and access, allowing administrators to perform tasks like
account registration, asset management, or system updates. They are powerful but carry higher risks, as improper use
can affect the security and stability of the entire system.
- **Non-admin operations**: These are designed for end-users or automated processes with more restricted access. They
follow strict rules, ensuring that users can only perform actions they are explicitly authorized to carry out (e.g.,
transferring assets or modifying their own account settings).

### Registering an account with FT4 admin [â€‹](\#registering-an-account-with-ft4-admin "Direct link to Registering an account with FT4 admin")

The FT4 admin operation, `ft4.admin.register_account`, requires an auth descriptor as a parameter. An auth descriptor
specifies who can access an account, what actions they can perform, and the lifetime of the auth descriptor. The access
to an account is determined by a public key when FT authentication (native Chromia signatures) is used or an EVM account
address when an EVM wallet is used for authentication.

The actions allowed by the auth descriptor are specified with authorization keys, and expiration rules determine the
activation and validity duration of the auth descriptor. For more details, see the auth descriptor topic.

To create an account using the FT4 admin operation, follow these steps:

1. Generate a new key pair for the account and retrieve the public key:





```codeBlockLines_e6Vv
chr keygen --file .chromia/user.keypair | grep pubkey

```

2. Register the account using the FT4 admin operation:





```codeBlockLines_e6Vv
chr tx ft4.admin.register_account \
       '[0, [["A","T"], x"0351D4F299E3D33EC745C9F3C2F74934960F58411BE8BAE52A1E6EC8D0BA26AEDB"], null]' \
       --await --secret .chromia/ft4-admin.keypair

```









In this command:
   - `0` represents a single signature auth descriptor.

   - `A` (account) and `T` (transfer) are auth flags defined in the FT library.



     note





     It's important to note that when calling FT account operations, such as `ft4.add_auth_descriptor` or
     `ft4.delete_auth_descriptor`, the authentication will fail unless the auth descriptor used has the `A` flag.
     Similarly, when calling the transfer operation, the transfer will be rejected if the auth descriptor doesn't have
     the `T` flag.

   - Replace `0351D4F299E3D33EC745C9F3C2F74934960F58411BE8BAE52A1E6EC8D0BA26AEDB` with the generated public key for the
     user.
3. A query can be added that returns all accounts to verify if the account exists. Add the following query to your code:





```codeBlockLines_e6Vv
query get_all_accounts() = accounts.account @* {} (.id);

```

4. Update and wait for the blockchain to reflect the changes:





```codeBlockLines_e6Vv
chr node update

```

5. You can now execute the query to retrieve all accounts:





```codeBlockLines_e6Vv
chr query get_all_accounts

```









The output will display the account ID(s), such as:





```codeBlockLines_e6Vv
[x"5E2488889F72939DD4D0A034FB91893ACBF14C7EDBCEF2A9F5C621A07169EAD2"]

```


## Register with a custom operation [â€‹](\#register-with-a-custom-operation "Direct link to Register with a custom operation")

If the provided account registration framework or admin operation does not meet specific requirements, a custom
operation can be created to handle account registration. Writing a custom operation provides full control over the
registration process, enabling customization according to unique requirements and security needs.

tip

When implementing a custom operation, it is advisable to follow best practices for secure coding, including code reviews
and thorough testing, to maintain the integrity and reliability of the account registration process.

When registering an account with a custom operation, protecting the operation against potential spam attacks on the
blockchain is essential. In this example, users are required to provide a voucher during registration. This approach
involves creating a register and an admin operation to allow vouchers to be added.

1. Define the voucher entity and the `add_voucher` operation in your code:





```codeBlockLines_e6Vv
entity voucher {
       hash: byte_array;
       mutable is_used: boolean = false;
}

operation add_voucher(hash: byte_array) {
       admin.require_admin();
       create voucher(hash);
}

```

2. Define the `register_account` operation, which includes voucher validation and account creation:





```codeBlockLines_e6Vv
operation register_account(accounts.auth_descriptor, voucher_code: text) {
       // extract pubkey from auth descriptor
       val pubkey = byte_array.from_gtv(auth_descriptor.args[1]);

       // check if provided key is signer
       require(op_context.is_signer(pubkey), "Transaction needs to be signed by %s".format(pubkey));

       val hash = voucher_code.hash();
       val voucher = require(
           voucher @? { hash },
           "Provided voucher with code <%s> does not exist".format(voucher_code)
       );
       require(
           not voucher.is_used,
           "Provided voucher with code <%s> is already used".format(voucher_code)
       );
       voucher.is_used = true;
       accounts.create_account_with_auth(auth_descriptor);
}

```

3. After adding the code snippets to the appropriate sections in your `main.rell` file, update the blockchain to apply
the changes.

4. Generate a voucher hash using the `chr repl` command as follows:





```codeBlockLines_e6Vv
chr repl -c '"voucher_1".hash()'

```









The output will be a hash like:





```codeBlockLines_e6Vv
x"E1E72D0C6C975815BD3259D81E67253D98CF90D888B4C7CB393C8CFB9043BAF3"

```

5. Add the voucher hash to the blockchain using the admin operation:





```codeBlockLines_e6Vv
chr tx add_voucher \
     'x"E1E72D0C6C975815BD3259D81E67253D98CF90D888B4C7CB393C8CFB9043BAF3"' \
     --await --secret .chromia/ft4-admin.keypair

```

6. Generate a new keypair for the user who'll register the account, and retrieve the public key:





```codeBlockLines_e6Vv
chr keygen --file .chromia/user-2.keypair | grep pubkey

```

7. Register the account using the custom operation `register_account`:





```codeBlockLines_e6Vv
chr tx register_account \
     '[0, [["A", "T"], x"03772E03AE22835384164AA90E28C84F78C97D29A2635861DC3F7E32F0CC8FDF51"], null]' \
     voucher_1 \
     --await --secret .chromia/user-2.keypair

```









Replace `03772E03AE22835384164AA90E28C84F78C97D29A2635861DC3F7E32F0CC8FDF51` with the generated public key for the
user.

8. To verify the successful account registration, execute the `get_all_accounts` query again. You should now see two
account IDs or one if you didn't follow the first half of the guide:





```codeBlockLines_e6Vv
chr query get_all_accounts

```









The output would include the account IDs:





```codeBlockLines_e6Vv
[x"5E2488889F72939DD4D0A034FB91893ACBF14C7EDBCEF2A9F5C621A07169EAD2", x"79C71AF3C9C951BED380F8ADAB2E407C15CC4A9EB942AA222D870136C45801CE"]

```


- [Account registration framework](#account-registration-framework)
  - [Registration strategies](#registration-strategies)
- [Register with FT4 admin operation](#register-with-ft4-admin-operation)
  - [Why Use the admin operation?](#why-use-the-admin-operation)
  - [Admin vs. non-admin operations](#admin-vs-non-admin-operations)
  - [Registering an account with FT4 admin](#registering-an-account-with-ft4-admin)
- [Register with a custom operation](#register-with-a-custom-operation)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

The [Rell](/intro/terminology#rell) dapp consists of modules. A module is either a single `.rell` file or a
directory with one or multiple `.rell` files.

A single-file Rell module must have a module header:

```codeBlockLines_e6Vv
module;

// entities, operations, queries, functions, and other definitions

```

If a `.rell` file has no module header, it's part of a directory module. All such `.rell` files in a directory belong to
the same directory module. An exception is a file called `module.rell`: it always belongs to a `directory-module`, even
if it has a module header. A `directory-module` doesn't need to have `module.rell`.

Every file of a directory module sees definitions of all other module files. A file module file sees only its
definitions. There may be a root module - a directory module that consists of `.rell` files located in the root of the
source directory. The root module has an empty name.

Example of a Rell source directory tree:

```codeBlockLines_e6Vv
.
â””â”€â”€ app
    â”œâ”€â”€ module.rell
    â”œâ”€â”€ entities.rell
    â”œâ”€â”€ operations.rell
    â”œâ”€â”€ queries.rell
    â”œâ”€â”€ functions.rell
    â””â”€â”€ structs.rell

```

Understanding the file structure in depth reveals the organization and purpose behind each component, providing insights
into how the module is built and operates:

- **`module_name`**: This directory serves as the central hub for each module, housing all related files. It is the
foundation where the moduleâ€™s functionalities and features are defined and interconnected.

- **`module.rell`**: This file is essential for initial module setup, including import statements and custom mount
names. It serves as a blueprint, outlining how the module integrates with the broader application architecture.

**Example**:





```codeBlockLines_e6Vv
module;

```

- **`entities.rell`**: Contains the structural backbone, housing entities, enums, and structures (for modules with up to
three structs). It also includes functions for retrieving entities by ID, offering a quick reference to the module's
fundamental data structures.

**Example**:





```codeBlockLines_e6Vv
entity house {
      index street;
      number: integer;
      key street, number;
      number_of_rooms: integer;
      number_of_floors: integer;
      floor_area: integer;
      index number_of_rooms, floor_area;
}

```

- **`operations.rell`**: Lists all the operations the module can perform. These operations are the actionable
components, enabling the module to execute its primary functions.

**Example**:





```codeBlockLines_e6Vv
operation create_house(
      street_id: rowid,
      number: integer,
      number_of_rooms: integer,
      number_of_floors: integer,
      floor_area: integer
) {
      val street = street @ { .rowid == street_id };
      create house ( street, number, number_of_rooms, number_of_floors, floor_area );
}

```

- **`queries.rell`**: A repository of all queries within the module, dictating how it communicates with the database to
fetch and present data.

**Example**:





```codeBlockLines_e6Vv
query get_houses_with_streets() = ( house, street) @* { street == house.street } ( street = .street.address, .number );

```

- **`functions.rell`**: Encapsulates the core of the module's business logic. This file contains a variety of functions
that define how the module processes data and responds to different inputs.

**Example**:





```codeBlockLines_e6Vv
function require_user(id: byte_array) = require(user @? { id }, "User with id %b does not exist".format(id));

```

- **`structs.rell`**: For modules containing more than three structs, this file provides a dedicated space to maintain
clarity and organization, especially in complex modules.

**Example**:





```codeBlockLines_e6Vv
struct user {
      name: text;
      address: text;
      mutable balance: integer = 0;
}

```


## Import [â€‹](\#import "Direct link to Import")

To access the module's definitions, you need to import the module:

```codeBlockLines_e6Vv
import app.single;

function test() {
    single.f();  // Calling the function "f" defined in the module "app.single".
}

```

When importing a module, it's added to the current namespace with some alias. By default, the alias is the last part of
the module name, `single` for the module `app.single` or `multi` for `app.multi`. The definitions of the module can be
accessed via the alias.

A custom alias can be specified:

```codeBlockLines_e6Vv
import alias: app.multi;

function test() {
    alias.g();
}

```

It's possible to specify a relative name of a module when importing. In that case, the name of the imported module is
derived from the current module's name. For example, if the current module is `a.b.c`,

- `import .d;` imports `a.b.c.d`
- `import alias: ^;` imports `a.b`
- `import alias: ^^;` imports `a`
- `import ^.e;` imports `a.b.e`

tip

When importing a function from a module, import the specific module containing the desired function and explicitly call
it using the module name as a namespace. This ensures clarity and eliminates ambiguity. For example, if the `map_entity`
function exists in both `users` and `projects` modules. Importing both modules and directly calling `map_entity` leads
to ambiguity, as it's unclear which function is being invoked.

### Wildcard imports [â€‹](\#wildcard-imports "Direct link to Wildcard imports")

Importing all definitions of a module:

```codeBlockLines_e6Vv
import foo.*;

```

All definitions are added directly to the importing namespace.

It's possible to import definitions of a specific namespace defined within a module:

```codeBlockLines_e6Vv
import foo.{ns.*};

```

An import alias, if specified, creates a nested namespace and adds imported definitions there:

```codeBlockLines_e6Vv
import sub: foo.{ns.*};

```

Definitions from the namespace `ns` of module `foo` in this example are added to a new namespace `sub`.

### Import specific definitions [â€‹](\#import-specific-definitions "Direct link to Import specific definitions")

To import a specific definition (or a set of definitions) from a module, specify their names in braces:

```codeBlockLines_e6Vv
import foo.{f};
import foo.{g, h};

```

The definitions "f", "g", and "h" are added to the importing namespace like they were defined there.

If an import alias is specified, a nested namespace is created:

```codeBlockLines_e6Vv
import ns: foo.{f, g};

```

This creates a namespace `ns` containing definitions `f` and `g`.

One can specify an alias for individual definitions in braces:

```codeBlockLines_e6Vv
import foo.{a: f, b: g};

```

Imported definitions in this example are added to the namespace under names `a` and `b`.

## Run-time [â€‹](\#run-time "Direct link to Run-time")

At run-time, not all modules defined in a source directory tree are active. Only the main module and all modules it
imports (directly or indirectly) are active. There is a main module that is specified when starting a Rell app.

When a module is active, its operations and queries can be invoked, and tables for its entities and objects are added to
the database on initialization.

- [Import](#import)
  - [Wildcard imports](#wildcard-imports)
  - [Import specific definitions](#import-specific-definitions)
- [Run-time](#run-time)[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ”—Create a simple app using Rell and React**](https://learn.chromia.com/courses/my-news-feed/introduction)[**ğŸ”—Build a decentralized marketplace using FT4**](https://learn.chromia.com/courses/marketplace-course/introduction)[**ğŸ”—Write your first dapp on Chromia**](https://learn.chromia.com/courses/monetize-dapp/introduction)[**ğŸ”—Monetize your dapp**](https://learn.chromia.com/courses/my-news-feed/introduction)[Skip to main content](#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Chromia provides a cloud-like hosting experience with the benefits of decentralization and a zero gas fee policy,
meaning transactions are free for users. Instead of gas fees, developers lease containers that come with dedicated
resources, such as vCPU, RAM, storage, and I/O bandwidth. This approach ensures predictable hosting costs while
maintaining a decentralized infrastructure.

## Dapp containers and Standard Container Units (SCUs) [â€‹](\#dapp-containers-and-standard-container-units-scus "Direct link to Dapp containers and Standard Container Units (SCUs)")

Dapps on Chromia run in containers that are duplicated across all [nodes](/intro/architecture/node) in a
[cluster](/intro/architecture/). This setup ensures consistent performance and decentralization, providing dedicated
resources for each container. This way, traffic elsewhere on the network doesn't affect your dapp. As demand for your
dapp grows, you can scale horizontally by adding more containers.

**Flexible leasing model:** You can lease containers on a weekly basis, adjusting resources as needed. You make payments
in CHR, and we adjust the cost to a USD-equivalent target for predictability.

info

One SCU provides 2 GB RAM, 0.5 vCPU, 16 GB storage, and I/O bandwidth of 25 MiB/s read and 20 MiB/s write. The current
weekly target cost is approximately 90 USD for a default 7-node dapp cluster.

## Understanding hosting costs [â€‹](\#understanding-hosting-costs "Direct link to Understanding hosting costs")

Chromia's hosting model offers predictable and manageable costs, which depend on the following factors:

- **Number of SCUs:** The main cost driver is the number of SCUs leased, providing more resources for handling higher
traffic and more demanding workloads.
- **Additional storage:** Extra storage can be added beyond the base SCU allocation for an additional fee.

You can make payments manually or programmatically, and any network participant can cover them to ensure continuous
operation.

## Hosting fee estimator

Could not fetch CHR/USDT price

## Monetizing your application [â€‹](\#monetizing-your-application "Direct link to Monetizing your application")

Chromia gives you the freedom to design whatever revenue model that works best for your dapp. You have the option to
select or combine approaches such as:

- **Freemium model:** Provide a basic version for free, and offer optional paid upgrades for advanced features.
- **Subscription model:** Charge recurring fees to provide access to premium content or services.
- **Pay-per-use:** Bill users based on specific usage, like asset transfers or data access.

Ultimately, you have the flexibility to implement any monetization strategy that fits your project.

- [Dapp containers and Standard Container Units (SCUs)](#dapp-containers-and-standard-container-units-scus)
- [Understanding hosting costs](#understanding-hosting-costs)
- [Monetizing your application](#monetizing-your-application)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Auth descriptors are a mechanism that defines the authorized key pairs and their associated permissions for interacting
with accounts on the blockchain. They enable features like multi-signature security and granular access control,
allowing for secure and flexible management of account access.

### Entities involved [â€‹](\#entities-involved "Direct link to Entities involved")

- **Account**: An on-chain entity representing a user or an app on the blockchain, capable of interacting with other
entities like tokens and smart contracts.
- **User**: A person seeking access to on-chain services through an account.
- **Key pair**: A cryptographic tool used for identification and authorization, consisting of a public key (shared
publicly) and a private key (kept secret).

A more detailed description of these terms can be found in the [glossary](/terms)

### Key concepts [â€‹](\#key-concepts "Direct link to Key concepts")

- #### User and key pair relationships [â€‹](\#user-and-key-pair-relationships "Direct link to User and key pair relationships")

  - A single user can have multiple key pairs for added security or convenience.
  - A single key pair should **never** be shared among multiple users.
- #### Account and key pair/user relationships [â€‹](\#account-and-key-pairuser-relationships "Direct link to Account and key pair/user relationships")

  - A single account can be accessed by multiple key pairs and users, enabling shared accounts for groups or
    applications.
  - A single key pair can be used to access multiple accounts, providing flexibility for the user.

warning

**Never share your private key.** The FT4 library offers secure methods for managing multiple user access to accounts
without compromising private keys.

**Role of auth descriptors**:

Auth descriptors define the key pairs authorized to interact with the blockchain on behalf of an account. This allows
for:

- **Multi-signature security:** By requiring multiple keypairs to co-sign transactions, critical operations can be
secured with the combined approval of authorized parties.
- **Granular access control:** Permissions specified in the descriptor can restrict the actions and resources specific
keypairs can access within an account.

## Auth descriptor components [â€‹](\#auth-descriptor-components "Direct link to Auth descriptor components")

An auth descriptor consists of arguments and rules.

- The arguments include who can access it and what they can do.
- The rules explain under what conditions the auth descriptor is usable.

### Auth descriptor arguments [â€‹](\#auth-descriptor-arguments "Direct link to Auth descriptor arguments")

**Components**:

1. **Public keys**: This component specifies the public keys that can be used to identify authorized key pairs for
accessing the account. You can include multiple public keys to establish multi-signature access control.
2. **Permissions (flags)**: This component defines the specific actions or resources the authorized key pairs can access
or interact with within the account. For example, certain key pairs may be granted permission to transfer tokens,
while others may be restricted to basic interactions with tokens.
3. **Required signatures**: This optional component specifies the number of authorized key pairs whose signatures are
required for a transaction to be valid. This configuration enables multi-signature authentication, where multiple key
pair approvals are needed for critical actions, enhancing security. This value can be less than the number of
provided public keys if not all signers need to sign a transaction.

**Variations**:

- **Single-signature (single-sig)**: If only one key pair can be granted access, the "Required Signatures" component can
be omitted, simplifying the auth descriptor for straightforward single-user scenarios.
- **Multi-signature (multi-sig)**: The default configuration includes the "Required Signatures" component, enabling
scenarios where multiple key pairs need to co-sign transactions, providing higher security for critical operations.

### Auth descriptor rules [â€‹](\#auth-descriptor-rules "Direct link to Auth descriptor rules")

Auth descriptor rules use a combination of operators, variables, and values to define specific conditions that must be
met for an auth descriptor to be considered valid.

- Operators
  - `>`: Greater than
  - `>=`: Greater than or equal to
  - `=`: Equal to
  - `<`: Less than
  - `<=`: Less than or equal to
- Variables
  - `operation_count`: Represents the number of times the account has been used.
  - `block_time`: Represents the timestamp of the latest block on the blockchain.
  - `block_height`: Represents the block height of the latest block on the blockchain.
  - `relative_block_height`: Same as `block_height`, but the value is relative to the block in which the auth descriptor
    was registered instead of the genesis block.
  - `relative_block_time`: Same as `block_time` but relative to the block in which the auth descriptor was registered
    instead of the timestamp of the genesis block.

In the case of the two relative rules, an expression like `relative_block_time < 120000` would mean that the the auth
descriptor would be valid from its creation and 120000ms (aka 2 minutes) into the future.

note

The `operation_count` variable is only compatible with the `<=` and `<` operators.

A rule can either be simple or complex. Complex rules have multiple conditions, and they must all be true for the auth
descriptor to be usable.

When considering whether an auth descriptor is usable, the rules will be checked, and the auth descriptor will be
assigned a status. Based on the evaluation of its rules, an auth descriptor can be assigned one of three statuses:

- **Active**: The auth descriptor meets all its rule requirements and can be used for transactions.
- **Inactive**: The auth descriptor currently violates one or more rule conditions, but it may become usable if the
conditions change.
- **Expired**: The auth descriptor permanently violates its rules and can no longer be used for transactions.

Expired auth descriptors will be automatically cleaned up when the user interacts with an account, and you do not need
to remove them manually.

The provided functions allow you to define a rule easily. These rules will enable you to define specific conditions that
must be met before the associated auth descriptor becomes valid or invalid.

- [Entities involved](#entities-involved)
- [Key concepts](#key-concepts)
- [Auth descriptor components](#auth-descriptor-components)
  - [Auth descriptor arguments](#auth-descriptor-arguments)
  - [Auth descriptor rules](#auth-descriptor-rules)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Chromia FT4 (Flexible Token 4) is an advanced token standard designed for the Chromia blockchain, offering enhanced
asset and account management capabilities. Similar to the ERC20 standard in Ethereum, FT4 facilitates token creation,
transfer, and ownership tracking. However, FT4 goes beyond basic token management by providing additional features like
flexible account access controls, multi-signature support, and configurable rules for managing assets and accounts. This
makes it ideal for more complex decentralized applications (dApps) requiring nuanced account management, robust
security, and fine-grained control over assets.

It has its own client library, created for ease of use on the frontend.

FT4

Client (TypeScript)

Uses Postchain Library

Backend (Rell)

Account Management

Asset Management

Transfers

Same Chain

Cross Chain

Authorization

Auth Descriptor

Multisig

Singlesig

Pagination

## Client [â€‹](\#client "Direct link to Client")

The client is written in TypeScript. It is made for easier access to the backend operations and queries and ready to be
used on the frontend (or a js backend).

The library is available on [npm](https://www.npmjs.com/package/@chromia/ft4).

## Backend [â€‹](\#backend "Direct link to Backend")

The backend part of FT4 is written in rell and holds the implementation of the above-mentioned features:

- [**`Account management`**](/ft4/accounts/account-management)
- [**`Asset management`**](/ft4/accounts/account-management/asset)
- [**`Authorization`**](/ft4/accounts/accounts-and-auth-descriptors)
- [**`Transfers`**](/ft4/accounts/accounts-and-auth-descriptors)
- [**`Cross-chain transfers`**](/backend/cross-chain/cross-chain-transfers)
- [**`Pagination`**](/pagination)

As most dapps in the chromia environment, the ft4 library is configured through the `chromia.yml` file which belongs to
the dapp importing it.

warning

While FT4 assets share many similarities with ERC20 tokens, there are key differences, especially around how asset
management and account control are handled. These differences offer greater flexibility for more complex use cases. More
detailed comparisons and technical distinctions between FT4 and ERC20 can be found in the [FT4 Glossary](/ft4/terms#asset).

- [Client](#client)
- [Backend](#backend)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Providers are individuals or organizations who contribute computing power to the network. They run nodes, which are
high-performance computers that store and process data for Chromia. These nodes act as the backbone of the Chromia
blockchain.

## System Providers and Node Providers [â€‹](\#system-providers-and-node-providers "Direct link to System Providers and Node Providers")

There are two different roles that Providers can have that come with varying levels of responsibility:

1. **System Providers**: These Providers run nodes in the network's system cluster. They manage the network's core
infrastructure by overseeing the smooth operation of the system chains, which form the foundation upon which Chromia
operates. System Providers are responsible for voting on crucial proposals that shape the network's future, such as
adding new system providers. System Providers can also initiate the creation of new dapp clusters as demand on the
network increases.
2. **Node Providers**: These Providers contribute by running nodes in dapp clusters, providing infrastructure for dapps
deployed by developers to run. While System Providers are allowed to run nodes in both the system cluster and dapp
clusters, Node Providers are only allowed to run nodes in dapp clusters. A Node Provider can be promoted into a
System Provider through voting among the current System Providers.

Providers in the Chromia network have a significant say in the decision-making process. They vote on various proposals,
and a super-majority (greater than â…”) is required to approve substantial changes to the network.

Providers manage two types of key pairs:

1. A **provider key pair**, used to vote on and sign proposals. This key pair is used to identify the provider on the
network.
2. **Node key pairs**, used to identify each node on the network. All nodes in the network have their unique key pair.

## Provider staking [â€‹](\#provider-staking "Direct link to Provider staking")

Providers are required to stake a certain amount of Chroma tokens (CHR). Staking helps align Providers' incentives with
the welfare of the network and community. Individual token holders can delegate stake to a Provider to earn a share of
their rewards.

Anyone can stake CHR and receive a 10% annual percentage rate (APR) governance reward, which may change in the future.
The staking contract is deployed on the Ethereum and Binance Smart Chain (BSC) blockchains, allowing users to interact
with it using existing ERC20 wallets, such as MetaMask.

## Provider rewards [â€‹](\#provider-rewards "Direct link to Provider rewards")

Providers receive compensation from a pool of all hosting fees paid by dapps on the network. The compensation a Provider
receives is calculated based on several parameters, such as the amount of computing power contributed to the network,
node uptime, and provider role (system provider or node provider). A proposal can update the reward calculation formula
as the network evolves and the optimal balance of parameters changes. You can read more about the exact formula for
provider rewards in the [provider section](/providers/rewards).

## Next up [â€‹](\#next-up "Direct link to Next up")

Next, we'll look at how to set up a local Rell development environment.

- [System Providers and Node Providers](#system-providers-and-node-providers)
- [Provider staking](#provider-staking)
- [Provider rewards](#provider-rewards)
- [Next up](#next-up)[Skip to main content](#__docusaurus_skipToContent_fallback)

The FT4 Client provides the interface through which applications interact with the blockchain. It facilitates operations
such as querying assets, signing transactions, transferring assets, and performing cross-chain transfers.

[To set up the FT4 client with TypeScript, install the necessary packages using npm install @chromia/ft4. Initialize the client by creating a connection to the Postchain network, and use it to interact with the blockchain (e.g., querying assets).](/ft4/client-setup) [FT4 supports Single-Signature (SingleSig) and Multi-Signature (MultiSig) auth descriptors, allowing customizable\\
permissions and rules for secure access control in decentralized applications.](/ft4/client-auth-descriptors) [FT4 enables non-interactive signing with disposable keys. These keys can be managed via the login function, with\\
care needed when assigning sensitive auth flags. Keys can be stored with different keystore options and cleared on\\
logout for security.](/ft4/client-login) [FT4's KeyStore interface manages cryptographic keys for signing transactions. It includes implementations for\\
Ethereum-compatible keys (EvmKeyStore) and FT4-specific keys (FtKeyStore), supporting in-memory, session, and local\\
storage options.](/ft4/client-key-store) [To transfer assets with FT4, use the Chromia CLI with the ft4.transfer command or the Postchain client library to\\
initiate a transfer using a session. Ensure proper setup of assets, accounts, and key pairs before transferring.](/ft4/client-transfer-assets) [Use the orchestrator for cross-chain asset transfers, ensuring multichain configuration and ICCF module inclusion. Transfer assets between source and target chains with proper error handling and asset registration.](/ft4/client-orchestrator)[Skip to main content](#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.[Skip to main content](#__docusaurus_skipToContent_fallback)

The JavaScript/TypeScript client library, known as postchain-client, provides functionality for interacting with a
blockchain using JavaScript or TypeScript. It allows you to send transactions and retrieve information from a blockchain
node running Rell.

For a detailed introduction to the clients functionality, read the projects
[Readme](https://www.npmjs.com/package/postchain-client).

The library is distributed on npm (Node Package Manager) and can be easily installed in your project. You have two
options to install it:

1. Visit the npm package page for postchain-client and follow the installation instructions provided there, see
[npm-postchain-client](https://www.npmjs.com/package/postchain-client).

2. In your project's terminal or command prompt, execute the following command: `npm install postchain-client`. This
command will download and install the library in your project.


tip

You can find detailed example usage of the JavaScript client in the
[React/Rell course](https://learn.chromia.com/courses/my-news-feed/module-two/connecting-the-client).[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

The prioritization is used to determine which transactions should be processed first on the blockchain. The FT4 library
offers a basic default implementation which calculates priority based on account activity, configured rate limits, and
transaction cost in terms of points. If dapps require a more complex way of calculating priority, the `priority_check`
function can be extended for a custom implementation as described below.

### Core concepts [â€‹](\#core-concepts "Direct link to Core concepts")

- **Priority value**: A zero or posizive decimal value that determines a transactionâ€™s priority within a queue. A higher
value indicates a higher priority.
- **Account points**: Points assigned to each account, representing its rate-limited transaction capacity.
- **Transaction cost points**: The cost in points for each transaction. Transactions are rejected if their cost exceeds
the accountâ€™s current points.

## Priority function details [â€‹](\#priority-function-details "Direct link to Priority function details")

By importing the `lib.ft4.core.prioritization.default` module, transaction prioritization can be enabled so that the
rate-limiting rules are applied to transactions in the transaction queue, which will have the following effects:

- Accounts with more points will get higher priority for their transactions.
- Accounts with disabled rate limiting will get the highest priority for all their transactions.
- Transactions that the rate limiter would have rejected will be rejected immediately upon submission.
- If the queue becomes full, transactions can be removed from the queue to make room for transactions with higher
priority.

This can be customized by importing `lib.ft4.core.prioritization` instead of `lib.ft4.core.prioritization.default` and
extending the function
`priority_check(tx_body: gtx_transaction_body, tx_size: integer, tx_enter_timestamp: timestamp, current_timestamp: timestamp): priority_state_v1?`.

The FT4 library has its own implementation on the priority check function.

```codeBlockLines_e6Vv
import lib.ft4.core.prioritization.*;

@extend(priority_check) function(tx_body: gtx_transaction_body, tx_size: integer, tx_enter_timestamp: timestamp, current_timestamp: timestamp): priority_state_v1 {
    // custom logic here

    return no_op_priority_state();
}

```

More information on extending the function can be found
[here](https://bitbucket.org/chromawallet/ft3-lib/src/master/rell/src/libcore/prioritization/default/module.rell)

### Purpose [â€‹](\#purpose "Direct link to Purpose")

The `priority_check` function assigns a priority value to transactions based on account activity and rate-limiting
rules. It ensures that transactions with sufficient points and higher priority values are processed before others.

### Parameters [â€‹](\#parameters "Direct link to Parameters")

The `priority_check` function accepts the following parameters:

- `tx_body` (gtx\_transaction\_body): Contains the transaction body and operations.
- `tx_size`(integer): Size of the transaction in bytes.
- `tx_enter_timestamp`(timestamp): Timestamp indicating when the transaction entered the queue.
- `current_timestamp`(timestamp): The current time, used for calculating rate-limiting and priority adjustments.

### Priority calculation steps [â€‹](\#priority-calculation-steps "Direct link to Priority calculation steps")

1. **Auth operation extraction**:
   - Filters for **auth operations** within `tx_body` to identify and validate relevant accounts.
   - For each auth operation, extracts `account_id` and `auth_descriptor_id`.
2. **Account and descriptor validation**:
   - Attempts to retrieve account details and corresponding auth descriptor.
   - Returns **`no_op_priority_state()`** (lowest priority state) if:
     - No valid auth operation exists.
     - Account or descriptor information is missing.
3. **Rate limit configuration and points check**:
   - If rate limiting is enabled for the account, the function:
     - Retrieves the **rate limit configuration** and **current points** for the account.
     - Calculates the **priority** as the ratio of `current_points` to `max_points`, capped within (\[0, 1\]).
     - The function returns this calculated priority along with account information.
4. **Handling special cases**:
   - If the account is not rate-limited (i.e., lacks a rate limit configuration, is exempt, or if rate limiting is
     disabled):
     - Returns **`no_account_priority_state(1.0)`**, representing a high priority with no associated account
       information.
   - If multiple accounts are involved, the priority is assigned based on the first valid account.

### Return types and states [â€‹](\#return-types-and-states "Direct link to Return types and states")

The function can produce several specific states based on the account and rate-limiting status:

- `no_op_priority_state()`: \- Represents the lowest priority state with a priority of `0.0` and no associated account
information. - Triggered when no valid account or auth operation is found.

- `no_account_priority_state(priority: decimal)`: \- Returns a configurable priority (e.g., `1.0`) without account
details if: - Rate limiting is disabled globally or bypassed for the account. - The account lacks rate limiter
configuration. - Useful for high-priority transactions that bypass rate limits.

- `priority_state_v1`: \- Struct containing the following fields: - `account_id`: Account ID pushing the transaction. -
`account_points`: Current points of the account. - `tx_cost_points`: Transaction cost in points; used to ensure the
account can cover the transaction cost. - `priority`: Decimal value, where a higher value indicates higher priority
within the queue.


### Example scenario: priority calculation [â€‹](\#example-scenario-priority-calculation "Direct link to Example scenario: priority calculation")

For an account with the following values:

- **Max points**: 100
- **Current points**: 50
- **Transaction cost points**: 20

The priority would be calculated as:

priority = current\_points / max\_points = 50 / 100 = 0.5

Key Components and Definitions `priority_state_v1` Struct: Contains account ID, account points, transaction cost points,
and priority value. `priority_check_v1` Query: Standard query used to fetch the priority of each transaction, calling
priority\_check for its calculation. `no_op_priority_state` and `no_account_priority_state` Functions: Define default
priority states for cases without specific account or priority information.

- [Core concepts](#core-concepts)
- [Priority function details](#priority-function-details)
  - [Purpose](#purpose)
  - [Parameters](#parameters)
  - [Priority calculation steps](#priority-calculation-steps)
  - [Return types and states](#return-types-and-states)
  - [Example scenario: priority calculation](#example-scenario-priority-calculation)[Skip to main content](#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

The Chromia platform is organized into clusters, each consisting of multiple [nodes](/intro/architecture/node).
Nodes are individual computers or servers responsible for processing transactions, validating blocks, and maintaining
the blockchain ledger. [Providers](/intro/providers) manage the nodes and contribute computing power to
Chromia.

Chromia employs an adapted version of the PBFT protocol known as eBFT to achieve
[consensus](/intro/architecture/node) in the network. This protocol involves multiple nodes validating transactions
and blocks, ensuring the network's security and reliability.

Let's look at the high-level architecture of Chromia:

![chromia architecture](/img/chromia_architecture_light.svg)

Chromia strategically groups nodes into clusters to divide areas of responsibility and streamline operations. Each
cluster focuses on running specific blockchains. There are two cluster types:

- **System Cluster** \- An integral part of Chromia that orchestrates the whole ecosystem.
The system cluster consists of nodes that run Chromia's core system services.
- **Dapp Cluster** \- Represents an environment where nodes run decentralized applications (dapps).
Every dapp in the cluster has its own blockchain and computational resources leased by the network.
Each dapp cluster runs its own Cluster Anchoring Chain, which stores hashed block headers.
This allows verifying the state of all underlying blockchains that each dapp operates.

## Blockchain anchoring [â€‹](\#blockchain-anchoring "Direct link to Blockchain anchoring")

Chromia employs an effective mechanism called Blockchain Anchoring to secure the System Cluster, Dapp Clusters, and
dapps. and the dapps. This means a blockchain can increase security by storing its hashed block headers on another
blockchain. The other blockchain becomes a strong point of reference, which can be used to resolve a consensus failure.
This mechanism works hierarchically. Here is how it functions:

1. Each Cluster Anchoring Chain waits for block headers from the clusterâ€™s dapp blockchains. Once received,
it hashes the block headers and creates blocks.
2. The System Anchoring Chain follows an identical process: It waits for block headers from the Cluster Anchoring Chains, hashes
the received block headers, and creates blocks.

In the event of a consensus failure, the System Anchoring Chain can validate the state of all clusters by referring to
the hashed block headers. The System Anchoring Chain is further anchored to Ethereum for additional security.

System cluster

Dapp cluster N...

Dapp cluster 2

Dapp cluster 1

System anchoring chain

Dapp chain 1

Dapp chain 2

Dapp chain N...

Cluster anchoring chain

Dapp chain 1

Dapp chain 2

Dapp chain N...

Cluster anchoring chain

Dapp chain 1

Dapp chain 2

Dapp chain N...

Cluster anchoring chain

External blockchain (Ethereum)

Chromia's anchoring hierarchy

## Dapp cluster [â€‹](\#dapp-cluster "Direct link to Dapp cluster")

A dapp cluster is an environment where nodes host decentralized applications (dapps). Each hosted dapp has dedicated
vCPU, memory, and storage resources, allowing for high and predictable performance while avoiding network congestion
scenarios.

Each dapp has its own blockchain where the data associated with the dappâ€™s operations is stored. Nodes in the cluster
are responsible for validating transactions and routing these validated transactions to the appropriate dappâ€™s
blockchain.

After the deployment, the dapp gets replicated across all nodes in a cluster.

This approach makes the dapp truly decentralized and resilient.

### Directory Chain Replica [â€‹](\#directory-chain-replica "Direct link to Directory Chain Replica")

Directory Chain Replica represents a full copy of [Directory Chain](#directory-chain) running in the System cluster. It
stores configuration details and Rell code for all dapps, as well as hierarchical information about the Dapp Clusters,
nodes, dapps, and dapps' blockchains. Each Dapp Cluster has a separate Directory Chain Replica that reads the
information from the original Directory Chain.

Dapp nodes heavily rely on the data that they source from this blockchain replica to determine what dapps they must run
within the Dapp Cluster. The main idea of having a separate replica within the Dapp Cluster is to ensure that, in any
negative circumstance, the dapp nodes will have a reference point to ensure all dapps within the cluster remain
operational.

### Cluster Anchoring Chain [â€‹](\#cluster-anchoring-chain "Direct link to Cluster Anchoring Chain")

A dapp cluster relies on its cluster anchoring chain to manage data integrity across all dapp blockchains. For each new
block created on the dapp blockchains, the corresponding block headers are sent to the Cluster Anchoring Chain, hashed,
and then used to create blocks that play a major role in the state verification of all underlying blockchains.

Once the Cluster Anchoring Chain creates a new block, its block header gets transferred to the System Anchoring Chain,
and the process repeats for all the other dapp clusters. Then, the System Anchoring Chain hashes the retrieved block
headers and creates blocks.

## System cluster [â€‹](\#system-cluster "Direct link to System cluster")

The System cluster serves as the central hub of the Chromia network. It runs five system chains: the Directory Chain,
the Economy Chain, the System Anchoring Chain, the Transaction Submitter Chain, and the EVM Event Receiver Chain.

Each blockchain is responsible for specialized functions, such as network resource management, billing for hosting
operations, network security, sending block headers to the Ethereum blockchain for anchoring, and managing CHR account
balances for cross-chain Ethereum transfers.

Additionally, the System cluster hosts Cluster Anchoring Chain Replicas that source and store data from the Dapp
Clusters. For each [Cluster Anchoring Chain](#cluster-anchoring-chain) Replica hosted in the System cluster, there is a
corresponding unique Cluster Anchoring Chain in the Dapp cluster. These replicas are used by the System cluster to
verify the state of the network and keep the whole ecosystem secure.

### Dapp Cluster Anchoring Chain Replica [â€‹](\#dapp-cluster-anchoring-chain-replica "Direct link to Dapp Cluster Anchoring Chain Replica")

Each Dapp Cluster has a [Cluster Anchoring Chain](#cluster-anchoring-chain) that sources block headers from all dapp
blockchains within the cluster to build blocks and keep all dapps secure. In this context, the Cluster Anchoring Chain
Replica is simply a copy of the Cluster Anchoring Chain, hosted in the System cluster. It functions as the source of
block headers for the System Anchoring Chain, which uses them to verify the state of the entire ecosystem and include
them in newly created blocks for anchoring purposes.

### System Anchoring Chain [â€‹](\#system-anchoring-chain "Direct link to System Anchoring Chain")

The System Anchoring Chain is a central repository for all validated data collected across all dapp Clusters. Its
primary responsibility is to ensure the security and integrity of all data on the network by collecting block headers
from all Cluster Anchoring Chains and using them to create blocks.

### Cluster Anchoring Chain [â€‹](\#cluster-anchoring-chain-1 "Direct link to Cluster Anchoring Chain")

Cluster Anchoring Chain sources block headers from all blockchains running in the System Cluster and produces blocks.
Then the System Anchoring Chain queries the headers of those blocks and produces a new set of anchoring blocks. The
ecosystem requires this anchoring process to keep the network tamperproof.

### Transaction Submitter Chain [â€‹](\#transaction-submitter-chain "Direct link to Transaction Submitter Chain")

The Transaction Submitter is an independent blockchain operating within the System Cluster that reads block headers from
the System Anchoring Chain to produce blocks. It is responsible for securing the entire Chromia ecosystem by anchoring
the state of the network to the Ethereum blockchain. Transaction Submitter Chain periodically submits transactions to
the Ethereum blockchain for anchoring purposes.

### Economy chain [â€‹](\#economy-chain "Direct link to Economy chain")

The Economy Chain manages hosting prices, provider rewards, and dapp payments through leases and incentivizes node
providers. When a developer leases computational resources from the network, the Economy Chain sends the corresponding
information to the Directory Chain using the [ICMF](/intro/cross-chain/icmf) protocol to allocate a specific number
of resources in a dapp cluster for dapp deployment.

### EVM Event Receiver Chain [â€‹](\#evm-event-receiver-chain "Direct link to EVM Event Receiver Chain")

The Economy Chain retrieves data from the EVM Event Receiver Chain using the [ICMF](/intro/cross-chain/icmf). When
a user deposits CHR tokens into the Ethereum CHR contract, the EVM Event Receiver Chain reads the updated state of the
smart contract and informs the Economy Chain of the new deposit. After the deposit is confirmed and the Economy Chain
has been notified, it must allocate the corresponding number of CHR tokens to the specific account on the Chromia
network.

### Directory chain [â€‹](\#directory-chain "Direct link to Directory chain")

The directory chain stores hierarchical information about the dapp clusters, nodes, dapps, and dappsâ€™ blockchains, as
well as configurations for dapps and blockchains. The directory Chain creates data records, associating each node with
the corresponding cluster and each dapp with the corresponding nodes.

The Directory Chain stores the code and configurations of dapps. In the event of an issue affecting a cluster or dapp,
its configuration and code can be promptly restored. Additionally, it facilitates state validation by providing
transaction history and a history of the deployed code at any given block height.

The Directory Chain communicates with the Economy Chain through the [ICMF](/intro/cross-chain/icmf) protocol to
allocate the corresponding number of resources that a developer has leased to deploy a dapp in the selected cluster.

## Scalability of the network [â€‹](\#scalability-of-the-network "Direct link to Scalability of the network")

Chromia's unique architecture allows the network to scale horizontally. As demand for the network increases, Providers
(Chromia's validators) add more nodes and more dapp clusters, thus allowing more dapps to deploy and run. With each dapp
receiving its dedicated compute, memory, and storage resources, a traffic spike on one dapp doesn't cause congestion or
performance degradation for the rest of the dapps on the network. Dapps themselves can scale by leasing more resources
on the network or even sharding into multiple blockchains that communicate with each other.

## Cross-chain communication [â€‹](\#cross-chain-communication "Direct link to Cross-chain communication")

Blockchains within the Chromia network can send events and data between them using Chromia's
[Interchain Messaging Facility (ICMF)](/intro/cross-chain/icmf) and
[Interchain Confirmation Facility (ICCF)](/intro/cross-chain/iccf) protocols, both within clusters and between
different clusters. Some dapp clusters also have access to Chromia's extensive EVM interoperability framework, allowing
dapps to bridge tokens, events, and other forms of data to and from Ethereum and other EVM chains.

## Next up [â€‹](\#next-up "Direct link to Next up")

Next, we'll look at the Chromia cross-chain capabilities and explore its inner workings, including the EIF Rell module
and the unique pegged bridge system.

- [Blockchain anchoring](#blockchain-anchoring)
- [Dapp cluster](#dapp-cluster)
  - [Directory Chain Replica](#directory-chain-replica)
  - [Cluster Anchoring Chain](#cluster-anchoring-chain)
- [System cluster](#system-cluster)
  - [Dapp Cluster Anchoring Chain Replica](#dapp-cluster-anchoring-chain-replica)
  - [System Anchoring Chain](#system-anchoring-chain)
  - [Cluster Anchoring Chain](#cluster-anchoring-chain-1)
  - [Transaction Submitter Chain](#transaction-submitter-chain)
  - [Economy chain](#economy-chain)
  - [EVM Event Receiver Chain](#evm-event-receiver-chain)
  - [Directory chain](#directory-chain)
- [Scalability of the network](#scalability-of-the-network)
- [Cross-chain communication](#cross-chain-communication)
- [Next up](#next-up)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

A decentralized application, or dapp, is software comprised of various components that collectively serve a valuable
purpose for its users. A portion of its functionality is decentralized, and you can use it without relying on a single
company to control it.

On Chromia, these dapps have two main parts:

- **The user-facing side:** This is what you see and interact with, like the buttons and screens. It's like the
storefront of your dapp.
- **The decentralized backend:** This is the core that runs on a special database called a blockchain. It is where the
real magic happens, ensuring security and transparency.

To [build](/intro/create-dapp/run-dapp-cli) this backend, Chromia has its own language called Rell. Think of Rell
as a set of tools designed to build dapp backends on Chromia.

The structure of a decentralized app built in Rell resembles the following:

![rell structure](/img/Rell_structure_LM_C.svg)

In Rell, developers handle requests through two types of actions:

1. **Data-modifying requests (Operations)**: These operations modify the database state.
2. **Data-retrieving requests (Queries)**: These are requests for retrieving data.

Relational operators play a crucial role when dealing with both requests, allowing developers to leverage the power of
relational programming idioms.

info

To learn Rell from the ground up, consider taking the
[Rell Masterclass](https://learn.chromia.com/courses/rell-masterclass/introduction).

Once you've developed your dapp, you can quickly deploy and update it to Chromia's public testnet or mainnet. The
[deployment](/intro/deployment/testnet/deploy-dapp) process is straightforward and well-documented, allowing you to
bring your decentralized application to life on Chromia's blockchain network.

But how does the user interface connect to this backend? Chromia provides a postchain-client that enables you to connect
the frontend of your dapp to the decentralized backend running on Chromia's blockchain network. This client library
allows you to send transactions and retrieve information from a blockchain node running Rell.

You can choose from the following client libraries to interact with their dapps:

| Library | Description |
| --- | --- |
| [JavaScript/TypeScript](/intro/installation/postchain-clients#javascript-jstypescriptts) | The JavaScript/TypeScript client library, known as postchain-client, provides functionality for interacting with a blockchain using JavaScript or TypeScript. |
| [Kotlin](/intro/installation/postchain-clients#kotlin) | The Kotlin client library, postchain-client, can interact with a blockchain from a client app written in Kotlin or Java. |
| [C#](/intro/installation/postchain-clients#c) | The client library, known as postchain-client, provides functionality for interacting with a blockchain using C#. |

## Next up [â€‹](\#next-up "Direct link to Next up")

Next, we'll look at dapp hosting fees in more detail and examine the origins of the tokens used to reward Providers.
Hosting fees and provider rewards form the backbone of Chromia's tokenomics model.

- [Next up](#next-up)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Asset registration is a crucial process within the FT4 library. It involves defining and initializing new assets (such
as tokens) that will be used within the system, ensuring that each asset has a unique identity, associated metadata, and
is properly tracked across different accounts.

There are two primary ways to register assets in FT4: using the built-in admin operation or by writing a custom
operation. Both methods achieve the same goal but allow for different levels of customization and control over the
registration process.

Asset registration ensures that each token is recognized and managed according to a set of predefined rules. It serves
several purposes:

1. **Asset initialization**: Registration initializes an asset on the blockchain by defining its properties (name,
symbol, decimals, etc.). Without this, the blockchain has no way of identifying or interacting with the asset.

2. **Standardization**: Registration ensures that all assets follow a standardized format, making it easier for wallets,
dApps, and other services to recognize and interact with them. The assetâ€™s properties (such as its decimal precision
and symbol) are necessary for accurate tracking and transactions.

3. **Security and control**: Registering an asset provides security by ensuring that the assetâ€™s identity is unique and
tied to the correct issuing entity. This prevents conflicts, duplicate assets, or fraud within the system.

4. **Supply tracking**: Registration initializes the assetâ€™s supply (even if the initial supply is zero) and allows the
system to track future issuance or transfers of the asset.

5. **Integration with accounts**: Once registered, the asset can be held in accounts, transferred between users, or used
in decentralized applications (dApps). Without registration, the system cannot recognize the asset or manage account
balances.


## Register assets with FT4 admin operation [â€‹](\#register-assets-with-ft4-admin-operation "Direct link to Register assets with FT4 admin operation")

FT4 provides an admin operation to easily register assets on the Chromia blockchain. This is a streamlined process that
allows administrators to define and add new assets without needing to write custom code. However, the `Admin module`
should not be used in production since it's a security liability.

### Steps for asset registration: [â€‹](\#steps-for-asset-registration "Direct link to Steps for asset registration:")

1. **Import the admin module**: Ensure the admin module is imported into your project. If you followed the
[setup](/project-setup) guide, this step should already be completed.

2. **Execute the registration command**: Register an asset using the following command:





```codeBlockLines_e6Vv
chr tx ft4.admin.register_asset TestAsset TST 6 https://url-to-asset-icon --secret .chromia/ft4-admin.keypair --await

```









In this example:
   - `TestAsset` is the name of the asset.
   - `TST` is the asset's ticker symbol.
   - `6` specifies the number of decimal places for the asset.
   - `https://url-to-asset-icon` is a URL linking to the asset's icon.
   - `.chromia/ft4-admin.keypair` is the key pair used to sign the registration.
3. **Verify asset registration**: After registration, use this command to verify if the asset was successfully
registered:





```codeBlockLines_e6Vv
chr query ft4.get_all_assets page_size=10 page_cursor=null

```

4. **View the output**: If the registration is successful, the asset details will be displayed:





```codeBlockLines_e6Vv
[\
"data": [\
    [\
      "blockchain_rid": x"CCEF62BF92CED034DD41D8230D30D2818FE6C3C96BD12E55B0BEC4D02B25E5A6",\
      "decimals": 6,\
      "icon_url": "https://url-to-asset-icon",\
      "id": x"AB423B9C0A207B9E712FB245A738B1E29C49C5C4CB77F9E0CBA4E003F95C6CAF",\
      "name": "TestAsset",\
      "supply": 0L,\
      "symbol": "TST",\
      "type": "ft4"\
    ]\
],\
"next_cursor": null\
]

```









:::

note The `blockchain_rid` and `id` values will differ in your case.

:::


warning

Admin operations are enabled by importing the admin module and should not be used in production.

## Register an asset with a custom operation [â€‹](\#register-an-asset-with-a-custom-operation "Direct link to Register an asset with a custom operation")

For more complex scenarios, such as registering multiple assets at once or performing additional logic during
registration, a custom operation can be written. This method gives developers more flexibility to handle asset creation
and other initialization tasks in a single transaction.

Here is an example of a custom operation without importing the admin module:

### Custom asset registration code: [â€‹](\#custom-asset-registration-code "Direct link to Custom asset registration code:")

1. **Add custom code**: Insert the following code into the `main.rell` file. This code checks if the asset already
exists before registering it.





```codeBlockLines_e6Vv
var is_registered = false;

...

operation init() {
       is_registered=true;
       register_asset_if_needed("TestAsset2", "TST2", 10, "https://url-to-asset-2-icon");
       register_asset_if_needed("TestAsset3", "TST3", 18, "https://url-to-asset-3-icon");
}

function register_asset_if_needed(asset_name: name, symbol: text, decimals: integer, icon_url: text) {
      // Derive id of the asset
      val asset_id = (asset_name, chain_context.blockchain_rid).hash();

      // Check if the asset already exists
      val asset = assets.asset @ ? { .id == asset_id };
      if (not empty(asset)) return;

      assets.Unsafe.register_asset(asset_name, symbol, decimals, chain_context.blockchain_rid, icon_url);
}

```

2. **Deploy the code**: Use the following command to deploy the updated code:





```codeBlockLines_e6Vv
chr node update

```

3. **Activate the configuration**: The output will mention the block height when the new configuration becomes active.
For example:





```codeBlockLines_e6Vv
Configuration added at height 50

```

4. **Execute the custom operation**: Once the configuration is active, execute the `init` operation to register the
assets:





```codeBlockLines_e6Vv
chr tx init --secret .chromia/ft4-admin.keypair --await

```

5. **Verify the registration**: Check if the assets were successfully registered:





```codeBlockLines_e6Vv
chr query ft4.get_all_assets page_size=10 page_cursor=null

```









The output will include the newly registered assets:





```codeBlockLines_e6Vv
[\
"data": [\
    [\
      "blockchain_rid": x"CCEF62BF92CED034DD41D8230D30D2818FE6C3C96BD12E55B0BEC4D02B25E5A6",\
      "decimals": 6,\
      "icon_url": "https://url-to-asset-icon",\
      "id": x"AB423B9C0A207B9E712FB245A738B1E29C49C5C4CB77F9E0CBA4E003F95C6CAF",\
      "name": "TestAsset",\
      "supply": 0L,\
      "symbol": "TST",\
      "type": "ft4"\
    ],\
    [\
      "blockchain_rid": x"CCEF62BF92CED034DD41D8230D30D2818FE6C3C96BD12E55B0BEC4D02B25E5A6",\
      "decimals": 10,\
      "icon_url": "https://url-to-asset-2-icon",\
      "id": x"5D99EDF63EF87ADD04966558E575712C9984F0DDDFB7039073BDD83227C4584D",\
      "name": "TestAsset2",\
      "supply": 0L,\
      "symbol": "TST2",\
      "type": "ft4"\
    ],\
    [\
      "blockchain_rid": x"CCEF62BF92CED034DD41D8230D30D2818FE6C3C96BD12E55B0BEC4D02B25E5A6",\
      "decimals": 18,\
      "icon_url": "https://url-to-asset-3-icon",\
      "id": x"03AEE687F19E8BE6899E3898D407C65838B85FAB1AF479E330A41EFC98404948",\
      "name": "TestAsset3",\
      "supply": 0L,\
      "symbol": "TST3",\
      "type": "ft4"\
    ]\
],\
"next_cursor": null\
]

```


After successfully registering assets, the next step is to handle \[account registration\](../Accounts/Account
Registration/register-accounts). This process allows users to create new accounts and link them to their assets,
enabling them to interact with the assets within the Chromia network. Admins can perform these registrations through
special operations, and custom operations can be created for more complex use cases.

- [Register assets with FT4 admin operation](#register-assets-with-ft4-admin-operation)
  - [Steps for asset registration:](#steps-for-asset-registration)
- [Register an asset with a custom operation](#register-an-asset-with-a-custom-operation)
  - [Custom asset registration code:](#custom-asset-registration-code)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Transferring assets is a fundamental operation in decentralized applications built on the FT4 framework. FT4 provides a
secure and efficient way to transfer assets between accounts, ensuring proper authentication and authorization. This
section will guide you through the process of transferring assets using both the Chromia CLI and the Postchain client
library.

## Prerequisites [â€‹](\#prerequisites "Direct link to Prerequisites")

Before you can transfer assets, you need to have the following:

1. **Registered assets**: You must have registered one or more assets on the blockchain. If you haven't done so already,
follow the instructions in the [Register assets](/ft4/backend/assets/register-assets) section.

2. **Registered accounts**: You need at least two registered accounts on the blockchain: a sender account and a
recipient account. Refer to the [Register accounts](/ft4/backend/accounts/account-registration/register-accounts)
section for instructions on account registration.

3. **Minted tokens**: Ensure that the sender account has a balance of the asset you wish to transfer. You can mint
tokens to an account using the `ft4.admin.mint` operation.



tip





To mint tokens to the sender account:







```codeBlockLines_e6Vv
chr tx ft4.admin.mint \
     SENDER_ACCOUNT_ID \
     ASSET_ID \
     AMOUNT_WITH_DECIMALS \
     --await --secret .chromia/ft4-admin.keypair

```











Replace `SENDER_ACCOUNT_ID` with the ID of the account you want to mint tokens to, `ASSET_ID` with the ID of the
asset you're minting, and `AMOUNT_WITH_DECIMALS` with the amount of tokens to mint (including decimal places).


## Transfer assets using the Chromia CLI [â€‹](\#transfer-assets-using-the-chromia-cli "Direct link to Transfer assets using the Chromia CLI")

The Chromia CLI provides a convenient way to perform asset transfers from the command line. Here's an example of how to
transfer tokens using the CLI:

1. Verify the account balance:





```codeBlockLines_e6Vv
chr query ft4.get_asset_balance \
     'account_id=SENDER_ACCOUNT_ID' \
     'asset_id=ASSET_ID'

```

2. Transfer tokens to the recipient account:





```codeBlockLines_e6Vv
chr tx ft4.transfer \
     RECIPIENT_ACCOUNT_ID \
     ASSET_ID \
     AMOUNT_TO_TRANSFER \
     --ft-auth --await --secret .chromia/SENDER_ACCOUNT_KEYPAIR

```









Replace `RECIPIENT_ACCOUNT_ID` with the ID of the account you want to transfer tokens to, `ASSET_ID` with the ID of
the asset you're transferring, and `AMOUNT_TO_TRANSFER` with the amount of tokens to transfer (including decimal
places). Additionally, replace `.chromia/SENDER_ACCOUNT_KEYPAIR` with the path to the sender account's keypair file.

The `--ft-auth` flag enables FT4 authentication, allowing you to sign the transaction with the sender account's
keypair.


note

Currently, the CLI only supports `--ft4-auth`. Support for the equivalent of `--evm-auth` might be added in the future,
but for now, the only way to achieve EVM authentication is by using the client lib.

## Transfer assets using the Postchain client library [â€‹](\#transfer-assets-using-the-postchain-client-library "Direct link to Transfer assets using the Postchain client library")

Alternatively, you can use the Postchain client library to perform asset transfers programmatically. Here's an example
of how to transfer assets using the client library:

```codeBlockLines_e6Vv
const {
  createAmount,
  createInMemoryFtKeyStore,
  createKeyStoreInteractor,
  createConnection,
  gtv,
} = require("@chromia/ft4");
const { createClient, encryption } = require("postchain-client");

// Connect to the blockchain node
const url = "http://localhost:7740";
const client = await createClient({
  nodeUrlPool: url,
  blockchainIid: 0,
});

// Define the sender's keypair (replace with your own keypair)
const senderKeyPair = encryption.makeKeyPair("YOUR_SENDER_PRIVATE_KEY");

// Get the sender's account ID
const senderId = "SENDER_ACCOUNT_ID";

// Get the recipient's account ID
const recipientId = "RECIPIENT_ACCOUNT_ID";

// Get the asset ID
const assetId = "ASSET_ID";

// Define the amount to transfer (including decimal places)
const amountToSend = createAmount(10, 6); // Transfers 10 tokens with 6 decimal places

// Create a session for the sender account
const { getSession } = createKeyStoreInteractor(client, createInMemoryFtKeyStore(senderKeyPair));
const session = await getSession(senderId);

// Transfer the assets
await session.account.transfer(recipientId, assetId, amountToSend);

// Check the sender's balance after the transfer
console.log(await session.account.getBalanceByAssetId(assetId));

```

Replace `YOUR_SENDER_PRIVATE_KEY`, `SENDER_ACCOUNT_ID`, `RECIPIENT_ACCOUNT_ID`, and `ASSET_ID` with the appropriate
values for your use case.

This example demonstrates the following steps: register-assets

1. Connect to the blockchain node using the Postchain client library.
2. Define the sender's keypair and retrieve the sender's account ID, recipient's account ID, and asset ID.
3. Create a session for the sender account using the `createKeyStoreInteractor` and `createInMemoryFtKeyStore`
functions.
4. Transfer the assets using the `session.account.transfer` method, specifying the recipient account ID, asset ID, and
the amount to transfer.
5. Check the sender's balance after the transfer using the `session.account.getBalanceByAssetId` method.

By following these steps, you can securely transfer assets between accounts using either the
[Chromia CLI](#transfer-assets-using-the-chromia-cli) or the
[Postchain client library](#transfer-assets-using-the-postchain-client-library), depending on your specific
requirements.

- [Prerequisites](#prerequisites)
- [Transfer assets using the Chromia CLI](#transfer-assets-using-the-chromia-cli)
- [Transfer assets using the Postchain client library](#transfer-assets-using-the-postchain-client-library)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In the FT4 client library, the `KeyStore` interface represents a general abstraction for managing cryptographic keys.
This abstraction is crucial for implementing security and transaction signing mechanisms. Two key implementations extend
this interface:

1. **`EvmKeyStore`**: Designed for Ethereum-compatible keys.
2. **`FtKeyStore`**: Designed for FT4-specific keys.

Both implementations provide methods to sign messages or transactions and to integrate with authentication handlers.

### **`KeyStore` interface** [â€‹](\#keystore-interface "Direct link to keystore-interface")

The `KeyStore` interface defines the foundational structure and behavior for cryptographic key management:

- **Properties:**
  - `id: Buffer`: A unique identifier for the key.
  - `isInteractive: boolean`: Indicates if signing requires user interaction.
- **Methods:**
  - `createKeyHandler(authDescriptor: AnyAuthDescriptor): KeyHandler`: Creates a handler that interacts with the key for
    authorization purposes.

### **`EvmKeyStore` implementation** [â€‹](\#evmkeystore-implementation "Direct link to evmkeystore-implementation")

#### **Description** [â€‹](\#description "Direct link to description")

The `EvmKeyStore` extends `KeyStore` and implements the `EvmSigner` interface. It is designed for managing
Ethereum-compatible (EVM) keys and includes functionality to sign Ethereum messages and handle EVM-specific operations.

#### **Properties and methods** [â€‹](\#properties-and-methods "Direct link to properties-and-methods")

- **Properties:**
  - `address: Buffer`: The Ethereum address associated with the key (without the leading `0x`).
- **Methods:**
  - `signMessage(message: string): Promise<Signature>`: Signs a given message using the EVM key.
  - `createKeyHandler(authDescriptor: AnyAuthDescriptor): KeyHandler`: Implements key handler creation.

#### **Instantiation options** [â€‹](\#instantiation-options "Direct link to instantiation-options")

1. **In-memory `EvmKeyStore`**
   - Created with ephemeral keys stored in memory.
   - **Method:** `createInMemoryEvmKeyStore(keyPair: KeyPair): EvmKeyStore`
   - **Example:**




     ```codeBlockLines_e6Vv
     const keyPair = { privKey: Buffer.from("private_key_hex", "hex") };
     const evmKeyStore = createInMemoryEvmKeyStore(keyPair);

     ```
2. **Generic `EvmKeyStore`**
   - Allows customization with a provided signing function and configuration.

   - **Method:** `createGenericEvmKeyStore(config: { address: string, signMessage: Function, isInteractive?: boolean }): Promise<EvmKeyStore>`

   - **Example:**





     ```codeBlockLines_e6Vv
     const evmKeyStore = await createGenericEvmKeyStore({
       address: "YourEthereumAddress",
       signMessage: async (message) => "signature_string",
       isInteractive: false,
     });

     ```
3. **Web3 provider `EvmKeyStore`**
   - Integrates with external Web3 providers (e.g., MetaMask).

   - **Method:** `createWeb3ProviderEvmKeyStore(externalProvider: Eip1193Provider): Promise<EvmKeyStore>`

   - **Example:**





     ```codeBlockLines_e6Vv
     const evmKeyStore = await createWeb3ProviderEvmKeyStore(window.ethereum);

     ```

### **`FtKeyStore` implementation** [â€‹](\#ftkeystore-implementation "Direct link to ftkeystore-implementation")

The `FtKeyStore` extends `KeyStore` and implements the `FtSigner` interface. It manages FT4-specific keys and supports
signing FT4 transactions.

#### **Properties and methods** [â€‹](\#properties-and-methods-1 "Direct link to properties-and-methods-1")

- **Properties:**
  - `pubKey: Buffer`: The public key associated with the FT4 key.
- **Methods:**
  - `sign(transaction: GTX | RawGtx): Promise<Buffer>`: Signs an FT4 transaction.
  - `createKeyHandler(authDescriptor: AnyAuthDescriptor): KeyHandler`: Implements key handler creation.

#### **Instantiation options** [â€‹](\#instantiation-options-1 "Direct link to instantiation-options-1")

1. **In-memory `FtKeyStore`**
   - Created with ephemeral keys stored in memory.
   - **Method:** `createInMemoryFtKeyStore(keyHolder: KeyPair | SignatureProvider): FtKeyStore`
   - **Example:**




     ```codeBlockLines_e6Vv
     const keyPair = { privKey: Buffer.from("private_key_hex", "hex") };
     const ftKeyStore = createInMemoryFtKeyStore(keyPair);

     ```

### **Storage options** [â€‹](\#storage-options "Direct link to storage-options")

The FT4 client supports storing keys in:

1. **Memory:** Keys are stored temporarily and cleared upon application restart.
2. **Session storage:** Keys persist only for the duration of the browser session.
3. **Local storage:** Keys persist across browser sessions and application restarts (custom implementations may be
needed).

Even though there are implementations ready for the generic KeyStore, individual implementations for custom stores need
to be implemented.

#### **Using in-memory storage** [â€‹](\#using-in-memory-storage "Direct link to using-in-memory-storage")

In-memory storage is the default for ephemeral keys, especially for testing.

#### **Custom storage implementation** [â€‹](\#custom-storage-implementation "Direct link to custom-storage-implementation")

For session or local storage, wrap the `KeyStore` creation logic to persist the keys using browser APIs or custom
storage strategies.

### **Key differences** [â€‹](\#key-differences "Direct link to key-differences")

| Feature | `EvmKeyStore` | `FtKeyStore` |
| --- | --- | --- |
| **Purpose** | Ethereum-compatible signing | FT4-specific signing |
| **Identifier** | `address` | `pubKey` |
| **Signing Method** | `signMessage` | `sign` |
| **Storage Options** | Memory, Session, Browser | Memory |

### **Example usage** [â€‹](\#example-usage "Direct link to example-usage")

#### `EvmKeyStore` with Web3 provider [â€‹](\#evmkeystore-with-web3-provider "Direct link to evmkeystore-with-web3-provider")

```codeBlockLines_e6Vv
const evmKeyStore = await createWeb3ProviderEvmKeyStore(window.ethereum);
const signature = await evmKeyStore.signMessage("Hello, Ethereum!");

```

#### `FtKeyStore` with in-memory keys [â€‹](\#ftkeystore-with-in-memory-keys "Direct link to ftkeystore-with-in-memory-keys")

```codeBlockLines_e6Vv
const keyPair = { privKey: Buffer.from("private_key_hex", "hex") };
const ftKeyStore = createInMemoryFtKeyStore(keyPair);
const signedTx = await ftKeyStore.sign(someTransaction);

```

- [**`KeyStore` interface**](#keystore-interface)
- [**`EvmKeyStore` implementation**](#evmkeystore-implementation)
- [**`FtKeyStore` implementation**](#ftkeystore-implementation)
- [**Storage options**](#storage-options)
- [**Key differences**](#key-differences)
- [**Example usage**](#example-usage)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

To improve the user experience in web applications, FT4 provides a mechanism for generating disposable keys and adding
them to a user's account. This allows non-interactive signing of operations using the directly accessible new key,
eliminating the need for the user to sign each operation with MetaMask.

However, it's crucial to exercise caution when adding auth flags to disposable keys, as compromised keys with sensitive
flags could lead to asset compromisation or other security risks.

FT4 offers a `login` function that simplifies the process of generating and managing disposable keys.

### Logging in [â€‹](\#logging-in "Direct link to Logging in")

The following example demonstrates adding a disposable key to an account using the `login` function and calling the
`foo` and `bar` operations. Only one message signing is required to add a new auth descriptor, while the `foo` and `bar`
operations are called without signing.

More information about messages and authentication can be found [here](/ft4/backend/auth-descriptors/authentication).

```codeBlockLines_e6Vv
createWeb3ProviderEvmKeyStore(window.ethereum).then(async (store: EvmKeyStore) => {
  const { getAccounts, login } = createKeyStoreInteractor(client, store);

  const accounts = await getAccounts();

  if (!accounts.length) return;

  const { session, logout } = await login({
    accountId: accounts[0].id,
  });

  await session.call(op("foo"), op("bar", "some other text", 123456));

  // more calls here ...

  await logout();
});

```

![](/assets/ideal-img/login_manager_auth_desc.da0e965.367.png)

However, the disposable auth descriptor will still require a signature if a transfer operation is called because it doesn't
have the "T" (transfer) flag.

![](/assets/ideal-img/transfer_sign.2e8a46d.350.png)

![](/assets/ideal-img/transfer_approve.087baf8.353.png)

To sign the transfer transaction using the disposable auth descriptor, modify the `login` function call and add the "T" flag
to the auth descriptor:

```codeBlockLines_e6Vv
const { session, logout } = await login({
  accountId: accounts[0].id,
  config: {
    flags: ["T"],
  },
});

```

The disposable auth descriptor will be used to sign the transfer transaction instead of the master auth descriptor.

If we want, we can also specify a keystore when logging in which then will hold the signing key that will be used with
the disposable auth descriptor. It is a good idea to always specify a keystore as it gives increased control over the
lifecycle of the disposable key. If no keystore is provided, the disposable key will only be stored in memory and will
thus be cleared when the browser window is reloaded. Forcing the user to login on each page reload can lead to bad UX.

Furthermore, using an in memory key store while developing could be problematic since each page reload will cause a new
disposable auth descriptor to be added. In a development scenario, where each code change might trigger a hot reload of
the page, one will quickly hit the upper limit of how many auth descriptors can be added, resulting in the inability of
logging in to the account until the login time to live is reached.

To use a more durable keystore, we can specify it when logging in:

```codeBlockLines_e6Vv
const { session } = await login({
  accountId: accounts[0].id,
  config: {
    flags: ["T"],
  },
  loginKeyStore: createSessionStorageLoginKeyStore(),
});

```

This will instead store the disposable key in the browsers session storage and consequently have the same lifecycle. Out
of the box, there is also a variant that will store the key in the browsers local storage. The `login` function accepts
any instance of the
[`LoginKeystore`](https://docs.chromia.com/pages/ft4-ts-client/client/interfaces/authentication.LoginKeyStore.html)
interface which means that it is possible to implement a custom login keystore, e.g., for cases when the dapp does not
run in a browser context.

One can also add rules to be applied to the new auth descriptor, such as for how long it should be valid:

```codeBlockLines_e6Vv
const { session } = await login({
  accountId: accounts[0].id,
  config: {
    flags: ["T"],
    rules: ttlLoginRule(minutes(30)),
  },
  loginKeyStore: createSessionStorageLoginKeyStore(),
});

```

If no login config is provided. The default config will be used. The default timeout is then **one day** and the flags
will be set to `[]`.

caution

Disposable keys aren't securely stored. Therefore, never add auth flags that could lead to asset compromise if the
disposable key pair is compromised.

### Logging out [â€‹](\#logging-out "Direct link to Logging out")

Logging out is a necessary step after login which removes the disposable key's access to the account, removing the risk
of misuse in case that key is leaked. To do so, you simply have to call the `logout` function:

```codeBlockLines_e6Vv
const { session, logout } = await login({
  accountId: accounts[0].id,
});

// use the disposable key...

await logout();

```

There are two main reasons to logout:

- the disposable key might be leaked and used to access the account by third parties, in a way that is comparable to
authentication token stealing in web2;
- every account has a limit to how many auth descriptor can be attached to it, and failing to remove old unused ones
brings the account closer to this limit. Reaching the maximum number of auth descriptors added to the account will
prevent the user from logging in again until some auth descriptors expire.

For these reasons, always remember to call the `logout` function to destroy disposable keys when they are no longer
needed.

If you want the better UX given by being able to login without user interaction, you can use a more durable login
keystore when logging in (like `createSessionStorageLoginKeyStore()`). This can also help reduce the risk of being
locked out from the account during development.

A more durable keystore will prevent the buildup of unusable auth descriptors on the account.

For more information on the maximum auth descriptor limit, check out the
[Authentication with FT4 accounts](/ft4/backend/auth-descriptors/authentication) topic.

- [Logging in](#logging-in)
- [Logging out](#logging-out)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In a fixed fee strategy, users pay a set fee for specific actions such as creating an account or making a transaction.

#### Key details: [â€‹](\#key-details "Direct link to Key details:")

- Users pay a fixed amount (similar to a one-time purchase) using a specific token to access the dapp's features.
- This approach provides a clear and easy-to-understand system, suitable for users who prefer straightforward access.
- Simplifies the dapp's financial management and encourages brand loyalty among satisfied users.

#### Benefits of fixed fees: [â€‹](\#benefits-of-fixed-fees "Direct link to Benefits of fixed fees:")

- **Clarity:** Users know exactly what theyâ€™re paying for, fostering trust and transparency.
- **Convenience:** Eliminates the need for recurring payments, making it user-friendly.
- **Brand Loyalty:** Encourages users to explore all features, potentially increasing engagement.

### Getting started [â€‹](\#getting-started "Direct link to Getting started")

A code example with tests is available [here](https://bitbucket.org/chromawallet/fee-samples/src/main/fee/).

To begin, here is an example configuration:

```codeBlockLines_e6Vv
lib.ft4.core.accounts.strategies.transfer:
  rules:
    - sender_blockchain: x"0000000000000000000000000000000000000000000000000000000000000000"
    sender: "*"
    recipient: "*"
    asset:
        - name: "MyTestAsset"
        min_amount: 100L
    timeout_days: 60
    strategy:
    - "fee"
lib.core.accounts.strategies.transfer.fee:
  asset:
    - name: "MyTestAsset" # issued by current blockchain
    amount: 40L

```

This configuration includes two main settings: `strategies.transfer` and `strategies.transfer.fee`. In the example
above:

1. **Transfer Strategy:** For any user to any recipient from any blockchain using the `MyTestAsset` asset with a minimum
amount of 100 coins, a fixed fee can be requested. The timeout is 60 days.
2. **Fee Strategy:** The fee is set at 40 `MyTestAsset` coins.

tip

A clear and straightforward fee structure is essential. Transparency ensures users know exactly what theyâ€™re paying for.

To test the configuration above, refer to the available
[tests](https://bitbucket.org/chromawallet/fee-samples/src/main/subscription/src/test/subscription_test.rell).

- [Getting started](#getting-started)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

This section discusses how to install and initialize the FT4 client.

#### Install the client [â€‹](\#install-the-client "Direct link to Install the client")

Use [npm](https://docs.npmjs.com/cli/v10/commands/npm-init) to install the
[FT4 client](https://www.npmjs.com/package/@chromia/ft4):

```codeBlockLines_e6Vv
npm install @chromia/ft4

```

#### Initialize the client [â€‹](\#initialize-the-client "Direct link to Initialize the client")

In your JavaScript code, initialize the FT4 client:

```codeBlockLines_e6Vv
const { createClient } = require("postchain-client");
const { createConnection } = require("@chromia/ft4");

const url = "http://localhost:7740";
const client = await createClient({
  nodeUrlPool: url,
  blockchainIid: 0,
});

const connection = createConnection(client);

```

In the code snippet above, we import the necessary modules from the `postchain-client` and `@chromia/ft4` packages.
Next, we define the `url` of the Postchain network we want to connect to (in this case,
" [http://localhost:7740](http://localhost:7740/)"). We then create an instance of the `IClient` using the specified URL
and the internal ID of the chain, which by default is `0` on a local network.

With the client initialized, you can now utilize its capabilities to interact with the Postchain network and perform
various operations, such as sending transactions and querying the blockchain.

We then pass the client to the `createConnection` method from FT4, allowing us to easily use all of the FT4 features.

#### Test the connection [â€‹](\#test-the-connection "Direct link to Test the connection")

To test the connection, add a function to call a method on the connection object:

```codeBlockLines_e6Vv
const { createClient } = require("postchain-client");
const { createConnection } = require("@chromia/ft4");

async function main() {
  const url = "http://localhost:7740";
  const client = await createClient({
    nodeUrlPool: url,
    blockchainIid: 0,
  });

  const connection = createConnection(client);
  console.log(await connection.getAllAssets()); // This line is new
}

main();

```

Run the above example with `node index.js`. This will print all the assets registered on the blockchain. If no assets
are registered, the response will look like this:

```codeBlockLines_e6Vv
{ data: [], nextCursor: null }

```[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Authentication in decentralized applications (dapps) verifies if a user has permission to perform specific actions.
While the process is straightforward with regular Rell applications, it becomes more complex with FT4 due to support for
native and EVM signatures and multiple keys for an FT4 account. However, the complexity is abstracted, and
authentication can be easily implemented using the `authenticate` operation.

## The `authenticate` function [â€‹](\#the-authenticate-function "Direct link to the-authenticate-function")

To authenticate a user within an operation, use the following code:

```codeBlockLines_e6Vv
operation foo() {
    val account = auth.authenticate();
}

```

Calling this operation from the client side without additional configuration will result in the following error:

`Cannot find auth handler for operation <foo>`

To enable FT4 authentication, define an auth handler for the operation using the `auth_handler` extension function. This
function allows specification of the authentication requirements for the operation, such as required auth flags or
custom authentication logic. For more information on extendable functions, refer to the
[extendable functions](/rell/language-features/modules/function#extendable-functions) topic.

```codeBlockLines_e6Vv
@extend(auth.auth_handler)
function () = auth.add_auth_handler(
  scope = rell.meta(foo).mount_name,
  flags = []
);

operation foo() {
    val account = auth.authenticate();
}

```

In this example, the `auth_handler` function is defined with an empty list of `flags`, indicating that no specific auth
flags are required to call the `foo` operation. The `scope` parameter specifies the scope of the auth handler, which in
this case is limited to the `foo` operation.

### Overridable auth handlers [â€‹](\#overridable-auth-handlers "Direct link to Overridable auth handlers")

When defining an auth handler for an operation, for example, if developing a library on top of FT4, it may be preferable
to allow developers to override that auth handler with their implementation to suit their use case better. For this, an
alternative function for registering an auth handler called `add_overridable_auth_handler` is provided. This function
works like `add_auth_handler` but allows a user to call `add_auth_handler` with the same scope as was registered with
the overridable auth handlerâ€”an action that would cause an error if `add_auth_handler` alone were used.

```codeBlockLines_e6Vv
@extend(auth.auth_handler)
function () = auth.add_overridable_auth_handler(
  scope = rell.meta(foo).mount_name,
  flags = []
);

@extend(auth.auth_handler)
function () = auth.add_auth_handler(
  scope = rell.meta(foo).mount_name,
  flags = ["T"]
);

```

If a user adds their version of an auth handler, it will authorize the operation. If not, the original version will be
used.

note

While `add_overridable_auth_handler` allows users to add another auth handler with the same name, it only works once.
For example, if overriding auth handlers for one of the built-in FT4 auth handlers, users cannot override that auth
handler again.

## Custom auth messages [â€‹](\#custom-auth-messages "Direct link to Custom auth messages")

If the transaction is being signed with an EVM key, there will be a generic message suited for better UX on clients like
Metamask. it is automatically generated from the operation name and argument values, e.g. for account registration it's
going to look like this:

```codeBlockLines_e6Vv
"Blockchain: %s\n\nPlease sign the message to register account\n\nAccount ID:\n%s\n\n"

```

To display friendlier messages, define a custom message formatter. The following example demonstrates how to create a
custom message formatter for the `bar` operation:

```codeBlockLines_e6Vv
function bar_message(gtv) {
    val args = struct<bar>.from_gtv(gtv);
    val arg1 = args.arg1;
    val arg2 = args.arg2;
    return "Please sign the message\nin order to call BAR operation\nwith arguments:\n\n- arg1: %s\n- arg2: %s".format(arg1, arg2);
}

@extend(auth.auth_handler)
function () = auth.add_auth_handler(
  scope = rell.meta(bar).mount_name,
  flags = [],
  message = bar_message(*)
);

operation bar(arg1: text, arg2: integer) {
    val account = auth.authenticate();
}

```

The custom message formatter `bar_message` expects a GTV-encoded list of operation arguments, which can be easily
decoded using `struct<op_name>.from_gtv(gtv)`. In this case, arguments for the `bar` operation are decoded using
`struct<bar>.from_gtv(gtv)`.

This custom message formatter now also displays argument names. The message is decorated to contain the blockchain rid
of the current blockchain and a nonce value to prevent replay attacks.

Additionally, placeholders `{account_id}` and `{auth_descriptor_id}` can be used in custom auth messages, which are
replaced by the account ID or auth\_descriptor\_id during signature verification.

```codeBlockLines_e6Vv
function bar_message(gtv) {
    val args = struct<bar>.from_gtv(gtv);
    val arg1 = args.arg1;
    val arg2 = args.arg2;
    return "Please sign the message\nin order to call BAR operation\nwith arguments:\n\n- arg1: %s\n- arg2: %s. This is your account id: {account_id} this is your auth descriptor id: {auth_descriptor_id}".format(arg1, arg2);
}

```

To apply the custom message formatter, specify it in the auth handler definition:

```codeBlockLines_e6Vv
@extend(auth.auth_handler)
function () = auth.add_auth_handler(
  scope = rell.meta(bar).mount_name,
  flags = [],
  message = bar_message(*)
);

```

### Account ID and signer types [â€‹](\#account-id-and-signer-types "Direct link to Account ID and signer types")

An **account ID** on the Chromia blockchain is derived as the hash of the signer(s) associated with the account. There
are two types of signers:

1. **FT signers (Postchain signers)**
2. **EVM signers**

### FT (Postchain) signers [â€‹](\#ft-postchain-signers "Direct link to FT (Postchain) signers")

FT signers use Chromia's native Postchain signatures. When an FT signer is used, it is added directly to the signers
field of the transaction. The transaction is then signed, and the signature of the entire transaction is added to the
`signatures` field before the transaction is submitted.

### EVM signers [â€‹](\#evm-signers "Direct link to EVM signers")

EVM signers operate through Ethereum-compatible wallets, such as MetaMask. Due to limited support for signing custom
data structures in these wallets, data structures used for signing are often not very readable for end users.

For example, instead of signing the entire transaction structure as shown below:

```codeBlockLines_e6Vv
transaction: {
  "blockchain_rid": {"type": "Buffer", "data": [0, 0, 123, 53, 119, ...]},
  "operations": {
    "name": "my_op",
    "arguments": [1, "abc", 87]
  },
  "signers": [\
    "11111111111",\
    "22222222222"\
  ]
}

```

The user will see a simpler message to sign, like:

```codeBlockLines_e6Vv
Do you want to call "my_op"?
It will create a token named ABC
with 1 decimal, and give you
8.7 ABC of balance.

Blockchain RID: 0034df12...
nonce: <something>

```

This message format ensures that EVM users can interact with transactions in a more understandable way.

### Signer Type Detection [â€‹](\#signer-type-detection "Direct link to Signer Type Detection")

To distinguish which type of signature the Rell language should expect, it checks if the signer is an **EVM address** or
a **public key**.

An account created with a public key will have a different ID than an account created with an EVM address, even if they
share the same public key.

### Account ID calculation [â€‹](\#account-id-calculation "Direct link to Account ID calculation")

- **FT signers**: The account ID is generated as `hash(pubkey)`.
- **EVM signers**: The account ID is generated as `hash(evm_address)`.

For EVM signers, the EVM address is derived from the public key by taking the first 40 characters of the hashed public
key. Specifically:

1. The EVM signer account ID is calculated as `hash(evm_address without "0x")`.
2. This corresponds to `hash(hash(pubkey).sub(0, 40))`, where the EVM address is the first 40 characters of the hashed
public key.

## Custom resolver [â€‹](\#custom-resolver "Direct link to Custom resolver")

In cases where authorization requirements are complex and static flags cannot determine if a user can act, a resolver
function is useful. For instance, in the FT4 library, the `ft4.delete_auth_descriptor` operation requires the `A` flag
unless the auth descriptor to be deleted is the same as the one authorizing the operation. The resolver will always take
the same arguments: args are the same for as for the message (in gtv format), account\_id (byte array) and
auth\_descriptor\_ids (list). If the resolver returns null, it means that none of the auth descriptor ids from the list is
not authorized for the action.

```codeBlockLines_e6Vv
function bar_resolver(
  args: gtv,
  account_id: byte_array,
  auth_descriptor_ids: list<byte_array>
): byte_array? {
    // Only the main auth descriptor for the account can perform this operation
    for (ad_id in auth_descriptor_ids) {
        val main_ad_id = accounts.main_auth_descriptor @ {
            .account.id == account_id
        } .auth_descriptor.id;
        return if (main_ad_id in auth_descriptor_ids) main_ad_id else null;
    }

    return null;
}

@extend(auth.auth_handler)
function () = auth.add_auth_handler(
  scope = rell.meta(bar).mount_name,
  flags = [],
  message = bar_message(*),
  resolver = bar_resolver(*)
);

```

More details about the partial function call (\*) can be found
[here](https://docs.chromia.com/rell/language-features/modules/function#partial-function-application)

## Application scope auth handler [â€‹](\#application-scope-auth-handler "Direct link to Application scope auth handler")

When multiple operations within an application share the same authentication requirements (e.g., auth flags), define an
application scope auth handler. If the `scope` property is omitted when defining an auth handler, it becomes an
application scope handler and applies to operations without operation scope auth handlers.

```codeBlockLines_e6Vv
module;

import lib.ft4.accounts;
import lib.ft4.auth;

query get_all_accounts() = accounts.account @* {} (.id);

@extend(auth.auth_handler)
function () = auth.add_auth_handler(
  flags = []
);

operation foo() {
    val account = accounts.authenticate();
}

operation bar(arg1: text, arg2: integer) {
    val account = accounts.authenticate();
}

```

caution

Defining multiple application scope auth handlers results in a runtime error during authentication.

## Mount name scope auth handler [â€‹](\#mount-name-scope-auth-handler "Direct link to Mount name scope auth handler")

In addition to operation and application scope auth handlers, a mount name scope auth handler is also available. This
enables use of a common auth handler for a mount name.

For example, consider this folder structure in a project:

```codeBlockLines_e6Vv
src/
|-dir1/
| |-dir2/
| | |-inner.rell
| |
| |-mid.rell
|
|-outer.rell

```

With this code structure:

inner.rell

```codeBlockLines_e6Vv
@mount("mid.inner")
module;

operation foo() {
    // ...
}

operation bar() {
    // ...
}

```

mid.rell

```codeBlockLines_e6Vv
@mount("mid")
module;
import dir2.inner;

```

outer.rell

```codeBlockLines_e6Vv
module;
import dir1.mid;

```

chromia.yml

```codeBlockLines_e6Vv
blockchains:
  hello:
    module: outer
#...

```

The operations are now mounted as `mid.inner.foo` and `mid.inner.bar`.

To define an auth handler for all operations in scope `inner`:

```codeBlockLines_e6Vv
@extend(auth.auth_handler)
function () = auth.add_auth_handler(
  scope = "mid.inner",
  flags = ["T"]
);

```

In this example, both `foo` and `bar` require the `T` flag to be called.

Detailed information about mount name scope auth handlers, including support for `{operation}` and `{args}` placeholders
in the auth message template, will be added later.

- [The `authenticate` function](#the-authenticate-function)
  - [Overridable auth handlers](#overridable-auth-handlers)
- [Custom auth messages](#custom-auth-messages)
  - [Account ID and signer types](#account-id-and-signer-types)
  - [FT (Postchain) signers](#ft-postchain-signers)
  - [EVM signers](#evm-signers)
  - [Signer Type Detection](#signer-type-detection)
  - [Account ID calculation](#account-id-calculation)
- [Custom resolver](#custom-resolver)
- [Application scope auth handler](#application-scope-auth-handler)
- [Mount name scope auth handler](#mount-name-scope-auth-handler)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

All notable changes to this project will be documented in this file.

The format is based on [Keep a changelog](https://keepachangelog.com/en/1.0.0/), and this project adheres to
[Semantic versioning](https://semver.org/spec/v2.0.0.html).

## \[1.0.0r\] - 2024-07-04 [â€‹](\#100r---2024-07-04 "Direct link to [1.0.0r] - 2024-07-04")

### Added âœ… [â€‹](\#added- "Direct link to Added âœ…")

- Introduced a filtering option in `get_pending_transfer_strategies` to sort results based on transfer expiration.

### Fixed ğŸ”§ [â€‹](\#fixed- "Direct link to Fixed ğŸ”§")

- Resolved an issue in the `get_auth_message_template` query where it failed if a GTV-encoded null was provided as
`args`.

## \[0.8.0r\] - 2024-05-29 [â€‹](\#080r---2024-05-29 "Direct link to [0.8.0r] - 2024-05-29")

### Breaking changes ğŸ’” [â€‹](\#breaking-changes- "Direct link to Breaking changes ğŸ’”")

- Removed the key constraint from the `symbol` attribute of the `asset` entity.
- Replaced `get_asset_by_symbol` with `get_assets_by_symbol`.
- Updated `register_crosschain_asset` operation to include `asset_id`, `asset_type`, and `uniqueness_resolver`
arguments.
- Renamed `get_paginated_asset_balances_by_name` to `get_paginated_assets_by_name`.
- Removed the `_ft_auth` function and `ft4.get_account_by_auth_descriptor` query.

### Changed ğŸª™ [â€‹](\#changed- "Direct link to Changed ğŸª™")

- Made the `icon_url` attribute of the `asset` entity mutable.

### Added âœ… [â€‹](\#added--1 "Direct link to Added âœ…")

- Added a `uniqueness_resolver` attribute to the `asset` entity.
- Introduced `get_assets_by_symbol` query to retrieve all registered assets with the same symbol.
- Added `get_transfer_rules` query to fetch transfer strategy rules configuration.

### Fixed ğŸ”§ [â€‹](\#fixed--1 "Direct link to Fixed ğŸ”§")

- Ensured that the number of required signatures in multisig auth descriptors is greater than 0.
- Verified that new main auth descriptors include all mandatory flags when using `update_main_auth_descriptor`.

## \[0.7.0r\] - 2024-04-23 [â€‹](\#070r---2024-04-23 "Direct link to [0.7.0r] - 2024-04-23")

### Breaking changes ğŸ’” [â€‹](\#breaking-changes--1 "Direct link to Breaking changes ğŸ’”")

- Deadline for transfers: Added `deadline` field to `init_transfer`. Transfers applied after this timestamp will fail
and can only be reverted.
- Moved `latest_time`: The `latest_time` field has been relocated from the `accounts` module to the `utils` module.
- Function renaming:
  - Renamed `_register_account()` to `register_account()`.
  - Renamed `add_auth_descriptor_to_account` function to `add_auth_descriptor`.
  - Renamed `_add_signer` to `add_signers`.
  - Renamed `ft4.get_auth_descriptor_nonce` to `ft4.get_auth_descriptor_counter`.
- Version requirement: Requires Rell 0.13.10.
- Entity changes:
  - Updated entity `ft4.crosschain.applied_transfers`.
  - Updated entity `ft4.account_creation_transfer`.
  - Added `transaction` field to the `applied_transfers` entity.
- Operation changes:
  - Removed `ft4.register_account_evm_signatures`, now use `ft4.evm_signatures` instead.
  - Removed `ft4.delete_all_auth_descriptors_exclude`, replaced with `ft4.delete_all_auth_descriptors_except_main`.
- Function argument changes:
  - Removed `is_strict` argument from `authenticate()` function. `auth_handlers` will now resolve to the most specific
    handler if no operation auth handler is found.
- Account creation updates:
  - Removed signature verification from `create_account_with_auth`. Signatures must now be verified separately using
    `verify_signers`.
  - `create_account_with_auth` will now create an account with an ID based on the hash of signers if the `account_id`
    argument is not provided.
- Configuration changes:
  - All module arguments for FT4 submodules in YML config now include an additional `core` component in the module path.
    For example, `accounts` module arguments should be defined under `lib.ft4.core.accounts` instead of
    `lib.ft4.accounts`.
- Module removal: Removed `ft4_basic` and `ft4_basic_dev` modules.

### Changed ğŸª™ [â€‹](\#changed--1 "Direct link to Changed ğŸª™")

- Revised internal structure of FT4 submodules: External modules are now imported alongside core modules. For instance,
importing `lib.ft4.accounts` will also import the associated operations and queries. If needed, you can still import
`accounts` entities and functions without the operations and queries by using `lib.ft4.core.accounts`.

### Added âœ… [â€‹](\#added--2 "Direct link to Added âœ…")

- Reversion of incomplete cross-chain transfers: Added support to revert incomplete cross-chain transfers after the
deadline has passed.
- Recall unclaimed register account transfers: Added functionality to recall unclaimed register account transfers after
the timeout period has expired.
- New operation: Introduced `ft4.delete_all_auth_descriptors_except_main`, which deletes all auth descriptors except the
main one.
- Auth flags configuration: Added `auth_flags` config to define mandatory and default authentication flags.
- Updated `ft4.get_register_account_message`: Now includes register account operation parameters in the auth message.
- New query: Added `ft4.get_enabled_registration_strategies` to retrieve enabled registration strategies.
- New utility functions: Added new functions in `ft4.test.utils`.
- Lock accounts support: Added support for "lock" accounts.

## \[0.6.0r\] - 2024-03-22 [â€‹](\#060r---2024-03-22 "Direct link to [0.6.0r] - 2024-03-22")

### Breaking changes ğŸ’” [â€‹](\#breaking-changes--2 "Direct link to Breaking changes ğŸ’”")

- Renamed `account` to `sender` in the `pending_transfer` entity.

### Added âœ… [â€‹](\#added--3 "Direct link to Added âœ…")

- New operation: `delete_auth_descriptors_for_signer` to remove all auth descriptors for a specific signer from an
account (corresponding to the query `get_account_auth_descriptors_by_signer`).

- New attributes and queries:
  - Added `type` attribute to the `asset` entity.
  - Introduced `get_assets_by_type` query.
  - Added `register_asset_with_type` admin operation.
- Enhanced query responses:
  - Included `is_crosschain` flag in responses from `get_transfer_history`, `get_transfer_history_from_height`, and
    `get_transfer_history_entry`.
  - Added `blockchain_rid` to responses from `get_transfer_details` and `get_transfer_details_by_asset`.
- Pending transfers: Pending transfers are now completed when the account is registered with direct strategies.

- Configuration updates: Added auth descriptor configuration options ( `max_rules` and `max_number_per_account`) to the
`get_config` query.

- Default login configuration: Set a 1-day expiration for default login configuration.

- New queries:
  - `get_last_pending_transfer_for_account`: Returns the most recent pending cross-chain transfer matching the provided
    parameters (sender, target chain, recipient, asset, amount).
  - `has_pending_create_account_transfer_for_strategy`: Checks if a "create on transfer" account registration is
    initiated for the specified strategy.

## \[0.5.0r\] - 2024-02-29 [â€‹](\#050r---2024-02-29 "Direct link to [0.5.0r] - 2024-02-29")

### Breaking changes ğŸ’” [â€‹](\#breaking-changes--3 "Direct link to Breaking changes ğŸ’”")

- Changed the mount name of the `lib.ft4.accounts` module from `ft` to `ft4`, affecting the following entities:
  - `account`
  - `account_auth_descriptor`
  - `auth_descriptor_signer`
  - `rl_state`

### Changed ğŸª™ [â€‹](\#changed--2 "Direct link to Changed ğŸª™")

- Updated the `_register_account()` function to return the created account.

### Added âœ… [â€‹](\#added--4 "Direct link to Added âœ…")

- New extension functions for cross-chain transfers:
  - `before_init_transfer`
  - `after_init_transfer`
  - `before_apply_transfer`
  - `after_apply_transfer`
- New `register_crosschain_asset` function.

- New account creation strategies:
  - Create on transfer: Subscription-based
  - Configurable fee account

## \[0.4.0r\] - 2024-02-15 [â€‹](\#040r---2024-02-15 "Direct link to [0.4.0r] - 2024-02-15")

### Breaking changes ğŸ’” [â€‹](\#breaking-changes--4 "Direct link to Breaking changes ğŸ’”")

- Changed `asset_data` to `asset` in the following queries:
  - `get_transfer_history`
  - `get_transfer_history_from_height`
  - `get_transfer_history_entry`

### Changed ğŸª™ [â€‹](\#changed--3 "Direct link to Changed ğŸª™")

- The `create_account_with_auth` function now requires the `auth_descriptor` to include the `A` flag. Accounts cannot be
created with an `auth_descriptor` missing the `A` flag by default.
- The `get_auth_descriptor_nonce` function now returns `null` if the auth descriptor is not found, rather than rejecting
the request.
- The `page_size` parameter in paginated queries is now optional. The default value can be configured using the
`query_max_page_size` field under the `lib.ft4` section.
- Updated the `transfer` function to support account creation during transfers.
- Revised the calculation method for account IDs.

### Added âœ… [â€‹](\#added--5 "Direct link to Added âœ…")

- Introduced a framework for account creation.
- New account creation strategies:
  - Create on transfer:
    - Open
    - Fee-based
  - Open strategy
- Added `get_first_allowed_auth_descriptor_by_signers` query.
- Added support for rules in the login configuration.

### Bugfixes ğŸ› [â€‹](\#bugfixes- "Direct link to Bugfixes ğŸ›")

- Cross-chain transfer operations now validate that transactions are anchored on SAC before proceeding.

## \[0.3.1r\] - 2024-01-19 [â€‹](\#031r---2024-01-19 "Direct link to [0.3.1r] - 2024-01-19")

### Changed ğŸª™ [â€‹](\#changed--4 "Direct link to Changed ğŸª™")

- Enhanced validation for `register_crosschain_asset` parameters.
- Added `op_index` to the `get_transfer_history` response for better tracking.

## \[0.3.0r\] - 2024-01-17 [â€‹](\#030r---2024-01-17 "Direct link to [0.3.0r] - 2024-01-17")

### Breaking changes ğŸ’” [â€‹](\#breaking-changes--5 "Direct link to Breaking changes ğŸ’”")

- Removed auth descriptor types `ES` and `EM`.

### Changed ğŸª™ [â€‹](\#changed--5 "Direct link to Changed ğŸª™")

- Introduced `get_all_auth_handlers` query to retrieve all authentication handlers specified by the dapp.
- Added `get_first_allowed_auth_descriptor` query to enable blockchain selection of auth descriptors for operation
authentication.
- Enabled creation of overridable auth handlers.
- Added `resolver` field to `AuthHandler` for custom authentication logic evaluation.
- Updated transaction prioritization to support Postchain 3.14.17 and later.
- Fixed `init_transfer` auth message issue to support `init_transfer` operation with EVM auth.

## \[0.2.0r\] - 2023-12-22 [â€‹](\#020r---2023-12-22 "Direct link to [0.2.0r] - 2023-12-22")

warning

This version is incompatible with older versions. To upgrade, you will need to perform a database migration. For more
information, refer to [this page](/rell/language-features/modules/entity#changing-entity-definitions).

### Breaking changes ğŸ’” [â€‹](\#breaking-changes--6 "Direct link to Breaking changes ğŸ’”")

- Paginated queries: Queries `get_accounts_by_participant_id` and `get_account_auth_descriptors_by_participant_id` are
now paginated. Update your code to handle these changes.
- Paginated queries: Removed non-paginated queries `_get_accounts_by_auth_descriptor_id`, `_get_asset_balances`, and
`_get_all_assets`. Use their paginated counterparts without the leading `_`. Replaced `get_asset_by_name` with the
paginated `get_assets_by_name`.
- Rules structure: Revised the internal structure of rules. Existing auth descriptors using rules will no longer
function and will cause runtime errors.
- Address functions removed: Deprecated `evm_address_from_pubkey` and `evm_address_from_privkey`. Use
`crypto.eth_pubkey_to_address` and `crypto.eth_privkey_to_address` from the Rell standard library.
- Function return types: `create_account_with_auth` now returns `account` instead of `byte_array`.
`add_auth_descriptor_to_account` now returns `account_auth_descriptor` instead of `byte_array`.
- Rate limit config: Updated format for rate limit configuration.
- `brid` to `blockchain_rid`: Renamed all instances of `brid` to `blockchain_rid` to clarify the acronym. This affects:
  - `asset.issuing_brid` -\> `asset.issuing_blockchain_rid`
  - Queries and message templates that previously used `{brid}` now use `{blockchain_rid}`.
  - `asset_origin.origin_brid` -\> `asset_origin.origin_blockchain_rid`
- Renamed terms: Updated terminology related to auth descriptors:
  - Queries: `get_account_auth_descriptors_by_participant_id` -\> `get_account_auth_descriptors_by_signer`,
    `get_accounts_by_participant_id` -\> `get_accounts_by_signer`.
  - Accounts module: Renamed `single_sig_args.pubkey` to `single_sig_args.signer`, `multi_sig_args.pubkeys` to
    `multi_sig_args.signers`, `get_participants` to `get_signers`, `auth_descriptor_participant` to
    `auth_descriptor_signer`, and functions like `get_paginated_auth_descriptors_by_participant_id` to
    `get_paginated_auth_descriptors_by_signer`.
  - Internals: Renamed `_add_auth_participant` to `_add_signer`, and `_add_eth_auth_participant` to `_add_eth_signer`.
- Transfer history: Removed `transfer_args` and `entry_index` from `get_transfer_history_entry` and
`get_transfer_history` queries.

### Added âœ… [â€‹](\#added--6 "Direct link to Added âœ…")

- Default values for `lib.ft4.accounts` module\_args to simplify `chromia.yml` configuration.
- Configuration parameter `max_auth_descriptor_rules` for `lib.ft4.accounts` module\_args, with a default value of 8.
- Option to customize the rate limiter for some accounts.
- Queries `get_transfer_details`, `get_transfer_details_by_asset`, and `get_transfer_history_from_height` moved to
`lib.ft4.assets.external`.
- Support for transaction priority.

### Changed ğŸª™ [â€‹](\#changed--6 "Direct link to Changed ğŸª™")

- Updated signature for `evm_auth_operation_for` to accept a `rell.test.op`.
- `before_authenticate` function is now extendable to add custom pre-authentication logic.
- `after_authenticate` function is now extendable to execute logic post-authentication.
- Account creation with `create_account_with_auth` can now be done without `op_context`.
- Validation added for auth descriptors to prevent the creation of expired descriptors.

## \[0.1.7r\] - 2023-10-25 [â€‹](\#017r---2023-10-25 "Direct link to [0.1.7r] - 2023-10-25")

### Added âœ… [â€‹](\#added--7 "Direct link to Added âœ…")

- Added the `get_admin_pubkey()` function to the admin module, enabling retrieval of the admin public key.

## \[0.1.6r\] - 2023-10-20 [â€‹](\#016r---2023-10-20 "Direct link to [0.1.6r] - 2023-10-20")

### Changed ğŸª™ [â€‹](\#changed--7 "Direct link to Changed ğŸª™")

- Removed cross-chain submodule imports from `ft4_basic_dev`.

## \[0.1.5r\] - 2023-10-19 [â€‹](\#015r---2023-10-19 "Direct link to [0.1.5r] - 2023-10-19")

### Added âœ… [â€‹](\#added--8 "Direct link to Added âœ…")

- Implemented cross-chain functions for asset transfer across chains.
- Introduced a new admin module, `admin.crosschain`, for registering cross-chain assets.
- Added the option to specify tests for Rell using the `--tests` or `-t` option in `scripts/relltest.sh`.

## \[0.1.4r\] - 2023-09-29 [â€‹](\#014r---2023-09-29 "Direct link to [0.1.4r] - 2023-09-29")

### Changed ğŸª™ [â€‹](\#changed--8 "Direct link to Changed ğŸª™")

- Importing a module now automatically imports the corresponding external module as well.

## \[0.1.3r\] - 2023-09-19 [â€‹](\#013r---2023-09-19 "Direct link to [0.1.3r] - 2023-09-19")

### Added âœ… [â€‹](\#added--9 "Direct link to Added âœ…")

- Added additional test utility functions.
- Added `evm_address_from_pubkey` function.

## \[0.1.2r\] - 2023-09-18 [â€‹](\#012r---2023-09-18 "Direct link to [0.1.2r] - 2023-09-18")

### Changed ğŸª™ [â€‹](\#changed--9 "Direct link to Changed ğŸª™")

- The version module is now included regardless of which modules are used from the library.

### Added âœ… [â€‹](\#added--10 "Direct link to Added âœ…")

- Added more test utility functions.

## \[0.1.1r\] - 2023-09-12 [â€‹](\#011r---2023-09-12 "Direct link to [0.1.1r] - 2023-09-12")

### Changed ğŸª™ [â€‹](\#changed--10 "Direct link to Changed ğŸª™")

- Assets are now always returned with all properties from Postchain. The separate properties `asset`, `asset_id`, and
`decimals` will be removed in favor of the more comprehensive `asset_data`.
- The version information is now included in every non-external module, ensuring that every dapp using ft4 has access to
version details.

### Added âœ… [â€‹](\#added--11 "Direct link to Added âœ…")

- Added a `test` module with utility functions for testing.

## \[0.1.0r\] - 2023-07-12 [â€‹](\#010r---2023-07-12 "Direct link to [0.1.0r] - 2023-07-12")

Initial release

- [\[1.0.0r\] - 2024-07-04](#100r---2024-07-04)
  - [Added âœ…](#added-)
  - [Fixed ğŸ”§](#fixed-)
- [\[0.8.0r\] - 2024-05-29](#080r---2024-05-29)
  - [Breaking changes ğŸ’”](#breaking-changes-)
  - [Changed ğŸª™](#changed-)
  - [Added âœ…](#added--1)
  - [Fixed ğŸ”§](#fixed--1)
- [\[0.7.0r\] - 2024-04-23](#070r---2024-04-23)
  - [Breaking changes ğŸ’”](#breaking-changes--1)
  - [Changed ğŸª™](#changed--1)
  - [Added âœ…](#added--2)
- [\[0.6.0r\] - 2024-03-22](#060r---2024-03-22)
  - [Breaking changes ğŸ’”](#breaking-changes--2)
  - [Added âœ…](#added--3)
- [\[0.5.0r\] - 2024-02-29](#050r---2024-02-29)
  - [Breaking changes ğŸ’”](#breaking-changes--3)
  - [Changed ğŸª™](#changed--2)
  - [Added âœ…](#added--4)
- [\[0.4.0r\] - 2024-02-15](#040r---2024-02-15)
  - [Breaking changes ğŸ’”](#breaking-changes--4)
  - [Changed ğŸª™](#changed--3)
  - [Added âœ…](#added--5)
  - [Bugfixes ğŸ›](#bugfixes-)
- [\[0.3.1r\] - 2024-01-19](#031r---2024-01-19)
  - [Changed ğŸª™](#changed--4)
- [\[0.3.0r\] - 2024-01-17](#030r---2024-01-17)
  - [Breaking changes ğŸ’”](#breaking-changes--5)
  - [Changed ğŸª™](#changed--5)
- [\[0.2.0r\] - 2023-12-22](#020r---2023-12-22)
  - [Breaking changes ğŸ’”](#breaking-changes--6)
  - [Added âœ…](#added--6)
  - [Changed ğŸª™](#changed--6)
- [\[0.1.7r\] - 2023-10-25](#017r---2023-10-25)
  - [Added âœ…](#added--7)
- [\[0.1.6r\] - 2023-10-20](#016r---2023-10-20)
  - [Changed ğŸª™](#changed--7)
- [\[0.1.5r\] - 2023-10-19](#015r---2023-10-19)
  - [Added âœ…](#added--8)
- [\[0.1.4r\] - 2023-09-29](#014r---2023-09-29)
  - [Changed ğŸª™](#changed--8)
- [\[0.1.3r\] - 2023-09-19](#013r---2023-09-19)
  - [Added âœ…](#added--9)
- [\[0.1.2r\] - 2023-09-18](#012r---2023-09-18)
  - [Changed ğŸª™](#changed--9)
  - [Added âœ…](#added--10)
- [\[0.1.1r\] - 2023-09-12](#011r---2023-09-12)
  - [Changed ğŸª™](#changed--10)
  - [Added âœ…](#added--11)
- [\[0.1.0r\] - 2023-07-12](#010r---2023-07-12)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

The orchestrator is a utility object that facilitates cross-chain transfers. It can be instantiated, listen to events,
and execute asset transfers between blockchains.

note

**Prerequisite environment setup**: Before you proceed with cross-chain transfers, ensure you have set up the necessary
environment. You need to clone the FT4 library using the following commands:

```codeBlockLines_e6Vv
git clone https://bitbucket.org/chromawallet/ft3-lib.git
cd ft3-lib

```

Run the examples and scripts from the root directory of the cloned repository.

## Initial multichain environment setup [â€‹](\#initial-multichain-environment-setup "Direct link to Initial multichain environment setup")

Before proceeding with the examples, initialize your multichain environment. Run the `npm run multichain:demo` script
from within the root directory of the cloned `ft3-lib` repository. Upon execution, you'll see an output similar to the
following:

```codeBlockLines_e6Vv
--- SUMMARY ---
Copy the following into your code as needed:
Multichain00 BRID: ...
Multichain02 BRID: ...
User Account ID:   ...
User Private Key:  ...
Test Asset ID: ...
-----------------
Press Ctrl+C to exit.

```

Make sure to copy the values provided, as they will be required to set up the orchestrator.

warning

**Important Configuration Requirement**: To ensure the successful validation of ICCF proofs during cross-chain
transfers, it's crucial to include the ICCF module in your chain configuration. Typically specified in `chromia.yml`,
the configuration should resemble the following:

```codeBlockLines_e6Vv
config:
  gtx:
    modules:
      - "net.postchain.d1.iccf.IccfGTXModule"

```

Omitting this module from the configuration may lead to the non-validation of ICCF proofs, impeding the proper
functioning of cross-chain transfers. Check [Import the cross-chain module](/imports#the-crosschain-module) for
more information.

## Performing the transfer [â€‹](\#performing-the-transfer "Direct link to Performing the transfer")

The code snippet below performs the transfer. The values for `targetChainId`, `recipientId`, `assetId`, and `keyPair`
should be copied from the `npm run multichain:demo` script output.

```codeBlockLines_e6Vv
const { createClient, encryption, formatter} = require("postchain-client");
const { createAmount, createInMemoryFtKeyStore, createKeyStoreInteractor } = require('@chromia/ft4');

// Prepare the required context
const sourceChainId = /* Paste the BRID of multichain00 */;
const targetChainId = /* Paste the BRID of multichain02 */;
const accountId = /* Paste user account ID here */;
const keyPair = encryption.makeKeyPair(/* Paste user private key here */);
const assetId = /* Paste the asset ID */;
const amountToSend = createAmount(10, 0);

  // Initialize Chromia client on multichain00
  const client0 = await createClient({
    directoryNodeUrlPool: "http://localhost:7740",
    blockchainRid: sourceChainId,
  });

  // Initialize session and keystore
  const { getSession } = createKeyStoreInteractor(
    client0,
    createInMemoryFtKeyStore(keyPair)
  );

  const session0 = await getSession(accountId);

  // make transfer
  try {
    await session0.account.crosschainTransfer(
      targetChainId,
      accountId,
      assetId,
      amountToSend,
    )
      .on("signed", (tx) => console.log("Transaction signed"))
      .on("init", (receipt) => console.log("Transfer initialized"))
      .on("hop", (bcRid) => console.log(`On chain ${formatter.toString(bcRid)}`));
    console.log("Transfer completed");
  } catch(e) {
    console.log(`Transfer failed due to ${e}`);
  }

```

### Error handling [â€‹](\#error-handling "Direct link to Error handling")

caution

Ensure you handle errors appropriately during the cross-chain transfer.

The orchestrator emits errors that are descendants of `OrchestratorError` from `@chromia/ft4`.

### Registering cross-chain assets [â€‹](\#registering-cross-chain-assets "Direct link to Registering cross-chain assets")

Cross-chain assets can be manually registered using the `registerCrosschainAsset()` function.

```codeBlockLines_e6Vv
// example to register an asset
const { registerCrosschainAsset, IClient, SignatureProvider, Asset, BufferId } = require('@chromia/ft4');

const childClient: IClient = session0.client;
const adminSignatureProvider: SignatureProvider = /* ... */;
const asset: Asset = /* ... */;
const parentBrid: BufferId = /* Paste parent blockchain RID */;

await registerCrosschainAsset(childClient, adminSignatureProvider, asset, parentBrid);

```

To build asset hierarchies, specify the `parentBrid` and a corresponding `childClient` during registration. The
`childClient` can be connected to different blockchains like `multichain00` or `multichain01`. See the
[Transfer architecture](/backend/cross-chain/cross-chain-transfers) topic for more information.

You can also register cross-chain assets using the CLI:

```codeBlockLines_e6Vv
chr tx --blockchain-rid <child blockchain RID> \
    ft4.admin.register_crosschain_asset TestAsset TST 6 $TEST_ASSET_BRID https://url-to-asset-icon \
    <parent blockchain RID> \
    --await \
    --secret .chromia/ft4-admin.keypair

```

info

If you want to see an example of a cross-chain transfer between two chains, you can explore the
[Simple FT4 cross-chain demo](https://bitbucket.org/chromawallet/ft3-lib/src/development/examples/crosschain-cli-example/).

- [Initial multichain environment setup](#initial-multichain-environment-setup)
- [Performing the transfer](#performing-the-transfer)
  - [Error handling](#error-handling)
  - [Registering cross-chain assets](#registering-cross-chain-assets)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Multi-signature (multi-sig) transactions provide an added layer of security and shared control over blockchain
transactions. In a multi-signature setup, multiple parties must approve a transaction before it can be executed,
reducing the risk of unauthorized actions. Multi-sig arrangements are commonly used for scenarios requiring heightened
security, such as managing corporate funds, safeguarding shared assets, or establishing trust in decentralized systems.

In a multi-signature transaction, a predefined number of designated signers must authorize the transaction for it to be
valid. This setup allows for flexible access control, as users can specify the minimum number of required signatures.

## Creating a new multi-signature transaction [â€‹](\#creating-a-new-multi-signature-transaction "Direct link to Creating a new multi-signature transaction")

### Minimal command [â€‹](\#minimal-command "Direct link to Minimal command")

To initiate a new multi-signature transaction, use the following command:

```codeBlockLines_e6Vv
chr multi-signature create --signers-file <path-to-signers-file> <op_name> <op_args>

```

This command reads the public keys from the specified signers file, adding them along with the initiatorâ€™s own key as
signers for the transaction. The transaction will be signed with the configured keypair, while other required signatures
will be left blank.

#### Signers file format [â€‹](\#signers-file-format "Direct link to Signers file format")

The signers file should follow this format:

```codeBlockLines_e6Vv
pubkey1=examplePublicKey1 pubkey2=examplePublicKey2

```

The public keys of the intended signers must be available to the transaction creator.

Additional command options, such as `--settings`, `--network`, `--blockchain-brid`, `--api-url`, or other
configurations, can be used to specify transaction settings.

### Creating a transaction with FT auth [â€‹](\#creating-a-transaction-with-ft-auth "Direct link to Creating a transaction with FT auth")

To create a transaction using FT4 authentication, follow this approach:

```codeBlockLines_e6Vv
@extend(auth.auth_handler)
function () = auth.add_auth_handler(
  scope = rell.meta(foo).mount_name,
  flags = []
);

operation foo() {
    val account = auth.authenticate();
    val a = 2;
}

operation create_user(signers: list<pubkey>) {
    val account = create_account_with_auth(multi_sig_auth_descriptor(signers, 3, set(["A", "T"])));
}

```

In this example, the `foo()` operation requires an auth descriptor. The descriptor is created using
`multi_sig_auth_descriptor(signers, 3, set(["A", "T"]))`, requiring a minimum of three signers.

To create a transaction with FT Auth, use:

```codeBlockLines_e6Vv
chr multi-signature create --signers-file <path-to-signers-file> --ft-auth --auth-descriptor-id <auth_descriptor_id> <op_name>

```

The `auth_descriptor_id` can be located in the
[Chromia Economy Chain Vault](https://vault.chromia.com/en/dapps/dapp/auth-descriptors/?dapp=2-Chromia+Economy+Chain).

Ensure the signers file contains at least two public keys, creating a total of three signers when combined with the
initiatorâ€™s key. This setup adds the `ft4.ft_auth` operation to the transaction with the designated auth descriptor. All
keys in the signers file must be included in the specified auth descriptor.

### Transaction output [â€‹](\#transaction-output "Direct link to Transaction output")

Executing the multi-signature creation command generates a file with the transaction in hex format, which should be
shared with the next signer.

## Adding signatures to a multi-wignature transaction [â€‹](\#adding-signatures-to-a-multi-wignature-transaction "Direct link to Adding signatures to a multi-wignature transaction")

To add a signature to an existing transaction, use:

```codeBlockLines_e6Vv
chr multi-signature sign --file <path-to-transaction-file>

```

This command signs the transaction with the configured keypair. A different keypair can be specified using the
`--secret` option.

### Signing transaction oOutput [â€‹](\#signing-transaction-ooutput "Direct link to Signing transaction oOutput")

The sign command produces a file containing the transaction in hex format with the new signature added, which should
then be passed to the next signer.

## Sending a fully signed transaction [â€‹](\#sending-a-fully-signed-transaction "Direct link to Sending a fully signed transaction")

After all necessary signatures have been collected, send the transaction using:

```codeBlockLines_e6Vv
chr multi-signature send --file <path-to-transaction-file>

```

Additional options like `--settings`, `--network`, `--blockchain-brid`, `--api-url`, and other configurations may be
used to determine the transaction destination.

## Viewing a transaction [â€‹](\#viewing-a-transaction "Direct link to Viewing a transaction")

To view transaction details, use:

```codeBlockLines_e6Vv
chr multi-signature view --file <path-to-transaction-file>

```

### Example output: [â€‹](\#example-output "Direct link to Example output:")

```codeBlockLines_e6Vv
{
  "blockchainRID": "7866A7DC9DA2E2075485DE8B877DED6F3AC28D1290D88A977D31C8C59DCDA7C6",
  "operations": [\
    {\
      "operation": "ft4.ft_auth",\
      "arguments": [\
        "byteArray: EBC8131DCBF77109409721CFA0031A2EF8A2A05FCACCCF533C537CA399CBC20A",\
        "byteArray: 823EB58C2AE2AF05D5EB920983C2B4CE5046BF80B8A8B803EE450F0250E3A72B"\
      ]\
    },\
    {\
      "operation": "foo",\
      "arguments": []\
    },\
    {\
      "operation": "nop",\
      "arguments": ["integer: 1729680747739"]\
    }\
  ],
  "signers": [\
    "031C434E1C5C8FCF0DA097FABBFBADE61F0C694F163DD23C70884978EEFE8480AE",\
    "030CB88BF43C4018E752E7ACB66BE271A4E72AA7283DDEA4BD44603FC4B4788DAA",\
    "0333E98D20E784EF395131F8FC7B9112470420594EB59EBF217BC100C054D46212"\
  ],
  "signatures": [\
    "31314F6B30DD06DA9AD5A3781426081DB716DAE0420B8AE2FF4C5D2D1BDAB8631C127B6C56F8B2F3BC39FB7D6914E619E6D6EFBE83319F9A9DE28EAC244B006B",\
    "",\
    "207C87A336632DBB282C9045A4446EFF7C096E699CC91176691BD936CF84448F6AAE780FAFAC9617C94EDDE67743493F1BA82F44A33478A82AE750410B79EAFB"\
  ]
}

```

- [Creating a new multi-signature transaction](#creating-a-new-multi-signature-transaction)
  - [Minimal command](#minimal-command)
  - [Creating a transaction with FT auth](#creating-a-transaction-with-ft-auth)
  - [Transaction output](#transaction-output)
- [Adding signatures to a multi-wignature transaction](#adding-signatures-to-a-multi-wignature-transaction)
  - [Signing transaction oOutput](#signing-transaction-ooutput)
- [Sending a fully signed transaction](#sending-a-fully-signed-transaction)
- [Viewing a transaction](#viewing-a-transaction)
  - [Example output:](#example-output)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

This topic describes the functions available for making assertions within tests. These functions are used to verify
expected conditions and behaviors, ensuring the correctness of the code under test.

- [`assert_equals(actual: T, expected: T)`](#assert_equalsactual-t-expected-t)
- [`assert_not_equals(actual: T, expected: T)`](#assert_not_equalsactual-t-expected-t)
- [`assert_true(actual: boolean)`](#assert_trueactual-boolean)
- [`assert_false(actual: boolean)`](#assert_falseactual-boolean)
- [`assert_null(actual: T?)`](#assert_nullactual-t)
- [`assert_not_null(actual: T?)`](#assert_not_nullactual-t)
- [`assert_lt(actual: T, expected: T)`](#assert_ltactual-t-expected-t)
- [`assert_gt(actual: T, expected: T)`](#assert_gtactual-t-expected-t)
- [`assert_le(actual: T, expected: T)`](#assert_leactual-t-expected-t)
- [`assert_ge(actual: T, expected: T)`](#assert_geactual-t-expected-t)
- [`assert_gt_lt(actual: T, min: T, max: T)`](#assert_gt_ltactual-t-min-t-max-t)
- [`assert_gt_le(actual: T, min: T, max: T)`](#assert_gt_leactual-t-min-t-max-t)
- [`assert_ge_lt(actual: T, min: T, max: T)`](#assert_ge_ltactual-t-min-t-max-t)
- [`assert_ge_le(actual: T, min: T, max: T)`](#assert_ge_leactual-t-min-t-max-t)
- [`assert_events(expected: (text, gtv)...)`](#assert_eventsexpected-text-gtv)
- [`rell.test.get_events(): list<(text, gtv)>`](#relltestget_events-listtext-gtv)
- [`assert_fails(f: () -> unit): rell.test.failure`](#assert_failsf----unit-relltestfailure)

### `assert_equals(actual: T, expected: T)` [â€‹](\#assert_equalsactual-t-expected-t "Direct link to assert_equalsactual-t-expected-t")

Asserts that two values are equal.

**Parameters:**

- `actual: T` \- The actual value to compare.
- `expected: T` \- The expected value.

**Throws:** An exception if the values are not equal.

### `assert_not_equals(actual: T, expected: T)` [â€‹](\#assert_not_equalsactual-t-expected-t "Direct link to assert_not_equalsactual-t-expected-t")

Asserts that two values are not equal.

**Parameters:**

- `actual: T` \- The actual value to compare.
- `expected: T` \- The value that should not be equal to the actual value.

**Throws:** An exception if the values are equal.

### `assert_true(actual: boolean)` [â€‹](\#assert_trueactual-boolean "Direct link to assert_trueactual-boolean")

Asserts that the value is "true".

**Parameters:**

- `actual: boolean` \- The boolean value to test.

**Throws:** An exception if the value is not "true".

### `assert_false(actual: boolean)` [â€‹](\#assert_falseactual-boolean "Direct link to assert_falseactual-boolean")

Asserts that the value is "false".

**Parameters:**

- `actual: boolean` \- The boolean value to test.

**Throws:** An exception if the value is not "false".

### `assert_null(actual: T?)` [â€‹](\#assert_nullactual-t "Direct link to assert_nullactual-t")

Asserts that the value is null.

**Parameters:**

- `actual: T?` \- The value to test for nullity.

**Throws:** An exception if the value is not null.

### `assert_not_null(actual: T?)` [â€‹](\#assert_not_nullactual-t "Direct link to assert_not_nullactual-t")

Asserts that the value is not null.

**Parameters:**

- `actual: T?` \- The value to test for non-nullity.

**Throws:** An exception if the value is null.

### `assert_lt(actual: T, expected: T)` [â€‹](\#assert_ltactual-t-expected-t "Direct link to assert_ltactual-t-expected-t")

Asserts that the actual value is less than the expected value.

**Parameters:**

- `actual: T` \- The actual value to compare.
- `expected: T` \- The expected value.

**Throws:** An exception if the actual value is not less than the expected value.

### `assert_gt(actual: T, expected: T)` [â€‹](\#assert_gtactual-t-expected-t "Direct link to assert_gtactual-t-expected-t")

Asserts that the actual value is greater than the expected value.

**Parameters:**

- `actual: T` \- The actual value to compare.
- `expected: T` \- The expected value.

**Throws:** An exception if the actual value is not greater than the expected value.

### `assert_le(actual: T, expected: T)` [â€‹](\#assert_leactual-t-expected-t "Direct link to assert_leactual-t-expected-t")

Asserts that the actual value is less than or equal to the expected value.

**Parameters:**

- `actual: T` \- The actual value to compare.
- `expected: T` \- The expected value.

**Throws:** An exception if the actual value is not less than or equal to the expected value.

### `assert_ge(actual: T, expected: T)` [â€‹](\#assert_geactual-t-expected-t "Direct link to assert_geactual-t-expected-t")

Asserts that the actual value is greater than or equal to the expected value.

**Parameters:**

- `actual: T` \- The actual value to compare.
- `expected: T` \- The expected value.

**Throws:** An exception if the actual value is not greater than or equal to the expected value.

### `assert_gt_lt(actual: T, min: T, max: T)` [â€‹](\#assert_gt_ltactual-t-min-t-max-t "Direct link to assert_gt_ltactual-t-min-t-max-t")

Asserts that the actual value is greater than min and less than max.

**Parameters:**

- `actual: T` \- The actual value to compare.
- `min: T` \- The minimum value.
- `max: T` \- The maximum value.

**Throws:** An exception if the actual value is not within the specified range.

### `assert_gt_le(actual: T, min: T, max: T)` [â€‹](\#assert_gt_leactual-t-min-t-max-t "Direct link to assert_gt_leactual-t-min-t-max-t")

Asserts that the actual value is greater than min and less than or equal to max.

**Parameters:**

- `actual: T` \- The actual value to compare.
- `min: T` \- The minimum value.
- `max: T` \- The maximum value.

**Throws:** An exception if the actual value is not within the specified range.

### `assert_ge_lt(actual: T, min: T, max: T)` [â€‹](\#assert_ge_ltactual-t-min-t-max-t "Direct link to assert_ge_ltactual-t-min-t-max-t")

Asserts that the actual value is greater than or equal to min and less than max.

**Parameters:**

- `actual: T` \- The actual value to compare.
- `min: T` \- The minimum value.
- `max: T` \- The maximum value.

**Throws:** An exception if the actual value is not within the specified range.

### `assert_ge_le(actual: T, min: T, max: T)` [â€‹](\#assert_ge_leactual-t-min-t-max-t "Direct link to assert_ge_leactual-t-min-t-max-t")

Asserts that the actual value is greater than or equal to min and less than or equal to max.

**Parameters:**

- `actual: T` \- The actual value to compare.
- `min: T` \- The minimum value.
- `max: T` \- The maximum value.

**Throws:** An exception if the actual value is not within the specified range.

### `assert_events(expected: (text, gtv)...)` [â€‹](\#assert_eventsexpected-text-gtv "Direct link to assert_eventsexpected-text-gtv")

Checks whether the list of events emitted during the last block execution matches the expected list of events.

**Parameters:**

- `expected: (text, gtv)...` \- A list of tuples, where each tuple represents an expected event with its name and Global
Type Value (gtv).

**Throws:** An exception if the actual events do not match the expected events.

### `rell.test.get_events(): list<(text, gtv)>` [â€‹](\#relltestget_events-listtext-gtv "Direct link to relltestget_events-listtext-gtv")

Returns the list of events emitted during the last block execution.

**Returns:** A list of tuples, where each tuple represents an event with its name and gtv.

### `assert_fails(f: () -> unit): rell.test.failure` [â€‹](\#assert_failsf----unit-relltestfailure "Direct link to assert_failsf----unit-relltestfailure")

Asserts that a function fails.

**Parameters:**

- `f: () -> unit` \- The function to test for failure.

**Returns:** A `rell.test.failure` object containing information about the failure, if the function fails.

**Throws:** An exception if the function does not fail.

**Optional Parameter:**

- `expected: text` \- If specified, the actual error message must contain the expected text.

#### Partial function for `assert_fails()` [â€‹](\#partial-function-for-assert_fails "Direct link to partial-function-for-assert_fails")

Use partial function application to pass a function to `assert_fails()`. For example:

```codeBlockLines_e6Vv
function foo(x: integer) {
     require(x >= 0, "x is negative: " + x);
 }
  ...
 assert_fails(foo(-123, *));                        // OK
 assert_fails("x is negative: -123", foo(-123, *)); // OK
 assert_fails(foo(123, *));                         // Fails

```

Use the returned value if non-exact error message matching is needed:

```codeBlockLines_e6Vv
val f = assert_fails(foo(-123, *));
assert_true(f.message.starts_with("x is negative: "));

```

- [`assert_equals(actual: T, expected: T)`](#assert_equalsactual-t-expected-t)
- [`assert_not_equals(actual: T, expected: T)`](#assert_not_equalsactual-t-expected-t)
- [`assert_true(actual: boolean)`](#assert_trueactual-boolean)
- [`assert_false(actual: boolean)`](#assert_falseactual-boolean)
- [`assert_null(actual: T?)`](#assert_nullactual-t)
- [`assert_not_null(actual: T?)`](#assert_not_nullactual-t)
- [`assert_lt(actual: T, expected: T)`](#assert_ltactual-t-expected-t)
- [`assert_gt(actual: T, expected: T)`](#assert_gtactual-t-expected-t)
- [`assert_le(actual: T, expected: T)`](#assert_leactual-t-expected-t)
- [`assert_ge(actual: T, expected: T)`](#assert_geactual-t-expected-t)
- [`assert_gt_lt(actual: T, min: T, max: T)`](#assert_gt_ltactual-t-min-t-max-t)
- [`assert_gt_le(actual: T, min: T, max: T)`](#assert_gt_leactual-t-min-t-max-t)
- [`assert_ge_lt(actual: T, min: T, max: T)`](#assert_ge_ltactual-t-min-t-max-t)
- [`assert_ge_le(actual: T, min: T, max: T)`](#assert_ge_leactual-t-min-t-max-t)
- [`assert_events(expected: (text, gtv)...)`](#assert_eventsexpected-text-gtv)
- [`rell.test.get_events(): list<(text, gtv)>`](#relltestget_events-listtext-gtv)
- [`assert_fails(f: () -> unit): rell.test.failure`](#assert_failsf----unit-relltestfailure)[Skip to main content](#__docusaurus_skipToContent_fallback)

FT4 provides flexible account management for dapps, supporting multi-user accounts and customizable registration
strategies. It enables secure access control through auth descriptors, which define key pairs and permissions, including
single and multi-signature setups. Authentication is simplified with the authenticate operation and customizable
auth\_handler functions, supporting native and EVM signatures, multiple key pairs, disposable keys, and overrideable
logic.

[FT4 allows you to manage accounts with unique identifiers, enabling secure interactions with decentralized applications. It supports multi-user accounts and customizable registration strategies to suit different access levels and security needs.](/ft4/overview) [FT4 allows flexible account management through auth descriptors, which define the key pairs and permissions for\\
accessing accounts. These descriptors support single and multi-signature setups, offering secure, customizable\\
access control for different use cases.](/ft4/auth-descriptors) [FT4 simplifies dapp authentication by abstracting native and EVM signatures, and multiple key pairs. The authenticate operation and customizable auth\_handler functions provide flexible, secure authentication, supporting scenarios like disposable keys and overrideable logic.](/ft4/authentication)[Skip to main content](#__docusaurus_skipToContent_fallback)

FT4 allows secure asset registration, ensuring unique identity and metadata via admin or custom operations. Asset
balances are managed with precise attributes like supply and precision, supporting secure operations and cross-chain
compatibility. FT4 lock accounts enable temporary asset storage for use cases such as staking or auctions, restricting
access without transferring ownership.

[Asset registration in FT4 initializes and standardizes assets, ensuring unique identity, metadata, and secure tracking. It can be done via a built-in admin operation or custom operations for greater control.](/ft4/backend/register-assets) [FT4 manages asset balances by defining attributes like precision, supply, and issuing blockchain, while ensuring\\
secure operations such as balance increases, deductions, and cross-chain compatibility.](/ft4/backend/asset-amounts) [FT4's lock accounts securely store assets temporarily for scenarios like staking or auctions, restricting access without transferring ownership.](/ft4/backend/locking-assets)[Skip to main content](#__docusaurus_skipToContent_fallback)

Providers are the backbone of the Chromia ecosystem. A provider is a person or organization responsible for nodes, which
are physical or virtual instances of computing power.

Chromia acquires node capacity from providers. Nodes run by providers produce blocks, thus enabling dapps to run.

The following are the roles on the network:

| **Provider role** | **Permitted actions** |
| --- | --- |
| Dapp Provider (DP) | Can deploy dapps and add nodes that replicates blockchains (replica) (default). |
| System Provider (SP) | Governance of the system chains. Can add node to the system cluster. |
| Node Provider (NP) | Can add block builder nodes. |

Providers together decide on events on the network. Voter sets contain the list of providers that can vote on proposals,
and all the significant changes are done by voting.

A system provider can do some operations directly on the network, such as creating a cluster, but considerable changes
require consensus by voting. For example, providers can upgrade a node provider to a system provider if a super-majority
(greater than or equal to â…”) of providers vote in favor of the proposal to approve it.

Providers have two types of key pairs. The first is the provider key pair, which providers use to sign transactions and
proposals on the network. The second is the node key pair, which the consensus algorithm uses to sign blocks between its
peers. All the nodes in the network have their unique key pair.

info

To manage nodes, you need to install Postchain Management Console (PMC) CLI. For information about installing PMC CLI,
see [Install the PMC CLI](/providers/pmc/cli/pmccli-installation) topic.[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Providers receive compensation from a pool of all fees paid by dapps for containers on the network. The compensation a
Provider receives is calculated based on several parameters, such as the number of SCUs contributed to the network, node
uptime, and provider role (system provider or node provider). The reward calculation formula can be updated by a
proposal as the network evolves and the optimal balance of parameters changes.

## Provider reward estimator

Total number of dapp clusters in the network1

Number of 64 SCU system nodes that you host1

Number of 128 SCU dapp nodes that you host1

Average occupancy rate of dapp clusters30%

Average up-time of your nodes99%

Weekly reward for system nodes (USD):$670.55

Weekly reward for dapp nodes (USD):$793.89

Total weekly reward (USD):$1,464.44

## System cluster provider rewards [â€‹](\#system-cluster-provider-rewards "Direct link to System cluster provider rewards")

Chromia provides a performance-based reward system for system cluster nodes. It considers factors like the total cost of
running the system, risk sharing between providers and the system, and individual node uptime.

Here's the formula for system provider reward per node:

```codeBlockLines_e6Vv
System Provider Reward per Node = max {
  (Total System Providers Cost * (1 - System Provider Risk Share)) +
  (System Provider Revenue Share per Node * System Provider Risk Share),
  System Provider Revenue Share per Node
} * Availability Factor

```

#### Explanation of the formula: [â€‹](\#explanation-of-the-formula "Direct link to Explanation of the formula:")

- `Total System Providers Cost`: This represents an estimate of the costs incurred by a system provider in hosting a
single system node.
- `System Provider Risk Share`: This value (between 0 and 1) adjusts the financial risk taken by system providers. The
value is currently set at 0.1, meaning that system providers are guaranteed to make at least 90% of their costs back,
adjusted down depending on their node's uptime.
- `System Provider Revenue Share per Node`: This represent the share of total revenues from dapp hosting fees allocated
as rewards to system providers for each node in the system cluster. It's calculated from the total revenue potential
of all dapp clusters on the network, multiplied by the system provider fee share (currently 0.1), divided by the
number of nodes in the system cluster.
- `Availability Factor`: This value (between 0 and 1) reflects the individual node's uptime or availability during the
reward period. Nodes with higher availability receive a higher reward. An uptime of 90% results in an availability
factor of 0, and an uptime of 100% results in an availability factor of 1. In other words, an uptime higher than 90%
results in rewards.
- `max { ... }`: This function ensures that the final reward per node is the greater value between the two calculations
within the curly braces.

## Dapp cluster provider rewards [â€‹](\#dapp-cluster-provider-rewards "Direct link to Dapp cluster provider rewards")

Chromia provides a performance-based reward system for dapp cluster nodes. Similar to the system cluster rewards, it
considers factors like the cluster's value and node availability to determine individual node rewards.

Here's the formula for dapp provider reward per node:

```codeBlockLines_e6Vv
Dapp Provider Reward per Node =
( (Dapp Cluster Value * (1 - Dapp Provider Risk Share)) +
  (Dapp Cluster Value * Occupancy Rate * Dapp Provider Risk Share) )
/ Number of Nodes in Dapp Cluster
* Availability Factor

```

#### Explanation of the formula: [â€‹](\#explanation-of-the-formula-1 "Direct link to Explanation of the formula:")

- `Dapp Cluster Value`: This represents the value of a dapp cluster, based on the total revenue it can generate from
dapp hosting fees at full utilization after accounting for fee shares with system providers, staking rewards, and the
system itself.
- `Dapp Provider Risk Share`: This value (between 0 and 1) adjusts the financial risk taken by dapp providers. The value
is currently set at 0.2, meaning that dapp providers are guaranteed to make at least 80% of the potential max revenue
of a cluster, adjusted down depending on their node's uptime.
- `Occupancy Rate`: This value (between 0 and 1) reflects the percentage of Standard Containers Units (SCUs) leased by
dapps within the dapp cluster. A higher occupancy rate suggests the cluster is being more actively used.
- `Number of Nodes in Dapp Cluster`: This represents the total number of nodes participating in the specific dapp
cluster.
- `Availability Factor`: This value (between 0 and 1) reflects the individual node's uptime or availability during the
reward period. Nodes with higher availability receive a larger reward. An uptime of 90% results in an availability
factor of 0, and an uptime of 100% results in an availability factor of 1. In other words, an uptime higher than 90%
results in rewards.

- [System cluster provider rewards](#system-cluster-provider-rewards)
- [Dapp cluster provider rewards](#dapp-cluster-provider-rewards)[Skip to main content](#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

This guide will walk you through obtaining test tokens (tCHR) on the Chromia testnet. These tokens are essential for
testing deployments and experimenting with Chromia's features without using real tokens.

## Step 1: Access the Chromia testnet faucet [â€‹](\#step-1-access-the-chromia-testnet-faucet "Direct link to Step 1: Access the Chromia testnet faucet")

To obtain tCHR, visit the [Chromia Testnet Faucet](https://faucet.testnet.chromia.com/).

## Step 2: Connect your wallet [â€‹](\#step-2-connect-your-wallet "Direct link to Step 2: Connect your wallet")

1. On the faucet page, click **Connect Wallet**.
2. Choose your wallet provider (e.g., MetaMask or Coinbase Wallet).
3. Follow the prompts to authorize the connection.

## Step 3: Request tCHR tokens [â€‹](\#step-3-request-tchr-tokens "Direct link to Step 3: Request tCHR tokens")

1. Once your wallet is connected, click **Request Tokens** on the faucet page.
2. Complete the CAPTCHA if prompted.
3. If you donâ€™t have a Chromia account yet, youâ€™ll see an option to create one. Click **Create Account** and follow the
instructions to set up your Chromia account.
4. If you just created an account, click **Request Tokens** again.
5. You will then be prompted to sign a message in MetaMask to authorize the token request. This is a cryptographic
signature, verifying that youâ€™re the account owner without any gas fees, as it only performs a mathematical
calculation on your device.

Once the tokens are successfully requested, they should appear in your wallet on the testnet.

## Step 4: View tokens in the Vault [â€‹](\#step-4-view-tokens-in-the-vault "Direct link to Step 4: View tokens in the Vault")

You can view your tCHR tokens and account balance by clicking **View my account in Vault**. Alternatively, visit the
[Economy Chain](https://vault.testnet.chromia.com/en/dapps/dapp/?dapp=1-Chromia+Economy+Chain) in the Vault directly,
where your account is located.

## Usage notes [â€‹](\#usage-notes "Direct link to Usage notes")

- **Purpose**: tCHR tokens are for testing on the Chromia testnet and have no real-world value.
- **Resetting balance**: If you need additional tokens, you can revisit the faucet periodically to request more.

By following these steps, youâ€™ll have tCHR available for any testnet actions, including deploying a dapp or
experimenting with token transfers.

- [Step 1: Access the Chromia testnet faucet](#step-1-access-the-chromia-testnet-faucet)
- [Step 2: Connect your wallet](#step-2-connect-your-wallet)
- [Step 3: Request tCHR tokens](#step-3-request-tchr-tokens)
- [Step 4: View tokens in the Vault](#step-4-view-tokens-in-the-vault)
- [Usage notes](#usage-notes)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

`rell.test` namespace provides types and functions for creating, manipulating, and executing test blocks and
transactions, as well as asserting their expected behavior.

## Test block, transaction, and operation types [â€‹](\#test-block-transaction-and-operation-types "Direct link to Test block, transaction, and operation types")

- [`rell.test.block`](/rell/tests/namespace/block): Represents a Rell block for testing purposes.
- [`rell.test.tx`](/rell/tests/namespace/tx): Represents a Rell transaction for testing purposes.
- [`rell.test.op`](/rell/tests/namespace/op): Represents a Rell operation within a transaction for testing purposes.

## Structures [â€‹](\#structures "Direct link to Structures")

### `rell.test.keypair` [â€‹](\#relltestkeypair "Direct link to relltestkeypair")

A struct containing a public and private keypair for signing transactions with.

#### `constuctor(pub: byte_array, priv: byte_array)` [â€‹](\#constuctorpub-byte_array-priv-byte_array "Direct link to constuctorpub-byte_array-priv-byte_array")

#### Properties [â€‹](\#properties "Direct link to Properties")

- `val pub: byte_array` \- the public key of this keypair
- `val priv: byte_array` \- the private key of this keypair

## Constants [â€‹](\#constants "Direct link to Constants")

### `rell.test.keypairs` [â€‹](\#relltestkeypairs "Direct link to relltestkeypairs")

The test framework contains the following predefined `rell.test.keypair`:

`rell.test.keypairs.{bob, alice, trudy, charlie, dave, eve, frank, grace, heidi}: rell.test.keypair`

### `rell.test.pubkeys` [â€‹](\#relltestpubkeys "Direct link to relltestpubkeys")

The test framework contains the following predefined public keys:

`rell.test.pubkeys.{bob, alice, trudy, charlie, dave, eve, frank, grace, heidi}: byte_array`

### `rell.test.privkeys` [â€‹](\#relltestprivkeys "Direct link to relltestprivkeys")

The test framework contains the following predefined private keys:

`rell.test.privkeys.{bob, alice, trudy, charlie, dave, eve, frank, grace, heidi}: byte_array`

### `rell.test.DEFAULT_FIRST_BLOCK_TIME: timestamp` [â€‹](\#relltestdefault_first_block_time-timestamp "Direct link to relltestdefault_first_block_time-timestamp")

The default first block time (2020-01-01 00:00:00 UTC).

### `rell.test.DEFAULT_BLOCK_INTERVAL: timestamp` [â€‹](\#relltestdefault_block_interval-timestamp "Direct link to relltestdefault_block_interval-timestamp")

The default block interval (10 seconds).

### `rell.test.BLOCKCHAIN_SIGNER_KEYPAIR: rell.test.keypair` [â€‹](\#relltestblockchain_signer_keypair-relltestkeypair "Direct link to relltestblockchain_signer_keypair-relltestkeypair")

The node keypair that signs all blocks within the test framework Defined as

```codeBlockLines_e6Vv
rell.test.keypair(
    priv = x'4242424242424242424242424242424242424242424242424242424242424242',
    pub = x'0324653eac434488002cc06bbfb7f10fe18991e35f9fe4302dbea6d2353dc0ab1c'
)

```

## Properties [â€‹](\#properties-1 "Direct link to Properties")

### `rell.test.last_block_time: timestamp` [â€‹](\#relltestlast_block_time-timestamp "Direct link to relltestlast_block_time-timestamp")

Returns the last block time

### `rell.test.last_block_time_or_null: timestamp?` [â€‹](\#relltestlast_block_time_or_null-timestamp "Direct link to relltestlast_block_time_or_null-timestamp")

Returns the last block time or null if it's not set.

### `rell.test.next_block_time: timestamp` [â€‹](\#relltestnext_block_time-timestamp "Direct link to relltestnext_block_time-timestamp")

Returns the next block time.

### `rell.test.block_interval: timestamp` [â€‹](\#relltestblock_interval-timestamp "Direct link to relltestblock_interval-timestamp")

Returns the block interval.

## Functions [â€‹](\#functions "Direct link to Functions")

### `function rell.test.set_block_interval(interval: integer): integer` [â€‹](\#function-relltestset_block_intervalinterval-integer-integer "Direct link to function-relltestset_block_intervalinterval-integer-integer")

Sets the block interval and returns the previous interval.

### `function rell.test.set_next_block_time(time: timestamp): unit` [â€‹](\#function-relltestset_next_block_timetime-timestamp-unit "Direct link to function-relltestset_next_block_timetime-timestamp-unit")

Sets the next block time directly.

### `function rell.test.set_next_block_time_delta(delta: integer): unit` [â€‹](\#function-relltestset_next_block_time_deltadelta-integer-unit "Direct link to function-relltestset_next_block_time_deltadelta-integer-unit")

Sets the next block time by adding a delta to the last block time.

### `function rell.test.nop(): rell.test.op` [â€‹](\#function-relltestnop-relltestop "Direct link to function-relltestnop-relltestop")

Creates a No-op operation. Useful for ensuring uniqueness of a transaction

**Parameters:**

- `nonce` \- Optional parameter. Can be an `integer`, `byte_array` or `text`

**Returns:**

- `rell.test.op` \- Corresponding to this nop.

- [Test block, transaction, and operation types](#test-block-transaction-and-operation-types)
- [Structures](#structures)
  - [`rell.test.keypair`](#relltestkeypair)
- [Constants](#constants)
  - [`rell.test.keypairs`](#relltestkeypairs)
  - [`rell.test.pubkeys`](#relltestpubkeys)
  - [`rell.test.privkeys`](#relltestprivkeys)
  - [`rell.test.DEFAULT_FIRST_BLOCK_TIME: timestamp`](#relltestdefault_first_block_time-timestamp)
  - [`rell.test.DEFAULT_BLOCK_INTERVAL: timestamp`](#relltestdefault_block_interval-timestamp)
  - [`rell.test.BLOCKCHAIN_SIGNER_KEYPAIR: rell.test.keypair`](#relltestblockchain_signer_keypair-relltestkeypair)
- [Properties](#properties-1)
  - [`rell.test.last_block_time: timestamp`](#relltestlast_block_time-timestamp)
  - [`rell.test.last_block_time_or_null: timestamp?`](#relltestlast_block_time_or_null-timestamp)
  - [`rell.test.next_block_time: timestamp`](#relltestnext_block_time-timestamp)
  - [`rell.test.block_interval: timestamp`](#relltestblock_interval-timestamp)
- [Functions](#functions)
  - [`function rell.test.set_block_interval(interval: integer): integer`](#function-relltestset_block_intervalinterval-integer-integer)
  - [`function rell.test.set_next_block_time(time: timestamp): unit`](#function-relltestset_next_block_timetime-timestamp-unit)
  - [`function rell.test.set_next_block_time_delta(delta: integer): unit`](#function-relltestset_next_block_time_deltadelta-integer-unit)
  - [`function rell.test.nop(): rell.test.op`](#function-relltestnop-relltestop)[Skip to main content](#__docusaurus_skipToContent_fallback)

```codeBlockLines_e6Vv
Usage: pmc keygen [OPTIONS]

  Generates public/private key pair

â•­â”€ Options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  -m, --mnemonic=TEXT  Mnemonic word list, words separated by space, e.g:    â”‚
â”‚                       "lift employ roast rotate liar holiday sun fever      â”‚
â”‚                       output magnet...""                                    â”‚
â”‚  -s, --save=PATH      File to save the generated keypair in                 â”‚
â”‚  -n, --node           Save the generated keypair in format to be included inâ”‚
â”‚                       node properties file                                  â”‚
â”‚  -h, --help           Show this message and exit                            â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

```

The keygen command ( `pmc keygen`) generates a public and private key pair. An elliptic curve `secp256k1` generates these
keys.

- Saves the key pair in a file named `.secret`.

```codeBlockLines_e6Vv
pmc keygen --save .secret

```

- Generates a key pair from a mnemonic phrase and saves it to a file named `.secret`.

```codeBlockLines_e6Vv
pmc keygen --save .secret --mnemonic "march aspect beef treat ..."

```

- Generates a keypair that PMC uses when commands are executed from this directory.

```codeBlockLines_e6Vv
pmc keygen --save .pmc/config

```

- Generates a keypair that PMC uses when commands are executed from this host (global config).

```codeBlockLines_e6Vv
pmc keygen --save ~/.pmc/config

```[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

This topic contains instructions to install and update the
[Chromia CLI](https://gitlab.com/chromaway/core-tools/chromia-cli).

## Prerequisite [â€‹](\#prerequisite "Direct link to Prerequisite")

Before proceeding, make sure the following prerequisites are met:

- **PostgreSQL database**: See [Set up PostgreSQL database](/intro/installation/database-setup).
- **RELL\_JAVA environment**: Chromia CLI do requries a java runtime (version 21 or later) to execute. Through the
different package managers this has been abstracted away for you so you don't need to set this up. If you want to
control which java runtime you use to execute Chromia CLI with it is recomended to set RELL\_JAVA variable in your
environment to point to a valid Java installation

## Installation [â€‹](\#installation "Direct link to Installation")

You can install Chromia CLI using a package manager or by downloading it directly from
[Chromia CLI Packages](https://gitlab.com/chromaway/core-tools/chromia-cli/-/packages).

- macOS
- Linux/WSL
- Windows

To install Chromia CLI ( `chr`) on macOS, follow these steps:

1. If Homebrew is not installed, install it by running:





```codeBlockLines_e6Vv
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

```

2. Add the Chromia repository to Homebrew by running the following command:





```codeBlockLines_e6Vv
brew tap chromia/core https://gitlab.com/chromaway/core-tools/homebrew-chromia.git

```

3. Install Chromia CLI with:





```codeBlockLines_e6Vv
brew install chromia/core/chr

```











info





To install a specific version of Chromia CLI, use the following commands:







```codeBlockLines_e6Vv
brew install chromia/core/chr@<version>
brew unlink chr
brew link chr@<version>

```











You can list available versions using: `brew search chr`.

4. To verify the installation, check the version by running:





```codeBlockLines_e6Vv
chr --version

```


To install Chromia CLI ( `chr`) on Linux or WSL (Windows Subsystem for Linux), follow these steps:

1. Download and add Chromia's `apt-repo` public key to your systemâ€™s trusted keyrings:





```codeBlockLines_e6Vv
curl -fsSL https://apt.chromia.com/chromia.gpg | sudo tee /usr/share/keyrings/chromia.gpg

```

2. Add the Chromia repository to your list of package sources:





```codeBlockLines_e6Vv
echo "deb [arch=amd64 signed-by=/usr/share/keyrings/chromia.gpg] https://apt.chromia.com stable main" | sudo tee /etc/apt/sources.list.d/chromia.list

```

3. Run the following command to update your package sources:





```codeBlockLines_e6Vv
sudo apt-get update

```











info





If you added `apt.chromia.com` before Chromia CLI version `0.16.0`, run the following command to allow the repository
update:







```codeBlockLines_e6Vv
sudo apt-get --allow-releaseinfo-change update

```

4. Once the repository is updated, install Chromia CLI by running:





```codeBlockLines_e6Vv
sudo apt-get install chr

```

5. To verify that Chromia CLI is installed successfully, check the version:





```codeBlockLines_e6Vv
chr --version

```


To install Chromia CLI ( `chr`) on Windows using [Scoop](https://scoop.sh/), follow these steps:

1. If Scoop is not installed, install it by running the following command in PowerShell (run as Administrator):





```codeBlockLines_e6Vv
iwr -useb get.scoop.sh | iex

```

2. Add the Chromia repository (bucket) to Scoop by running:





```codeBlockLines_e6Vv
scoop bucket add chromia https://gitlab.com/chromaway/core-tools/scoop-chromia/

```

3. Add the Java bucket to Scoop by running:





```codeBlockLines_e6Vv
scoop bucket add java

```









This will enable scoop to download the openjdk21 which chromia-cli depends on when installing

4. Install Chromia CLI by running:





```codeBlockLines_e6Vv
scoop install chr

```

5. To verify that Chromia CLI is installed successfully, check the version:





```codeBlockLines_e6Vv
chr --version

```


## Updating Chromia CLI [â€‹](\#updating-chromia-cli "Direct link to Updating Chromia CLI")

You can download and install the latest Chromia CLI from
[here](https://gitlab.com/chromaway/core-tools/chromia-cli/-/packages), or if you have installed the Chromia CLI via a
package manager, you can update it with the following:

- macOS
- Linux
- Windows

```codeBlockLines_e6Vv
brew update
brew upgrade chr

```

```codeBlockLines_e6Vv
sudo apt-get update
sudo apt-get install chr

```

```codeBlockLines_e6Vv
scoop update
scoop update chr

```

## Docker [â€‹](\#docker "Direct link to Docker")

Docker can run a standalone Linux container with the Chromia CLI pre-installed. Make sure that you have set up the
[PostgreSQL database](/intro/installation/database-setup).

To use the published Docker images, you must first have Docker installed and configured on your host machine. Please
refer to the Docker documentation on how to [install Docker](https://docs.docker.com/get-docker/) on Windows, Mac, and
Linux.

### Start the Docker container with Chromia CLI pre-installed [â€‹](\#start-the-docker-container-with-chromia-cli-pre-installed "Direct link to Start the Docker container with Chromia CLI pre-installed")

To run the latest version of the Chromia CLI, use the `docker run` command and specify the CLI Docker image name and
`chr`.

```codeBlockLines_e6Vv
docker run --rm -v $(pwd):/usr/app registry.gitlab.com/chromaway/core-tools/chromia-cli/chr:<latest version> chr

```

note

Make sure to configure your `chromia.yml` file correctly:

- **Mac**: Use `host.docker.internal` for `database:host`.
- **Windows**: Set `database:host` to `172.17.0.1`.
- **Linux**: Use the `--network=host` argument in Docker commands.

These configurations are crucial to ensure connectivity between Chromia CLI and the PostgreSQL instance.

See the [Docker command line reference](https://docs.docker.com/engine/reference/commandline/docker/) for more
information on updating or uninstalling the Docker image.

```codeBlockLines_e6Vv
#!/bin/bash

# Allocate a pseudo-TTY one when run in interactive mode
if [ -t 0 ] && [ -t 1 ] ; then TTY="--tty"; else TTY=""; fi

docker run \
  # Sets the network to host to not need to change the database hostname (linux only)
  --network=host \
  # Set timezone based on system settings (linux only)
  -e TZ=$(cat /etc/timezone) \
  # Sets process ownership to current user
  --user $(id -u):$(id -g) \
  --mount type=bind,source="/etc/passwd",target=/etc/passwd,readonly \
  --mount type=bind,source="/etc/group",target=/etc/group,readonly \
  # Configures ssh-agent (only needed if chr install is called on non-public repositores)
  -e SSH_AUTH_SOCK=$SSH_AUTH_SOCK \
  --volume "$SSH_AUTH_SOCK:$SSH_AUTH_SOCK" \
  --mount type=bind,source="${HOME}/.ssh",target=${HOME}/.ssh,readonly \
  --mount type=bind,source="${HOME}/.config/jgit",target=${HOME}/.config/jgit \
  # Mounts current folder into the container (Use `Get-Location` on PowerShell)
  --mount type=bind,source="$(pwd)",target=/usr/app \
  --interactive ${TTY} \
  --rm \
  registry.gitlab.com/chromaway/core-tools/chromia-cli/chr:${CHR_VERSION:-latest} chr "$@"

```

- [Prerequisite](#prerequisite)
- [Installation](#installation)
- [Updating Chromia CLI](#updating-chromia-cli)
- [Docker](#docker)
  - [Start the Docker container with Chromia CLI pre-installed](#start-the-docker-container-with-chromia-cli-pre-installed)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

`rell.test.block` type provides methods for creating and executing test blocks within the Rell testing framework.

- [Constructors](#constructors)
  - [`rell.test.block()`](#relltestblock-1)
  - [`rell.test.block(tx: rell.test.tx...)`](#relltestblocktx-relltesttx)
  - [`rell.test.block(txs: list<rell.test.tx>)`](#relltestblocktxs-listrelltesttx)
  - [`rell.test.block(op: rell.test.op...)`](#relltestblockop-relltestop)
  - [`rell.test.block(ops: list<rell.test.op>)`](#relltestblockops-listrelltestop)
- [Functions](#functions)
  - [`function tx(tx: rell.test.tx...)`](#function-txtx-relltesttx)
  - [`function tx(txs: list<rell.test.tx>)`](#function-txtxs-listrelltesttx)
  - [`function tx(op: rell.test.op...)`](#function-txop-relltestop)
  - [`function tx(ops: list<rell.test.op>)`](#function-txops-listrelltestop)
  - [`function copy(): rell.test.block`](#function-copy-relltestblock)
  - [`function run(): void`](#function-run-void)
  - [`function run_must_fail(expected: text? = null): rell.test.failure`](#function-run_must_failexpected-text--null-relltestfailure)

When a block is executed, its timestamp is determined by the following rules:

1. If the block timestamp was explicitly set to a specific value using the `rell.test.set_next_block_time()` function,
that specified value is utilized for the current block, and it is then discarded. Subsequent blocks will not use this
specified value.
2. If no specific timestamp is set, and there is a previous block, the new timestamp is calculated by adding the block
interval to the timestamp of the last block.
3. If no specific timestamp is set, and there is no previous block, the timestamp defaults to 2020-01-01 00:00:00 UTC.

#### Example [â€‹](\#example "Direct link to Example")

Here's a simple example of building and running a test block:

```codeBlockLines_e6Vv
operation foo(x: integer) { ... }
operation bar(s: text) { ... }

...

val tx1 = rell.test.block(foo(123), bar('ABC'))
    .sign(rell.test.keypairs.bob)           // signing with the "Bob" test keypair
    ;

val tx2 = rell.test.block(bar('XYZ'))
    .sign(rell.test.keypairs.bob)
    .sign(rell.test.keypairs.alice)         // tx2 is signed with both "Bob" and "Alice" keypairs
    ;

rell.test.block()
    .tx(tx1)
    .tx(tx2)
    .run()                                  // execute the block consisting of two transactions: tx1 and tx2
    ;

```

## Constructors [â€‹](\#constructors "Direct link to Constructors")

### `rell.test.block()` [â€‹](\#relltestblock-1 "Direct link to relltestblock-1")

Creates an empty block builder.

**Parameters:**

- None

**Returns:**

- An empty block builder object.

### `rell.test.block(tx: rell.test.tx...)` [â€‹](\#relltestblocktx-relltesttx "Direct link to relltestblocktx-relltesttx")

Creates a block builder with the specified transactions.

**Parameters:**

- `tx: rell.test.tx...` \- One or more test transactions to include in the block.

**Returns:**

- A block builder object containing the specified transactions.

### `rell.test.block(txs: list<rell.test.tx>)` [â€‹](\#relltestblocktxs-listrelltesttx "Direct link to relltestblocktxs-listrelltesttx")

Creates a block builder with the specified list of transactions.

**Parameters:**

- `txs: list<rell.test.tx>` \- A list of test transactions to include in the block.

**Returns:**

- A block builder object containing the specified list of transactions.

### `rell.test.block(op: rell.test.op...)` [â€‹](\#relltestblockop-relltestop "Direct link to relltestblockop-relltestop")

Creates a block builder with one transaction containing the specified operations.

**Parameters:**

- `op: rell.test.op` \- One or more test operations to include in a single transaction within the block.

**Returns:**

- A block builder object containing one transaction with the specified operations.

### `rell.test.block(ops: list<rell.test.op>)` [â€‹](\#relltestblockops-listrelltestop "Direct link to relltestblockops-listrelltestop")

Creates a block builder with one transaction containing the specified list of operations.

**Parameters:**

- `ops: list<rell.test.op>` \- A list of test operations to include in a single transaction within the block.

**Returns:**

- A block builder object containing one transaction with the specified list of operations.

## Functions [â€‹](\#functions "Direct link to Functions")

### `function tx(tx: rell.test.tx...)` [â€‹](\#function-txtx-relltesttx "Direct link to function-txtx-relltesttx")

Adds the specified transactions to the block.

**Parameters:**

- `tx: rell.test.tx...` \- One or more test transactions to add to the block.

**Returns:**

- The block builder object (allowing for method chaining).

### `function tx(txs: list<rell.test.tx>)` [â€‹](\#function-txtxs-listrelltesttx "Direct link to function-txtxs-listrelltesttx")

Adds the specified list of transactions to the block.

**Parameters:**

- `txs: list<rell.test.tx>` \- A list of test transactions to add to the block.

**Returns:**

- The block builder object (allowing for method chaining).

### `function tx(op: rell.test.op...)` [â€‹](\#function-txop-relltestop "Direct link to function-txop-relltestop")

Adds one transaction containing the specified operations to the block.

**Parameters:**

- `op: rell.test.op...` \- One or more test operations to include in the transaction.

**Returns:**

- The block builder object (allowing for method chaining).

### `function tx(ops: list<rell.test.op>)` [â€‹](\#function-txops-listrelltestop "Direct link to function-txops-listrelltestop")

Adds one transaction containing the specified list of operations to the block.

**Parameters:**

- `ops: list<rell.test.op>` \- A list of test operations to add to the block.

**Returns:**

- The block builder object (allowing for method chaining).

### `function copy(): rell.test.block` [â€‹](\#function-copy-relltestblock "Direct link to function-copy-relltestblock")

Returns a copy of this block builder object.

**Parameters:**

- None

**Returns:**

- A copy of the block builder object.

### `function run(): void` [â€‹](\#function-run-void "Direct link to function-run-void")

Runs the block.

**Parameters:**

- None

**Returns:**

- Nothing.

### `function run_must_fail(expected: text? = null): rell.test.failure` [â€‹](\#function-run_must_failexpected-text--null-relltestfailure "Direct link to function-run_must_failexpected-text--null-relltestfailure")

Runs this block and expects it to fail. If an expected message is passed, it will pass only if the failure message
contains the expected message. Throws an exception on success, not on failure.

**Parameters:**

- `expected` (optional): Text indicating the expected error message.

**Returns:**

- A `rell.test.failure` object if the block fails as expected. Throws an exception if the block succeeds unexpectedly.

#### Example [â€‹](\#example-1 "Direct link to Example")

```codeBlockLines_e6Vv
operation will_fail_sometimes(will_fail: booelan) {
    require(!will_fail, "This operation has failed");
}

function test_fails() {
    val block = rell.test.block(will_fail_sometimes(true));
    block.run_must_fail();
    block.run_must_fail("has failed");
}

```

- [Constructors](#constructors)
  - [`rell.test.block()`](#relltestblock-1)
  - [`rell.test.block(tx: rell.test.tx...)`](#relltestblocktx-relltesttx)
  - [`rell.test.block(txs: list<rell.test.tx>)`](#relltestblocktxs-listrelltesttx)
  - [`rell.test.block(op: rell.test.op...)`](#relltestblockop-relltestop)
  - [`rell.test.block(ops: list<rell.test.op>)`](#relltestblockops-listrelltestop)
- [Functions](#functions)
  - [`function tx(tx: rell.test.tx...)`](#function-txtx-relltesttx)
  - [`function tx(txs: list<rell.test.tx>)`](#function-txtxs-listrelltesttx)
  - [`function tx(op: rell.test.op...)`](#function-txop-relltestop)
  - [`function tx(ops: list<rell.test.op>)`](#function-txops-listrelltestop)
  - [`function copy(): rell.test.block`](#function-copy-relltestblock)
  - [`function run(): void`](#function-run-void)
  - [`function run_must_fail(expected: text? = null): rell.test.failure`](#function-run_must_failexpected-text--null-relltestfailure)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

This topic provides information about the architecture that's designed to facilitate the seamless transfer of FT4 assets
across multiple chains within the Chromia blockchain platform. It is the foundation for enabling cross-chain asset
movements and handling internally and externally minted assets, orchestrating the entire transfer process from asset
registration to finalization.

## Definitions [â€‹](\#definitions "Direct link to Definitions")

To fully understand the architecture, here are some key definitions and concepts:

- **Internal assets**: Assets that are minted directly on the local chain.
- **External assets**: Assets used within the local chain but minted on a different chain.
- **Origin chain**: The specific chain from which an asset can be received. This may or may not be the same as the
issuing chain.
- **Issuing chain**: The chain where an asset is initially minted.

### Registration of assets [â€‹](\#registration-of-assets "Direct link to Registration of assets")

To start a cross-chain asset transfer, you must first complete asset registration on both the sending and receiving
chains. When you register external assets, specifying the origin chain is crucial.

For example, if asset "X" mints on chain A, chain A is the **issuing chain** for asset X. You can only mint asset X on
its issuing chain, A.

If you need to use asset X on chain B, chain B must register asset X and specify that chain A is the **origin chain**.

Once you complete this registration process, chains A and B can freely exchange asset X.

BABAB owns 0 asset XB owns someasset Xmint X1register Xorigin: A2transfer X3

## Asset tree structure [â€‹](\#asset-tree-structure "Direct link to Asset tree structure")

When chains register assets they become interconnected, resulting in a tree-like connection structure that outlines the
flow of an asset across the network. This structure features a root (the issuing chain) and leaves (receiving chains).

**Example 1:**

1. In this example, both chains B and C have registered an asset, with chain A set as the origin chain. Therefore, if
chain B wants to transfer an asset to chain C, it must first send the asset to chain A, which will then route it to
chain C.

origin

origin

A

B

C

The following diagram illustrates two possible transfer scenarios:

CBACBAA and B already own asset Xtransfer from A to Ctransfer from B to Cregister Xorigin: A1transfer Xsource: A2transfer Xtarget: C3transfer Xsource: B4

**Example 2:**

2. Suppose chain C wants to transfer an asset to chain D. Chain C has registered the asset with chain A, which is the
issuing chain. Chain D has registered its asset with chain B, and chain B has also registered with chain A.
Therefore, when C initiates the transfer to D, the asset is routed in this sequence: C -> A -> B -> D.

origin

origin

origin

A

B

D

C

The diagram provided below highlights two possible transfer scenarios where: B transfers an asset to C, and C transfers
an asset to D:

CABDCABDA, B and D already own asset Xtransfer from B to Ctransfer from C to Dregister Xorigin: A1transfer Xtarget: C2transfer Xsource: B3transfer Xtarget: D4transfer Xtarget: D5transfer Xsource: C6

**Example 3:**

3. The following example illustrates the structure where element B serves as the connecting node between C and A.
Consequently, when A wants to transfer an asset to C, the transfer must pass through B, which then routes it to C.

origin

origin

B

A

C

Below you can find the process of the asset transfer from A to C:

CBACBAA and B already own asset Xtransfer from A to Cregister Xorigin: B1transfer Xtarget: C2transfer Xsource: A3

## Validating origin chains [â€‹](\#validating-origin-chains "Direct link to Validating origin chains")

The registration of any asset is a self-contained process, meaning that the origin chain is not notified about the
registration on the source chain. Therefore, there is no way to verify whether the origin chain has ever registered the
asset with the issuing chain.

For example, if chain A mints asset X and chain B lists A as its origin, and a new chain, C, wants to use asset X by
registering it with chain Z as its origin, problems arise if Z has not registered asset X. In this case, when chain B
attempts to send asset X to chain C, no connection path between the two chains is found, resulting in the transfer
failing.

origin

origin

B

A

C

Z

warning

Selecting trustworthy origin chains is crucial, as malicious or misconfigured chains could result in the user token
being lost or stolen.

## Operations in cross-chain transfers [â€‹](\#operations-in-cross-chain-transfers "Direct link to Operations in cross-chain transfers")

Cross-chain transfers involve three fundamental operations:

1. **init\_transfer**: Initiated on the source chain.
2. **apply\_transfer**: Executed on all intermediate and target chains.
3. **complete\_transfer**: Finalizes the transfer back on the source chain.

NO

YES

Find Path

init\_transfer

Wait Until Block Anchored

Get Proof

apply\_transfer

Get Proof

Is Last Hop?

(Is Target Chain?)

complete\_transfer

The direction of asset flow determines whether assets are locked, minted, unlocked, or burned during the process.

## Anchoring and ICCF [â€‹](\#anchoring-and-iccf "Direct link to Anchoring and ICCF")

After the initial transfer, the following chain must verify the previous transaction's inclusion in a block. This
verification process relies on the ICCF (Interchain Confirmation Facility) mechanism, which uses anchoring chains for
proof verification. For a deeper understanding of ICCF, refer to the
[Interchain Confirmation Facility](/intro/cross-chain/iccf) topic.

# Cross-Chain Transfer Operations

## List of Operations [â€‹](\#list-of-operations "Direct link to List of Operations")

1. [init\_transfer](#1-init_transfer)
2. [apply\_transfer](#2-apply_transfer)
3. [cancel\_transfer](#3-cancel_transfer)
4. [unapply\_transfer](#4-unapply_transfer)

### 1\. `init_transfer` [â€‹](\#1-init_transfer "Direct link to 1-init_transfer")

**Description**: Initializes a cross-chain transfer, creating a record in the system and setting up the necessary data
for later steps in the transfer process.

#### Parameters: [â€‹](\#parameters "Direct link to Parameters:")

- `asset_id`: ID of the asset to be transferred.
- `amount`: Amount of the asset to be transferred.
- `destination`: The destination blockchain and account where the asset will be sent.
- `hops`: Array of blockchains this transfer must go through.
- `deadline`: Expiration time of the transfer, after which it can be canceled.

#### Notes: [â€‹](\#notes "Direct link to Notes:")

- Throws if the sender does not have enough balance.
- Throws if the destination blockchain or account is invalid.
- Throws if the hops configuration is invalid.

### 2\. `apply_transfer` [â€‹](\#2-apply_transfer "Direct link to 2-apply_transfer")

**Description**: Applies a cross-chain transfer on the receiving blockchain. This operation must be called at each step
to transfer the asset from one chain to the next until it reaches the final destination.

#### Parameters: [â€‹](\#parameters-1 "Direct link to Parameters:")

- `init_transfer_tx`: The transaction containing the `init_transfer` operation.
- `init_tx_op_index`: Index of the `init_transfer` operation in `init_transfer_tx`.
- `previous_hop_tx`: Transaction containing the `apply_transfer` operation of the previous hop.
- `op_index`: Index of the `apply_transfer` operation in `previous_hop_tx`.
- `hop_index`: The index in the hops array provided in the original transaction that this chain represents.

#### Notes: [â€‹](\#notes-1 "Direct link to Notes:")

- Throws if the transfer deadline has passed.
- Throws if the operation sequence does not match the expected order in the hops array.
- Throws if the senderâ€™s balance is insufficient.
- Throws if there is an issue with the authorization steps.

### 3\. `cancel_transfer` [â€‹](\#3-cancel_transfer "Direct link to 3-cancel_transfer")

**Description**: Cancels a cross-chain transfer that has expired. This operation must be called in place of
`apply_transfer` to start the transfer canceling process. `unapply_transfer` must then be called on all previous chains
to bring the funds back to the sender account.

#### Parameters: [â€‹](\#parameters-2 "Direct link to Parameters:")

- `init_transfer_tx`: The transaction containing the `init_transfer` operation corresponding to the transfer to cancel.
- `init_tx_op_index`: The index of the `init_transfer` operation in `init_transfer_tx`.
- `previous_hop_tx`: The transaction containing the `apply_transfer` operation of the previous hop.
- `op_index`: The index of the `apply_transfer` or `init_transfer` operation in `previous_hop_tx`.
- `hop_index`: Index in the hops array provided in the original transaction that this chain represents.

#### Notes: [â€‹](\#notes-2 "Direct link to Notes:")

- Throws if the transfer has not yet expired.
- Throws if there is a configuration error, such as mismatches in the operation indices or hop index.
- Requires an `iccf_proof` operation to demonstrate that the `apply_transfer` was performed on the previous chain.
- Anyone can call this operation with the required proof.

#### Related Operations: [â€‹](\#related-operations "Direct link to Related Operations:")

- See `core.auth.is_auth_op` for information on authorization operations.
- See `core.crosschain.applied_transfers` and `core.crosschain.canceled_transfers` for details on the cross-chain
transfer workflow.

### 4\. `unapply_transfer` [â€‹](\#4-unapply_transfer "Direct link to 4-unapply_transfer")

**Description**: Unapplies a cross-chain transfer that has expired. This operation must be called if `apply_transfer`
was already executed on this chain. It reverses the transfer on this chain and adjusts balances accordingly.

#### Parameters: [â€‹](\#parameters-3 "Direct link to Parameters:")

- `init_transfer_tx`: The transaction containing the `init_transfer` operation corresponding to the transfer to unapply.
- `init_tx_op_index`: The index of the `init_transfer` operation in `init_transfer_tx`.
- `last_tx`: The last transaction in this transfer flow, as sent to the previous hop. It must contain one of the three
supported operations ( `cancel_transfer`, `recall_unclaimed_transfer`, or `unapply_transfer`).
- `last_op_index`: The index of the supported operation in `last_tx`.
- `hop_index`: Index in the hops array provided in the original transaction that this chain represents.

#### Notes: [â€‹](\#notes-3 "Direct link to Notes:")

- Throws if the transfer was never applied, or if it was already canceled or unapplied.
- Throws for malformed inputs, such as mismatched arguments or invalid hop indices.
- Throws if the operation in `last_tx` is not one of the supported types.
- Throws if the transfer has not expired.
- Requires no authorization flags to unapply a transfer.

#### Related Operations: [â€‹](\#related-operations-1 "Direct link to Related Operations:")

- See `apply_transfer` for edge cases where this operation might throw.
- See `core.crosschain.applied_transfers`, `core.crosschain.unapplied_transfers`, `core.crosschain.canceled_transfers`,
and `core.crosschain.recalled_transfers` for information on the cross-chain transfer workflow.

## 5\. `revert_transfer` [â€‹](\#5-revert_transfer "Direct link to 5-revert_transfer")

Reverts a transfer that was initialized on this chain after it has expired. This operation is used when a cross-chain
transfer must be rolled back after expiring and the assets need to be returned to the original sender.

### Throws: [â€‹](\#throws "Direct link to Throws:")

- if:
  - The transfer was never initialized on this chain.
  - The transfer has already been reverted on this chain.
- if the input is malformed, such as:
  - Arguments in `init_transfer_tx` and `last_tx` do not match.
  - `last_tx` has not been sent to the chain that comes after this one.
- if the operation found in `last_tx` is unsupported.
- if the transfer has not expired yet.
- Throws if `init_tx_op_index` does not point to `init_transfer` in `init_transfer_tx`.
- Throws if the required assets cannot be transferred (e.g., senderâ€™s balance is lower than `amount`).

### Parameters: [â€‹](\#parameters-4 "Direct link to Parameters:")

- **`init_transfer_tx`**: The transaction containing the `init_transfer` operation corresponding to the transfer to
revert.
- **`init_tx_op_index`**: The index of the `init_transfer` operation in `init_transfer_tx`.
- **`last_tx`**: The last transaction in the transfer flow, sent to the previous hop.
- **`last_op_index`**: The index of `apply_transfer` operation in `last_tx`.

## 6\. `recall_unclaimed_transfer` [â€‹](\#6-recall_unclaimed_transfer "Direct link to 6-recall_unclaimed_transfer")

Recalls an unclaimed transfer. A cross-chain transfer does not need to be claimed unless account registration is
configured on the target chain. If the transfer reaches the target chain and the recipient account does not exist, the
transfer can be recalled.

### Throws: [â€‹](\#throws-1 "Direct link to Throws:")

- if account registration on cross-chain transfers is not allowed.
- if the transferâ€™s target chain is not the current chain.
- if the transaction has:
- Never been applied.
- Already been recalled.
- Throws if the conditions for recalling the transfer are not met.

### Parameters: [â€‹](\#parameters-5 "Direct link to Parameters:")

- **`init_transfer_tx`**: The initial transaction containing `init_transfer`, submitted to the source chain.
- **`init_tx_op_index`**: The index of the `init_transfer` operation in `init_transfer_tx`.

## 7\. `validate_apply_transfer` [â€‹](\#7-validate_apply_transfer "Direct link to 7-validate_apply_transfer")

Validates the parameters for an `apply_transfer` operation and is used by other operations that require similar
validation, such as `cancel_transfer`. It does not check whether the transfer has expired.

### Throws: [â€‹](\#throws-2 "Direct link to Throws:")

- if the transfer has already been applied, canceled, or unapplied on this chain.
- if the input is malformed, such as:
  - Arguments in `init_transfer_tx` and `previous_hop_tx` do not match.
  - `hop_index` is out of bounds.
  - `previous_hop_tx` has not been sent to the correct chain.
- if the chain at `hop_index` on the `init_transfer_tx` does not match this chain.
- Throws if `op_index` does not point to `apply_transfer`.
- Throws if `init_tx_op_index` does not point to `init_transfer` on `init_transfer_tx`.

### Parameters: [â€‹](\#parameters-6 "Direct link to Parameters:")

- **`init_transfer_tx`**: The initial transaction containing `init_transfer` submitted to the starting chain.
- **`init_tx_op_index`**: The index of the `init_transfer` operation in `init_transfer_tx`.
- **`previous_hop_tx`**: The transaction that applied the transfer on the previous chain.
- **`op_index`**: The index of the `apply_transfer` operation in `previous_hop_tx`.
- **`hop_index`**: The index of the hop in the hops array of the original transaction.

The flowchart below is describing the possible scenarios for function calls above on 3 blockchains:

Chain A

Chain C

Chain B

expired

expired

expired

if unclaimed on new account

init\_transfer

complete\_transfer

apply\_transfer

cancel\_transfer

recall\_unclaimed\_transfer

apply\_transfer

revert\_transfer

cancel\_transfer

unapply\_transfer

- [Definitions](#definitions)
  - [Registration of assets](#registration-of-assets)
- [Asset tree structure](#asset-tree-structure)
- [Validating origin chains](#validating-origin-chains)
- [Operations in cross-chain transfers](#operations-in-cross-chain-transfers)
- [Anchoring and ICCF](#anchoring-and-iccf)
- [List of Operations](#list-of-operations)
  - [1\. `init_transfer`](#1-init_transfer)
  - [2\. `apply_transfer`](#2-apply_transfer)
  - [3\. `cancel_transfer`](#3-cancel_transfer)
  - [4\. `unapply_transfer`](#4-unapply_transfer)
- [5\. `revert_transfer`](#5-revert_transfer)
  - [Throws:](#throws)
  - [Parameters:](#parameters-4)
- [6\. `recall_unclaimed_transfer`](#6-recall_unclaimed_transfer)
  - [Throws:](#throws-1)
  - [Parameters:](#parameters-5)
- [7\. `validate_apply_transfer`](#7-validate_apply_transfer)
  - [Throws:](#throws-2)
  - [Parameters:](#parameters-6)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

This section covers the advantages of [Rell](/intro/terminology#rell) and its position within the Chromia platform.

info

You can read Rell's release notes [here](https://gitlab.com/chromaway/rell/-/tree/master/doc/release-notes/).

## Rell language [â€‹](\#rell-language "Direct link to Rell language")

Most [dapp](/intro/terminology#decentralized-application-dapp) [blockchain](/intro/terminology#blockchain)
platforms use virtual machines of various kinds. But a traditional virtual machine architecture doesn't work very well
with the Chromia relational data model, as we need a way to encode queries and operations. For this reason, ChromaWay is
taking a more language-centric approach: a newly developed language called Rell (Relational language) that's used for
dapp programming. This language allows programmers to describe the data model/schema, queries, and procedural app code.

Rell code gets compiled to an intermediate binary format, which is code for a specialized virtual machine. Chromia nodes
then translate queries in this code into SQL (while ensuring this translation is safe) and execute code as needed using
an interpreter or compiler.

### Features that empower developers [â€‹](\#features-that-empower-developers "Direct link to Features that empower developers")

- **Type safety**: Rell is completely type-safe, ensuring that types returned by queries match those used in procedural
code. This minimizes errors and safeguards against financial losses.
- **Safety first**: Arithmetic operations are protected against overflows, and explicit authorization checks are
mandatory. This safety-first approach provides developers with confidence and peace of mind.
- **Concise and expressive**: Rell doesn't have the unnecessary verbosity of SQL, focusing on conveying essential
details with clarity and precision. Data definition tasks become up to 7 times more compact, boosting developer
productivity.
- **Meta-programming power**: Rell allows you to bundle features as reusable templates. This empowers you to eliminate
repetitive code and accelerate development.

Our research indicated that no existing language or environment has this feature set, and thus, the development of a new
language was necessary. We designed Rell in such a way that it's easy to learn for programmers:

- Programmers can use relational programming idioms they're already familiar with. However, they don't have to go out of
their way to express everything through relational algebra: Rell can seamlessly merge relational constructs with
procedural programming.
- The language is deliberately similar to modern programming languages like JavaScript and Kotlin. A familiar language
is easier to adapt to, and our internal tests show that programmers can become proficient in Rell in a matter of days.
In contrast, the ALGOL-style syntax of PL/SQL generally needs to be more intuitive to modern developers.

## Rell structure [â€‹](\#rell-structure "Direct link to Rell structure")

As mentioned, Rell is a language designed for relational blockchain programming. The structure of a decentralized app
built in Rell looks something like this:

![rell structure](/img/Rell_structure_LM_C.svg)

The end user communicates with the client, sending transactions to Rell using a postchain client.

info

If you want to learn Rell from the ground up, you should take the
[Rell masterclass](https://learn.chromia.com/courses/rell-masterclass/introduction).

- [Rell language](#rell-language)
  - [Features that empower developers](#features-that-empower-developers)
- [Rell structure](#rell-structure)[Skip to main content](#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.[Skip to main content](#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.[Skip to main content](#__docusaurus_skipToContent_fallback)

In Chromia, projects help you organize your Rell code and resources in a single unit that is easy to store and share. In
simple words, a project is a directory that keeps everything that makes up your dapp. A typical project normally has a
set of settings and one or several modules.

Rell modules can be composed and reused more easily than traditional smart contracts, and they can be updated without
disrupting the entire blockchain network. They can be used to define assets, manage user accounts, create custom token
economies, and implement complex business logic for dapps. They can also interact with other modules and external
systems through well-defined interfaces and APIs.

Here's a structure of a project that gets created when you run the command `chr create-rell-dapp`. It creates a new Rell
structured project with the necessary files. A `main.rell` file, which includes the `Hello World` query and test files
in the `src/test/` folder. You also have a standard configuration for your project in the `chromia.yml` file.

```codeBlockLines_e6Vv
|--chromia.yml
|--_src
   |--main.rell
   |--_test
      |--arithmetic_test.rell
      |--data_test.rell

```

You can add modules to a project as follows:

```codeBlockLines_e6Vv
|--chromia.yml
|--_src
  |--_moduleA
      |--module.rell
      |--operations.rell
      |--queries.rell
  |--_moduleB
      |--module.rell
      |--util.rell

```

note

Please note that it is not possible to have the entry point in the config of a dapp set to `module.rell`. If that's the
name of the entry then the folder name should go into the config. For example, in the above project structure, if you
want to have `moduleA` as entry point to the dapp, you need to write `moduleA` as the entry point in the `chromia.yml`
file.[Skip to main content](#__docusaurus_skipToContent_fallback)

This topic contains instructions to install the [Rell](/intro/terminology#rell) plugin for Visual Studio Code.

To install the [Rell](https://marketplace.visualstudio.com/items?itemName=ChromaWay.rell-language-extension) extension:

1. Click the **Extensions** icon in the **Activity Bar** on the side of VS Code or go to the menu **View** ->
**Extensions**.
2. Enter ' **Rell**' in the search box, and you should see the extension named Rell in the list.
3. Press the **Install** button.

![chromia architecture](/img/vs-extension_install.png)[Skip to main content](#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

`rell.test.tx` type provides methods for creating and executing test transactions within the Rell testing framework.

- [Constructors](#constructors)
  - [`rell.test.tx()`](#relltesttx-1)
  - [`rell.test.tx(op: rell.test.op...): rell.test.tx`](#relltesttxop-relltestop-relltesttx)
  - [`rell.test.tx(ops: list<rell.test.op>): rell.test.tx`](#relltesttxops-listrelltestop-relltesttx)
- [Functions](#functions)
  - [`function op(op: rell.test.op...): rell.test.tx`](#function-opop-relltestop-relltesttx)
  - [`function op(ops: list<rell.test.op>): rell.test.tx`](#function-opops-listrelltestop-relltesttx)
  - [`function nop(): rell.test.tx`](#function-nop-relltesttx)
  - [`function nop(x: integer): rell.test.tx`](#function-nopx-integer-relltesttx)
  - [`function nop(x: text): rell.test.tx`](#function-nopx-text-relltesttx)
  - [`function nop(x: byte_array): rell.test.tx`](#function-nopx-byte_array-relltesttx)
  - [`function sign(keypair: rell.test.keypair...): rell.test.tx`](#function-signkeypair-relltestkeypair-relltesttx)
  - [`function sign(keypairs: list<rell.test.keypair>): rell.test.tx`](#function-signkeypairs-listrelltestkeypair-relltesttx)
  - [`function sign(privkey: byte_array...): rell.test.tx`](#function-signprivkey-byte_array-relltesttx)
  - [`function sign(privkeys: list<byte_array>): rell.test.tx`](#function-signprivkeys-listbyte_array-relltesttx)
  - [`function copy(): rell.test.tx`](#function-copy-relltesttx)
  - [`function run(): void`](#function-run-void)
  - [`function run_must_fail(expected: text? = null): rell.test.failure`](#function-run_must_failexpected-text--null-relltestfailure)

## Constructors [â€‹](\#constructors "Direct link to Constructors")

### `rell.test.tx()` [â€‹](\#relltesttx-1 "Direct link to relltesttx-1")

Creates an empty transaction builder.

**Parameters:**

- None

**Returns:**

- An empty transaction builder object.

### `rell.test.tx(op: rell.test.op...): rell.test.tx` [â€‹](\#relltesttxop-relltestop-relltesttx "Direct link to relltesttxop-relltestop-relltesttx")

Creates a transaction builder with the specified operations.

**Parameters:**

- `op: rell.test.op` \- One or more test operations to include in the transaction.

**Returns:**

- A transaction builder object containing the specified operations.

### `rell.test.tx(ops: list<rell.test.op>): rell.test.tx` [â€‹](\#relltesttxops-listrelltestop-relltesttx "Direct link to relltesttxops-listrelltestop-relltesttx")

Creates a transaction builder with the specified list of operations.

**Parameters:**

- `ops: list<rell.test.op>` \- A list of test operations to include in the transaction.

**Returns:**

- A transaction builder object containing the specified list of operations.

## Functions [â€‹](\#functions "Direct link to Functions")

### `function op(op: rell.test.op...): rell.test.tx` [â€‹](\#function-opop-relltestop-relltesttx "Direct link to function-opop-relltestop-relltesttx")

Adds the specified operations to this transaction builder.

**Parameters:**

- `op: rell.test.op` \- One or more test operations to add to the transaction.

**Returns:**

- The transaction builder object (allowing for method chaining).

### `function op(ops: list<rell.test.op>): rell.test.tx` [â€‹](\#function-opops-listrelltestop-relltesttx "Direct link to function-opops-listrelltestop-relltesttx")

Adds the specified list of operations to this transaction builder.

**Parameters:**

- `ops: list<rell.test.op>` \- A list of test operations to add to the transaction.

**Returns:**

- The transaction builder object (allowing for method chaining).

### `function nop(): rell.test.tx` [â€‹](\#function-nop-relltesttx "Direct link to function-nop-relltesttx")

Adds a no-operation (NOP) to the transaction. Equivalent to `.op(rell.test.nop())`.

**Parameters:**

- None

**Returns:**

- The transaction builder object (adding a NOP).

### `function nop(x: integer): rell.test.tx` [â€‹](\#function-nopx-integer-relltesttx "Direct link to function-nopx-integer-relltesttx")

Adds a NOP with the specified payload to the transaction. Equivalent to `.op(rell.test.nop(x))`.

**Parameters:**

- The payload for the NOP.

**Returns:**

- The transaction builder object (adding a NOP with payload).

### `function nop(x: text): rell.test.tx` [â€‹](\#function-nopx-text-relltesttx "Direct link to function-nopx-text-relltesttx")

Adds a NOP with the specified payload to the transaction. Equivalent to `.op(rell.test.nop(x))`.

**Parameters:**

- The payload for the NOP.

**Returns:**

- The transaction builder object (adding a NOP with payload).

### `function nop(x: byte_array): rell.test.tx` [â€‹](\#function-nopx-byte_array-relltesttx "Direct link to function-nopx-byte_array-relltesttx")

Adds a NOP with the specified payload to the transaction. Equivalent to `.op(rell.test.nop(x))`.

**Parameters:**

- The payload for the NOP.

**Returns:**

- The transaction builder object (adding a NOP with payload).

### `function sign(keypair: rell.test.keypair...): rell.test.tx` [â€‹](\#function-signkeypair-relltestkeypair-relltesttx "Direct link to function-signkeypair-relltestkeypair-relltesttx")

Adds signer keypairs to the transaction.

**Parameters:**

- `keypair: rell.test.keypair` \- One or more keypairs to add as signers.

**Returns:**

- The transaction builder object (allowing for method chaining).

### `function sign(keypairs: list<rell.test.keypair>): rell.test.tx` [â€‹](\#function-signkeypairs-listrelltestkeypair-relltesttx "Direct link to function-signkeypairs-listrelltestkeypair-relltesttx")

Adds the specified list of keypairs as signers to the transaction.

**Parameters:**

- `keypairs: list<rell.test.keypair>` \- A list of keypairs to add as signers.

**Returns:**

- The transaction builder object (allowing for method chaining).

### `function sign(privkey: byte_array...): rell.test.tx` [â€‹](\#function-signprivkey-byte_array-relltesttx "Direct link to function-signprivkey-byte_array-relltesttx")

Adds signer private keys to the transaction.

**Parameters:**

- `privkey: byte_array` \- One or more private keys to add as signers.

**Returns:**

- The transaction builder object (allowing for method chaining).

### `function sign(privkeys: list<byte_array>): rell.test.tx` [â€‹](\#function-signprivkeys-listbyte_array-relltesttx "Direct link to function-signprivkeys-listbyte_array-relltesttx")

Adds the specified list of private keys as signers to the transaction.

**Parameters:**

- `privkeys: list<byte_array>` \- A list of private keys to add as signers.

**Returns:**

- The transaction builder object (allowing for method chaining).

### `function copy(): rell.test.tx` [â€‹](\#function-copy-relltesttx "Direct link to function-copy-relltesttx")

Returns a copy of this transaction builder object.

**Parameters:**

- None

**Returns:**

- A copy of the transaction builder object.

### `function run(): void` [â€‹](\#function-run-void "Direct link to function-run-void")

Runs a block containing this single transaction.

**Parameters:**

- None

**Returns:**

- Nothing.

### `function run_must_fail(expected: text? = null): rell.test.failure` [â€‹](\#function-run_must_failexpected-text--null-relltestfailure "Direct link to function-run_must_failexpected-text--null-relltestfailure")

Runs a block containing this transaction and expects it to fail. If an expected message is passed, it will pass only if
the failure message contains the expected message. Throws an exception on success, not on failure.

**Parameters:**

- `expected` (optional): Text indicating the expected error message.

**Returns:**

- A `rell.test.failure` object if the transaction fails as expected. Throws an exception if the transaction succeeds
unexpectedly.

#### Example [â€‹](\#example "Direct link to Example")

```codeBlockLines_e6Vv
operation will_fail_sometimes(will_fail: booelan) {
    require(!will_fail, "This operation has failed");
}

function test_fails() {
    val tx = rell.test.tx().op(will_fail_sometimes(true));
    tx.run_must_fail();
    tx.run_must_fail("has failed");
}

```

- [Constructors](#constructors)
  - [`rell.test.tx()`](#relltesttx-1)
  - [`rell.test.tx(op: rell.test.op...): rell.test.tx`](#relltesttxop-relltestop-relltesttx)
  - [`rell.test.tx(ops: list<rell.test.op>): rell.test.tx`](#relltesttxops-listrelltestop-relltesttx)
- [Functions](#functions)
  - [`function op(op: rell.test.op...): rell.test.tx`](#function-opop-relltestop-relltesttx)
  - [`function op(ops: list<rell.test.op>): rell.test.tx`](#function-opops-listrelltestop-relltesttx)
  - [`function nop(): rell.test.tx`](#function-nop-relltesttx)
  - [`function nop(x: integer): rell.test.tx`](#function-nopx-integer-relltesttx)
  - [`function nop(x: text): rell.test.tx`](#function-nopx-text-relltesttx)
  - [`function nop(x: byte_array): rell.test.tx`](#function-nopx-byte_array-relltesttx)
  - [`function sign(keypair: rell.test.keypair...): rell.test.tx`](#function-signkeypair-relltestkeypair-relltesttx)
  - [`function sign(keypairs: list<rell.test.keypair>): rell.test.tx`](#function-signkeypairs-listrelltestkeypair-relltesttx)
  - [`function sign(privkey: byte_array...): rell.test.tx`](#function-signprivkey-byte_array-relltesttx)
  - [`function sign(privkeys: list<byte_array>): rell.test.tx`](#function-signprivkeys-listbyte_array-relltesttx)
  - [`function copy(): rell.test.tx`](#function-copy-relltesttx)
  - [`function run(): void`](#function-run-void)
  - [`function run_must_fail(expected: text? = null): rell.test.failure`](#function-run_must_failexpected-text--null-relltestfailure)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Iterable values introduce a unified concept for processing sequences in various data structures. While the compiler uses
an internal type `iterable<T>`, which cannot be explicitly declared in code, several types can be used as `iterable<T>`.

## Iterable types [â€‹](\#iterable-types "Direct link to Iterable types")

1. **`range: iterable<integer>`**
   - Generates a sequence of integers.

   - Examples:
     - `range(10)` produces 0 to 9.

     - `range(1, 10)` produces 1 to 9.

     - `range(0, 10, 2)` produces 0, 2, 4, 6, 8.
2. **`list<T>: iterable<T>`**
   - Stores an ordered collection of elements of type `T`.

   - Example:
     - `list<integer> = [1, 2, 3, 4, 5]`
3. **`set<T>: iterable<T>`**
   - Holds a unique collection of elements of type `T`.

   - Example:
     - `set<text> = {"apple", "banana", "cherry"}`
4. **`map<K,V>: iterable<(K,V)>`**
   - Associates keys of type `K` with values of type `V`.

   - Example:
     - `map<text, integer> = {"one": 1, "two": 2, "three": 3}`
5. **Virtual collections**
   - `virtual<list<T>>, virtual<set<T>>, virtual<map<K,V>>`

   - Represent virtual collections that behave like their non-virtual counterparts.

## Key applications of iterables [â€‹](\#key-applications-of-iterables "Direct link to Key applications of iterables")

1. **`for` loops**

Easily iterate through elements:





```codeBlockLines_e6Vv
for (x in range(10)) {
       print(x);
}

```

2. **Collection-at expressions**

Apply operations to each element:





```codeBlockLines_e6Vv
val doubled = range(1, 6) @* {} ( $ * 2 );

```

3. **List/Set/Map constructors**

Build new collections from iterables:





```codeBlockLines_e6Vv
struct Person {
       name: text;
       age: integer;
}

val people = [\
       Person("Alice", 28),\
       Person("Bob", 35),\
       Person("Charlie", 22),\
       Person("David", 41),\
       Person("Eve", 19)\
];

// List constructor: names of people over 30
val senior_names = list<text>();
for (p in people) {
       if (p.age > 30) {
           senior_names.add(p.name);
       }
}

// Set constructor: unique ages
val unique_ages = set<integer>();
for (p in people) {
       unique_ages.add(p.age);
}

// Map constructor: name to age mapping
val name_to_age = map<text, integer>();
for (p in people) {
       name_to_age[p.name] = p.age;
}

// Printing names of seniors
for (name in senior_names) {
       print("Senior name: " + name);
}

// Printing unique ages
for (age in unique_ages) {
       print("Unique age: " + age);
}

// Printing name to age map
for (name in name_to_age.keys()) {
       print(name + " is " + name_to_age[name] + " years old.");
}

```


## Practical examples [â€‹](\#practical-examples "Direct link to Practical examples")

### Working with ranges [â€‹](\#working-with-ranges "Direct link to Working with ranges")

```codeBlockLines_e6Vv
// Generate squares of numbers from 0 to 9
val squares = list<integer>();
for (i in range(10)) {
    squares.add(i * i);
}
print("Squares: " + squares);

// Create a set of natural numbers from 1 to 9
val naturals = set<integer>();
for (i in range(1, 10)) {
    naturals.add(i);
}
print("Naturals: " + naturals);

// Generate even numbers from 0 to 18
val evens = list<integer>();
for (i in range(0, 20, 2)) {
    evens.add(i);
}
print("Evens: " + evens);

```

### Constructing and manipulating maps [â€‹](\#constructing-and-manipulating-maps "Direct link to Constructing and manipulating maps")

```codeBlockLines_e6Vv
// Construct a map from tuples
val tuples = [(1,'A'), (2,'B'), (3,'C')];
val m = map(tuples);
print(m);  // Output: {1=A, 2=B, 3=C}

// Convert a map to a list of tuples
val L = list(m);
print(L);  // Output: [(1,A), (2,B), (3,C)]

// Create a map from two lists
val keys = ["name", "age", "city"];
val values = ["Alice", "30", "New York"];
val details = map<text, text>();
for (i in range(keys.size())) {
    details[keys[i]] = values[i];
}
print(details);  // Output: {name=Alice, age=30, city=New York}

```

### Working with sets [â€‹](\#working-with-sets "Direct link to Working with sets")

```codeBlockLines_e6Vv
// Create a set from a list with duplicates
val numbers = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4];
val unique_numbers = set(numbers);
print(unique_numbers);  // Output: [1, 2, 3, 4]

```

### Advanced iterable usage [â€‹](\#advanced-iterable-usage "Direct link to Advanced iterable usage")

```codeBlockLines_e6Vv
// Filter and transform a list
val numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
val even_numbers = list<integer>();
for (number in numbers) {
    if (number % 2 == 0) {
        even_numbers.add(number);
    }
}
print(even_numbers); // Output: [2, 4, 6, 8, 10]

// Combine multiple iterables
val numbers1 = [1, 2, 3];
val numbers2 = [4, 5, 6];
val combined = list<integer>();
for (number in numbers1) {
    combined.add(number);
}
for (number in numbers2) {
    combined.add(number);
}
print(combined);  // Output: [1, 2, 3, 4, 5, 6]

```

- [Iterable types](#iterable-types)
- [Key applications of iterables](#key-applications-of-iterables)
- [Practical examples](#practical-examples)
  - [Working with ranges](#working-with-ranges)
  - [Constructing and manipulating maps](#constructing-and-manipulating-maps)
  - [Working with sets](#working-with-sets)
  - [Advanced iterable usage](#advanced-iterable-usage)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

A node in the Chromia network is a computer (such as a virtual or physical server) that runs the Chromia core software,
_Postchain_, and the open-source relational database [PostgreSQL](https://www.postgresql.org/). A node holds a unique
cryptographic key pair and is identified on the network through its public key. In this section, we'll explore how
Postchain powers the network by handling decentralized transaction processing and data storage.

## Postchain overview [â€‹](\#postchain-overview "Direct link to Postchain overview")

Postchain is the core software that manages blockchain operations and integrates them with relational database
functionality through PostgreSQL. It serves as the backbone of Chromia, enabling decentralized transaction processing
and data consistency across multiple nodes.

Postchain handles key tasks on Chromia's nodes, such as:

- **Transaction processing:** It accepts and processes signed transactions submitted by users or applications.
- **Consensus management:** The system employs the eBFT (Enhanced Byzantine Fault Tolerance) consensus protocol to
validate blocks and achieve agreement among nodes.
- **Data storage:** It interacts with PostgreSQL to store blockchain data, which includes the history of verified
transactions and the states of each dappâ€™s individual blockchain.
- **Dapp code execution:** It executes dapp-specific code written in the Rell programming language, translating
operations into database actions that update the state of each dapp.

### PostgreSQL integration and indexing [â€‹](\#postgresql-integration-and-indexing "Direct link to PostgreSQL integration and indexing")

The PostgreSQL integration within Postchain enables automatic data indexing, allowing Chromia to support complex
relational queries directly on-chain. This approach offers significant performance advantages in both read and write
operations, enhancing data accessibility and flexibility for developers. With these capabilities, dapp developers can:

- Retrieve specific data points or datasets using advanced filters, eliminating the need to retrieve full data arrays.
- Perform relational queries across multiple tables or entities, allowing complex on-chain data interactions without
relying on off-chain processing.

Together, these features empower developers to build data-rich, complex dapps that leverage Chromiaâ€™s on-chain database
integration for optimal efficiency and functionality.

## Transaction lifecycle on Postchain [â€‹](\#transaction-lifecycle-on-postchain "Direct link to Transaction lifecycle on Postchain")

The lifecycle of transactions on Postchain involves several interconnected tasks, ensuring that each transaction is
properly received, processed, and stored. These tasks include:

### Receiving transactions [â€‹](\#receiving-transactions "Direct link to Receiving transactions")

To execute a transaction for a dapp on the Chromia network, a user or client sends that transaction to any node that
runs that dapp via the node's REST API. In practice, this means sending the transaction to any node _within the cluster_
that houses the dapp. Transactions are encoded according to Chromia's
[Generic Transaction Protocol (GTX)](/intro/architecture/generic-transaction-protocol) and include the following:

- The unique ID of the dapp chain on the network (referred to as the
[Blockchain RID](/intro/terminology#blockchain-rid-brid)).
- A list of operations and their corresponding arguments. These operations are defined in the dapp's code, allowing
users to call them through transactions and modify data. This defines what the transaction accomplishes.
- A list of signers along with their signatures.

### Building blocks and verifying consensus [â€‹](\#building-blocks-and-verifying-consensus "Direct link to Building blocks and verifying consensus")

When a node receives a transaction, it quickly multicasts it to all other nodes in the cluster. These nodes then verify
consensus using Chromia's eBFT algorithm, a modified version of
[Practical Byzantine Fault Tolerance](https://lamport.azurewebsites.net/pubs/byz.pdf). eBFT operates as a
[Proof-of-Authority (PoA)](https://en.wikipedia.org/wiki/Proof_of_authority) algorithm, allowing a select group of
validator nodes to create new blocks. The validator nodes in the dapp's cluster collaborate to achieve consensus,
ensuring only valid transactions are added to the blockchain and that the network remains secure and resilient.

With eBFT, a node can propose a block, and the proposal is accepted if it gets a super-majority (greater than â…”) of
validators to sign the block. Validator nodes take turns creating the next block. The consensus process follows these
steps:

![Consensus](/img/Consensus_LM_C.svg)

1. The primary node collects all incoming transactions within a specific (configurable) time interval and adds them to
the proposed block for the current round.
2. It then multicasts the proposed block to all other nodes.
3. Upon receiving the proposed block, the other nodes validate it by executing the transactions (without making changes
to the database). If valid, they sign the block and multicast their signatures to all other nodes, including the
primary node.
4. Once the primary node receives signatures from more than two-thirds of the nodes, each node commits the block to the
database.

The consensus algorithm can withstand just under â…“ of the nodes in a cluster acting maliciously, switching off, or
isolating themselves from the rest of the network. Once consensus around a block of transactions is reached, those
transactions can be safely committed.

### Executing dapp code [â€‹](\#executing-dapp-code "Direct link to Executing dapp code")

Dapps on the Chromia network are written in [Rell](/rell/rell-intro), a programming language specifically designed for
the platform. Rell simplifies working with Chromia's relational blockchain model. When transactions occur, Postchain
interprets and executes the dapp code, performing the specified operations with the transaction's provided arguments.

### Updating the relational database [â€‹](\#updating-the-relational-database "Direct link to Updating the relational database")

Each dapp on Chromia operates with its own instance of a relational database. Upon deploying a new dapp or updating an
existing one, Postchain interprets the dapp's code to determine the required database tables. It automatically creates
the necessary tables and columns, ensuring the dapp functions smoothly.

Postchain also updates the database as transactions occur. When transactions invoke operations defined in the dappâ€™s
Rell code, Postchain translates this code into SQL queries, updating the dapp's data and state. Rell prevents developers
from executing raw SQL queries directly, instead offering an abstraction that limits access to their own data while
providing a more convenient and expressive way to interact with the database.

Additionally, Postchain stores system-level data in the relational database. This includes storing each dapp's
blockchain and the history of verified transactions. If needed, this information can be combined and replayed to restore
each dapp's database state at any block height, ensuring data integrity across the network.

### Responding to queries [â€‹](\#responding-to-queries "Direct link to Responding to queries")

Besides transactions, which invoke operations and mutate data, Chromia allows you to perform read-only queries for a
dapp. Like transactions, queries are typically called using one of Chromia's client libraries. However, unlike
transactions, nodes running Postchain quickly respond to read-only queries without needing to verify consensus. This
efficiency allows the client or frontend to implement its own consensus verification strategy if required. For instance,
you might randomly choose a node from the cluster for a query, or in more complex cases, you might query multiple nodes
and validate consensus on the frontend.

Queries, like operations, are defined in Rell and are part of the deployed code for a dapp. They automatically form part
of a dapp's API and can be invoked through a client library by passing the necessary arguments.

## Dapp containers [â€‹](\#dapp-containers "Direct link to Dapp containers")

Dapps on the Chromia network have their own dedicated compute and storage resources to ensure consistent throughput.
Each node on the network runs multiple instances of the core software, Postchain. The main instance operates directly on
the node machine and spawns containers (isolated virtual machines) to host specific dapps. This setup allows the main
instance to route transactions and events efficiently to the corresponding container. From an external perspective, each
node functions as a single entity on the Chromia network, capable of accepting transactions intended for any of the
dapps it hosts.

Node

Postchain

Dapp container 1

Postchain

Dapp code

Database

Dapp container 2

Postchain

Dapp code

Database

Dapp container 3

Postchain

Dapp code

Database

Chromia network

Containers in a Chromia node

## The relational database [â€‹](\#the-relational-database "Direct link to The relational database")

Each dapp container hosts its own instance of a PostgreSQL relational database to support that container's dapp. The
database stores:

- Dapp data, with tables corresponding to [`entities`](/rell/core-concepts#entity-definitions) in the dapp's Rell code.
- A dapp's individual blockchain.
- A complete history of verified transactions related to the dapp.
- Node configuration settings, including addresses of peer nodes within the cluster.
- Replicas of the system chain.

## Next up [â€‹](\#next-up "Direct link to Next up")

Having explored the structure of nodes in the Chromia network, we'll now explore the Chromia architecture.

- [Postchain overview](#postchain-overview)
  - [PostgreSQL integration and indexing](#postgresql-integration-and-indexing)
- [Transaction lifecycle on Postchain](#transaction-lifecycle-on-postchain)
  - [Receiving transactions](#receiving-transactions)
  - [Building blocks and verifying consensus](#building-blocks-and-verifying-consensus)
  - [Executing dapp code](#executing-dapp-code)
  - [Updating the relational database](#updating-the-relational-database)
  - [Responding to queries](#responding-to-queries)
- [Dapp containers](#dapp-containers)
- [The relational database](#the-relational-database)
- [Next up](#next-up)[Skip to main content](#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Deploying a decentralized application (dapp) to the Chromia testnet involves several key steps. Here's an overview of
the process, with each step explained in more detail in the subsequent pages.

## [Step 1: Obtain a container for your dapp](/intro/deployment/testnet/get-container) [â€‹](\#step-1-obtain-a-container-for-your-dapp "Direct link to step-1-obtain-a-container-for-your-dapp")

Your dapp needs a container, which serves as its operational environment. Here's how to get one:

1. **Generate a public-private key pair**: Use the Chromia CLI to generate a
[public-private key pair](/intro/deployment/testnet/get-container#step-1-generate-a-key-pair). You'll need
the keys to lease a container and deploy your dapp.
2. **Lease a container**: Go to the Chromia [staking page](https://testnet-staking.chromia.com/staking/) and
[lease a container](/intro/deployment/testnet/get-container#step-2-lease-container-space). This process will
give you a Container ID necessary for deployment.

## [Step 2: Deploy your dapp](/intro/deployment/testnet/deploy-dapp) [â€‹](\#step-2-deploy-your-dapp "Direct link to step-2-deploy-your-dapp")

Once you have secured your container, follow these steps to deploy your dapp:

1. **Update configuration**: Add your deployment specifics, including the Container ID, to your project configuration
file ( `chromia.yml`). Detailed instructions can be found
[here](/intro/deployment/testnet/deploy-dapp#deploy-the-dapp).
2. **Execute deployment**: Use the Chromia CLI to execute the deployment command. Specify your network (mainnet) and
blockchain name.
3. **Receive blockchain RID**: Upon successful deployment, you will receive a unique Blockchain RID for your dapp. This
is essential for [future updates](/intro/deployment/testnet/deploy-dapp#update-the-dapp) and
[client connectivity](/intro/deployment/testnet/connect-client).

## [Step 3: Connect a client](/intro/deployment/testnet/connect-client) [â€‹](\#step-3-connect-a-client "Direct link to step-3-connect-a-client")

To enable user interactions, you must [connect a client](/intro/deployment/testnet/connect-client) to the
backend of your deployed dapp:

1. **Specify node URLs and Blockchain RID**: Configure the client by specifying a pool of system node URLs where your
dapp is running and the Blockchain RID specific to your dapp.
2. **Complete configuration**: Follow the steps outlined [here](/intro/deployment/testnet/connect-client) to
complete the configuration.

By completing these steps, you will have successfully deployed a fully functional dapp to the Chromia testnet. The next
few pages explain each of the steps in more detail.

- [Step 1: Obtain a container for your dapp](#step-1-obtain-a-container-for-your-dapp)
- [Step 2: Deploy your dapp](#step-2-deploy-your-dapp)
- [Step 3: Connect a client](#step-3-connect-a-client)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Entities, objects, operations, and queries have mount names:

- for entities and objects, those names are the SQL table names where the data gets stored
- for operations and queries, you use a mount name to invoke an operation or a query from the outside

By default, you define a mount name by a fully qualified name of a definition.

##### Example [â€‹](\#example "Direct link to Example")

```codeBlockLines_e6Vv
namespace foo {
    namespace bar {
        entity user {}
    }
}

```

note

The mount name for the `user` entity becomes `foo.bar.user`, reflecting its hierarchical position.

## Custom mount names [â€‹](\#custom-mount-names "Direct link to Custom mount names")

You can use the `@mount` annotation to specify a custom mount name. You can specify the `@mount` annotation for
entities, objects, operations, and queries.

**Syntax**: `@mount('desired_mount_name')`

##### Example [â€‹](\#example-1 "Direct link to Example")

```codeBlockLines_e6Vv
@mount('foo.bar.user')
entity user {}

```

## Mount for namespace [â€‹](\#mount-for-namespace "Direct link to Mount for namespace")

Prefix elements within a namespace with a custom mount name.

##### Example [â€‹](\#example-2 "Direct link to Example")

```codeBlockLines_e6Vv
@mount('foo.bar')
namespace ns {
    entity user {}
}

```

The mount name of a `user` is `foo.bar.user`.

## Mount for module [â€‹](\#mount-for-module "Direct link to Mount for module")

Prefix elements within a module with a custom mount name.

##### Example [â€‹](\#example-3 "Direct link to Example")

```codeBlockLines_e6Vv
@mount('foo.bar')
module;

entity user {}

```

The mount name of a `user` is `foo.bar.user`.

## Nested namespace mounts [â€‹](\#nested-namespace-mounts "Direct link to Nested namespace mounts")

A mount name can be relative to the context mount name. For example, when defined in a namespace:

##### Example [â€‹](\#example-4 "Direct link to Example")

```codeBlockLines_e6Vv
@mount('a.b.c')
namespace ns {
    entity user {}
}

```

The entity `user` has the following mount names when annotated with `@mount`:

- `@mount('.d.user')` -\> `a.b.c.d.user`
- `@mount('^.user')` -\> `a.b.user`
- `@mount('^^.x.user')` -\> `a.x.user`

#### Construct complex mount names relative to context using special characters [â€‹](\#construct-complex-mount-names-relative-to-context-using-special-characters "Direct link to Construct complex mount names relative to context using special characters")

- `.` (dot): Appends names to the current context mount name.
- `^` (caret): Removes the last part from the context mount name.

```codeBlockLines_e6Vv
@mount("foo.")
entity user {
}

// mount name = "foo.user"

@mount("foo")
entity user {
}
// mount name = "foo"

```

- [Custom mount names](#custom-mount-names)
- [Mount for namespace](#mount-for-namespace)
- [Mount for module](#mount-for-module)
- [Nested namespace mounts](#nested-namespace-mounts)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

The `@external` annotation allows a blockchain to access entities defined in another blockchain in the same container.

```codeBlockLines_e6Vv
@external("foo")
namespace {
    @log
    entity user {
    }
    @log
    entity company {
    }
}

@external("foo")
@log
entity city {
}

query get_all_users() = user @* { };

```

In this example, `'foo'` is the name of an external blockchain. Before it's used in an `@external` annotation, you need
to define the blockchain in the blockchain configuration ( `dependencies` node).

Every blockchain has its `chain_id`, that's included in table names for entities and objects of that chain. If the
blockchain `'foo'` has `chain_id` = 123, the table for the entity `user` is `c123.user`.

### Key features [â€‹](\#key-features "Direct link to Key features")

- External entities must have the `@log` annotation. This implies that those entities can't have mutable attributes.
- You can't create or delete the values of external entities.
- You can annotate only entities, namespaces, and imports with `@external` annotation.
- When you select the values of an external entity (using at-expression), an implicit block height filter gets applied,
so the active blockchain can see only those blocks of the external blockchain whose height is lower than a specific
value.
- Every blockchain stores the structure of its entities in meta-information tables. When you start a blockchain, the
meta-information of all involved external blockchains gets verified to ensure that all declared external entities
exist and have declared attributes.

note

External modules can only be accessed if the blockchain resides in the same container as the one trying to access them.

## External modules [â€‹](\#external-modules "Direct link to External modules")

You can annotate a module as `@external` with no arguments.

##### Example [â€‹](\#example "Direct link to Example")

```codeBlockLines_e6Vv
@external
module;

@log
entity user {
}

@log
entity company {
}

```

External modules can contain only namespaces, entities (annotated with `@log`), and imports of other external modules.

#### External modules can be imported as a regular or external module: [â€‹](\#external-modules-can-be-imported-as-a-regular-or-external-module "Direct link to External modules can be imported as a regular or external module:")

- **Regular import**: entities defined in the module `ext` belong to the current blockchain.





```codeBlockLines_e6Vv
import ext;

```

- **External import**: entities defined in the module `ext` get imported as external entities from the chain `foo`.





```codeBlockLines_e6Vv
@external('foo') import ext;

```


## Transactions and blocks [â€‹](\#transactions-and-blocks "Direct link to Transactions and blocks")

To access blocks and transactions of an external blockchain, you use the following syntax:

```codeBlockLines_e6Vv
@external("foo")
namespace foo {
    entity transaction ;
    entity block ;
}

function get_foo_transactions(): list<foo.transaction> = foo.transaction @* { };

function get_foo_blocks(): list<foo.block> = foo.block @* { };

```

- External and non-external transactions/blocks are distinct, incompatible types.
- When selecting external transactions or blocks, you use an implicit height filter (like for external entities).

You can access entities `transaction` and `block` of an external chain by an external module:

```codeBlockLines_e6Vv
@external("foo")
import ext;

function get_foo_transactions(): list<ext.transaction> = ext.transaction @* { };

function get_foo_blocks(): list<ext.block> = ext.block @* { };

```

The entities are implicitly added to the module's namespace, and you can access them by their import alias.

- [Key features](#key-features)
- [External modules](#external-modules)
- [Transactions and blocks](#transactions-and-blocks)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

#### Block [â€‹](\#block "Direct link to Block")

The blocks hold the actual data of the blockchain. Each block depends on the previous one, creating a chain of blocks.

#### Blockchain [â€‹](\#blockchain "Direct link to Blockchain")

The data the dapps use is stored in the blockchains that are hosted by the nodes. For example, the dapp `HorseDapp` uses
the blockchain `HorseBC` to store its data but also reads from the blockchain `AllSpeciesRepo` managed by a different
dapp.

#### Blockchain Configuration (BC-Config) [â€‹](\#blockchain-configuration-bc-config "Direct link to Blockchain Configuration (BC-Config)")

The blockchain configuration fully defines the blockchain's behavior. Signer and replica nodes need to know the
configuration to create and verify blocks.

#### Blockchain RID (BRID) [â€‹](\#blockchain-rid-brid "Direct link to Blockchain RID (BRID)")

The global reference ID for a blockchain that's common for all nodes.

#### Chain ID [â€‹](\#chain-id "Direct link to Chain ID")

The local blockchain ID. It can be different on different nodes.

#### Command Line Interface (CLI) [â€‹](\#command-line-interface-cli "Direct link to Command Line Interface (CLI)")

CLI is a non-graphical, text-based interface to the computer system, where the user types in a command, and the computer
then successfully executes it.

#### Chromia Command-line Interface (Chromia CLI) [â€‹](\#chromia-command-line-interface-chromia-cli "Direct link to Chromia Command-line Interface (Chromia CLI)")

Chromia [CLI](https://gitlab.com/chromaway/core-tools/chromia-cli) makes the development cycle and deployment of Rell
dapps simpler, where all the needed capability is available in one CLI.

#### Chromia Explorer [â€‹](\#chromia-explorer "Direct link to Chromia Explorer")

Chromia [Explorer](https://explorer.chromia.com/) is a fully decentralized blockchain explorer which allows users to
visualize transactions and activities on different chains.

#### Chromia Vault [â€‹](\#chromia-vault "Direct link to Chromia Vault")

Chromia [Vault](https://vault.chromia.com) allows users to manage their tokens and dapps on the Chromia blockchain.

#### Cross-Chain Communication Subsystem (ICMF) [â€‹](\#cross-chain-communication-subsystem-icmf "Direct link to Cross-Chain Communication Subsystem (ICMF)")

Interchain Messaging Facility allows chains and dapps across the Chromia network to communicate and share assets
seamlessly.

#### Decentralized Application (dapp) [â€‹](\#decentralized-application-dapp "Direct link to Decentralized Application (dapp)")

Short for decentralized applications, a dapp is an app that's designed to run on a blockchain network. It's a
distributed app where the back end runs on nodes and the front end on some client software.

#### Dapp Containers [â€‹](\#dapp-containers "Direct link to Dapp Containers")

A framework for resource provision on provider nodes that allows dapps on Chromia to run in a decentralized fashion. It
removes reliance on services like Amazon Web Service (AWS).

#### Flexible Tokens (FT) [â€‹](\#flexible-tokens-ft "Direct link to Flexible Tokens (FT)")

A Chromia token standard that supports all fungible, non-fungible, and native CHR tokens on the Chromia network.

#### Key pair [â€‹](\#key-pair "Direct link to Key pair")

Refers to a cryptographic key pair used for securing and authenticating transactions and interactions within the
network. The key pair consists of two related but distinct cryptographic keys: a private key and a public key.

#### Management Chain (bc0) [â€‹](\#management-chain-bc0 "Direct link to Management Chain (bc0)")

A dapp for managing settings for all blockchains in the network. This is convenient because it helps to synchronize
configuration changes between nodes (where manual synchronization would be time-consuming). bc0 manages all blockchains
in the network, including itself.

#### Node [â€‹](\#node "Direct link to Node")

A machine running the blockchains.

#### Postchain MC (PMC) [â€‹](\#postchain-mc-pmc "Direct link to Postchain MC (PMC)")

A command line tool which submits transactions to the management chain.

#### Private key [â€‹](\#private-key "Direct link to Private key")

The private key of a key pair.

#### Providers [â€‹](\#providers "Direct link to Providers")

It consists of private persons or organizations who are responsible for the nodes.

#### Public key [â€‹](\#public-key "Direct link to Public key")

The public key of a key pair.

#### Rell [â€‹](\#rell "Direct link to Rell")

Rell is the custom programming language of the Chromia blockchain. The language is deliberately like modern programming
languages, and developers can use relational programming idioms they're already familiar with.

#### Replica [â€‹](\#replica "Direct link to Replica")

A node that verifies data blocks but doesn't create blocks.

#### Signer [â€‹](\#signer "Direct link to Signer")

A node that's responsible for verifying and creating data blocks.

#### Single Sign-On (SSO) [â€‹](\#single-sign-on-sso "Direct link to Single Sign-On (SSO)")

The [Chromia Vault Single Sign On](https://blog.chromia.com/chromia-sso-the-whys-and-the-whats/) is a unique feature
that reduces password entering without compromising user's security.## @chromia/ft4 - v1.0.1

# [Dapp FT4 Library](\#md:dapp-ft4-library)

The FT4 library is a toolkit to help dapp developers build real world applications
within the Chromia ecosystem by providing out of the box support for things such as
account creation and access management and interaction with external signature solutions
already familiar to the user. It also provides asset management. Allowing issuance,
allocation and transfers and tracing of asset activities, both within a chain as well
as across other chains within the Chromia ecosystem.

## [Features](\#md:features)

- **Asset Management**: Facilitate the creation, allocation, and management of
assets.
- **Asset Allocation and Transfers**: Perform secure and efficient asset
transfers.
- **Cross-Chain Transfers**: Enable the movement of assets between distinct
blockchains.
- **Account Registration and Management**: Create and oversee user accounts
independently of asset activities.

### Settings

#### Member Visibility

- Protected
- Private
- Inherited

#### Theme

OSLightDark

### On This Page

[Dapp FT4 Library](#md:dapp-ft4-library)

- [Features](#md:features)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

By default, blockchains in the Chromia ecosystem cannot transact directly with one another. To enable this
functionality, developers must implement proprietary libraries known as ICMF and ICCF. These libraries facilitate
communication for dapps within the same cluster and between dapps in different clusters.

- **ICMF** enables cross-chain communication between blockchains within the
[dapp cluster](/intro/architecture#dapp-cluster).
- **ICCF** enables cross-chain communication between blockchains in different
[dapp clusters](/intro/architecture#dapp-cluster).

## Inter-Chain Messaging Facility (ICMF) [â€‹](\#inter-chain-messaging-facility-icmf "Direct link to Inter-Chain Messaging Facility (ICMF)")

ICMF operates as an event-based service within a [dapp cluster](/intro/architecture#dapp-cluster). In this model,
`dapp_#1` subscribes to a set of topics and waits for `dapp_#2` to emit events. Events represent transactions, while
topics contain the embedded data in those transactions. `dapp_#1` constantly queries `dapp_#2` for events, while
`dapp_#2` generates the events.

For instance, when a user in `dapp_#2` wants to transfer assets to an account in `dapp_#1`, the process unfolds as
follows:

1. A user submits an asset transfer request in `dapp_#2`.
2. The system validates the transaction in `dapp_#2` and records it in the ledger.
3. The account balance in `dapp_#2` updates accordingly.
4. `dapp_#1` queries `dapp_#2` to find the asset transfer event directed to `dapp_#1`.
5. `dapp_#1` verifies the authenticity of the asset transfer that occurred in `dapp_#2`.
6. With the verified asset transfer data, `dapp_#1` submits a transaction to update the account balance in its
blockchain.
7. The account balance in `dapp_#1` updates.

## Inter-Chain Confirmation Facility (ICCF) [â€‹](\#inter-chain-confirmation-facility-iccf "Direct link to Inter-Chain Confirmation Facility (ICCF)")

ICCF facilitates communication between dapps in different [dapp clusters](/intro/architecture#dapp-cluster). ICCF
acts as a client application that serves as an intermediary between two blockchains located in separate dapp clusters.
The client submits a transaction on the `source_chain` and provides proof of the validated transaction to the
`destination_chain`.

In a simplified scenario where a user wants to transfer assets from the `source_chain` to the `destination_chain`, the
process looks like this:

1. The client application submits a transaction on the `source_chain` for asset transfer.
2. The `source_chain` validates the transaction.
3. The client submits a transaction to the `destination_chain`, including proof of the validated transaction.
4. The `destination_chain` validates the transaction and updates the account balance.

- [Inter-Chain Messaging Facility (ICMF)](#inter-chain-messaging-facility-icmf)
- [Inter-Chain Confirmation Facility (ICCF)](#inter-chain-confirmation-facility-iccf)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Operations are declared using the `operation` keyword, followed by a unique operation name and a list of parameters
enclosed in parentheses. The parameters specify the data that the operation expects as input.

Operations have the following characteristics:

- Can modify the data in the database
- Doesn't return a value
- Parameter types must be GTV-compatible

##### Example [â€‹](\#example "Direct link to Example")

```codeBlockLines_e6Vv
operation create_user(name: text) {
    create user(name = name);
}

```

## Illustrative example: registering a channel [â€‹](\#illustrative-example-registering-a-channel "Direct link to Illustrative example: registering a channel")

Make an operation that allows a user to create a new channel:

```codeBlockLines_e6Vv
operation register_channel (user_pubkey: pubkey, channel_name: name) {
    require( op_context.is_signer(user_pubkey) );
    create channel (
        owner = user @ {.pubkey == user_pubkey},
        name = channel_name
    );
}

```

You can go through this line by line. First we declare the operation name and a list of parameters:

```codeBlockLines_e6Vv
operation register_channel (user_pubkey: pubkey, channel_name: name) {

```

It is very similar to function definitions in other languages. An operation is a function of a special kind: you can
invoke it by using a blockchain transaction by its name. When invoking `register_channel`, the caller must provide two
arguments of specified types. Otherwise, it fails.

```codeBlockLines_e6Vv
require( op_context.is_signer(user_pubkey) );

```

We don't want Alice to be able to pull a prank on Bob by registering a channel with a silly name on his behalf. Thus we
need to ensure that the transaction gets signed with a key corresponding to the public key specified in the first
parameter. (In other words, if Bob's public key is `user_pubkey`, the transaction must also get signed by Bob. That's,
Bob is a signer of this transaction.) it's a typical pattern in Rell -- typically, you specify an actor in an operation
parameter. In the body of the operation, you verify that the actor was the signer. `require` fails the operation if the
specified condition isn't met.

`create channel` creates a persistent object `channel`. You don't need to explicitly store it, as all created objects
persist if the operation succeeds.

`user @ {.pubkey=user_pubkey}` \-\- now we retrieve a user object by its pubkey, which should be unique. If no such user
exists, the operation fails. We don't need to test for that explicitly, as `@` operator does this job.

Rell can automatically find attribute names corresponding to arguments using types. As `user` and `name` are different
types, you can write `create channel` as follows:

```codeBlockLines_e6Vv
create channel (user @ {.pubkey == user_pubkey}, channel_name);

```

- [Illustrative example: registering a channel](#illustrative-example-registering-a-channel)- [@chromia/ft4](../index.html)
- [registration](../modules/registration.html)
- [registerAccountOp](registration.registerAccountOp.html)

# Function registerAccountOp

- registerAccountOp(): Operation [Permalink](#registerAccountOp)
- Produces a register\_account operation.




#### Returns Operation


### Settings

#### Member Visibility

- Protected
- Private
- Inherited

#### Theme

OSLightDark[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

This topic provides insights into the process of analyzing and optimizing your dapp code written in Rell. You can use
the [Chromia CLI](/cli/introduction) to examine SQL statements generated by your dapp, identify performance
bottlenecks, and implement optimizations.

Consider the following simple Rell dapp:

```codeBlockLines_e6Vv
# src/main.rell
module;

entity owner {
    name;
}

entity housekey {
    pubkey;
    owner;
}

entity house {
    address: text;
    owner;
}

entity house_owner {
    key house, owner;
}

query get_house_key(address: text): list<(name:text,housekey:pubkey)> {
    return ( housekey, house_owner) @* {
        housekey.owner == .house.owner,
        house_owner.house.address == address
    } (
        name = house_owner.owner.name,
        housekey = housekey.pubkey
    );
}

```

```codeBlockLines_e6Vv
# chromia.yml
blockchains:
  house-key-example:
    module: main
database:
  schema: schema_house-key-example

```

## Analyzing SQL Statements [â€‹](\#analyzing-sql-statements "Direct link to Analyzing SQL Statements")

We aim to gain insights into how the query executes on the server to determine if any optimizations are needed. You can
achieve this using the [Chromia CLI's `repl`](/cli/commands/repl) command with the `--sql-log` argument, which logs
all SQL statements executed. Follow these steps:

1. Start the `repl` with the main module loaded:





```codeBlockLines_e6Vv
$ chr repl --sql-log --use-db --module main
Rell 0.13.1
Type '\q' to quit or '\?' for help.
Current module: 'main'
>>>

```

2. This initiates an interactive Rell session where you can analyze any statement. Execute the `get_house_key` query
with your desired input to observe the results:





```codeBlockLines_e6Vv
>>> get_house_key("foo")
INFO [main] SqlConnectionLogger - [0]
       SELECT A05."name", A00."pubkey" FROM "c0.housekey" A00
       INNER JOIN "c0.owner" A02 ON A00."owner" = A02."rowid", "c0.house_owner" A01
       INNER JOIN "c0.house" A03 ON A01."house" = A03."rowid"
       INNER JOIN "c0.owner" A05 ON A01."owner" = A05."rowid"
       INNER JOIN "c0.owner" A04 ON A03."owner" = A04."rowid"
       WHERE (A02."rowid" = A04."rowid") AND (A03."address" = ?) ORDER BY A00."rowid", A01."rowid"

```


To enhance the query's performance, it's essential to consider various factors, with the impact varying depending on the
volume of data in the tables (entities).

## Optimizing Dapp code [â€‹](\#optimizing-dapp-code "Direct link to Optimizing Dapp code")

Enhancing the performance of your Dapp involves several optimization techniques:

### Keys and Indexing [â€‹](\#keys-and-indexing "Direct link to Keys and Indexing")

Identify fields used in SELECT, JOIN, and WHERE clauses and introduce keys or indexes to boost performance. Fields
directly referenced in the WHERE clause should have keys, while fields used in JOINs should be indexed.

For example, we can identify specific fields that play essential roles in the SELECT, JOIN, and WHERE clauses. These
fields include `A05."name"`, `"A00."pubkey"`, `A00."owner"`, `A01."house"`, `A01."owner"`, `A03."owner"`, and
`A03."address"`. Recognizing these key fields suggests that enhancing performance can be achieved through indexing or
implementing keys on these particular attributes. Considering this observation alone, we would proceed to make the
subsequent refinements to our Dapp:

```codeBlockLines_e6Vv
entity owner {
    key name;
}

entity housekey {
    key pubkey;
    index owner;
}

entity house {
    key address: text;
    index owner;
}

entity house_owner {
    key house, owner;
    index house, owner;
}

```

Keys are applied to uniquely identifiable fields directly referenced in the WHERE clause, and indexes are used for
fields involved in JOIN operations.

## Optimizing statement order [â€‹](\#optimizing-statement-order "Direct link to Optimizing statement order")

When optimizing your queries, pay close attention to the arrangement of conditions within your WHERE clause. To maximize
efficiency, aim to minimize the number of checks by prioritizing conditions likely to yield fewer results. For instance,
consider the following scenario:

In the WHERE clause, you can observe that the statement initially checks if two fields match before verifying the
correctness of the address. This sequence could be significantly enhanced by reversing it. Since we anticipate only one
result from the address check, placing it first would reduce the number of checks required.

```codeBlockLines_e6Vv
WHERE (A02."rowid" = A04."rowid") AND (A03."address" = ?) ORDER BY A00."rowid", A01."rowid"

```

Similarly, the order of join statements can also be fine-tuned for improved performance. If you anticipate a
significantly larger number of owners compared to houses, consider rearranging the first two joins. Achieve this by
reordering the entities in the FROM section of the query:

The modified query is as follows:

```codeBlockLines_e6Vv
query get_house_key(address: text): list<(name:text,housekey:pubkey)> {
    return ( house_owner, housekey) @* {
        house_owner.house.address == address,
        housekey.owner == .house.owner
    } (
        name = house_owner.owner.name,
        housekey = housekey.pubkey
    );
}

```

## Streamlining joins for improved performance [â€‹](\#streamlining-joins-for-improved-performance "Direct link to Streamlining joins for improved performance")

Within the scope of your query, even though it involves just two entities, you might notice that it leads to four joins.
Reducing the number of joins can have a substantial impact on query performance.

### Understanding join distribution [â€‹](\#understanding-join-distribution "Direct link to Understanding join distribution")

1. **Join from the WHAT-Part**: One of the joins arises from the WHAT-part, specifically
`name = house_owner.owner.name`.

2. **Join from the WHERE-Part**: The remaining two joins originate from the WHERE-part, specifically
`housekey.owner == .house.owner`.


### Enhancing performance [â€‹](\#enhancing-performance "Direct link to Enhancing performance")

To optimize query performance, consider strategically placing join conditions within the SQL statement. By introducing
the `house` entity into the statement and testing it in the Rell console, you can achieve performance improvements:

```codeBlockLines_e6Vv
>>> (house_owner, house, housekey) @* {
    house.address == "foo",
    house_owner.house == house,
    house_owner.owner == housekey.owner
    } (
      name = housekey.owner.name,
      housekey = housekey.pubkey
      );
INFO [main] SqlConnectionLogger - [0]
    SELECT A05."name", A02."pubkey" FROM "c0.house_owner" A00
    INNER JOIN "c0.house" A03 ON A00."house" = A03."rowid"
    INNER JOIN "c0.owner" A04 ON A00."owner" = A04."rowid", "c0.house" A01, "c0.housekey" A02 INNER JOIN "c0.owner" A05 ON A02."owner" = A05."rowid"
    WHERE ((A01."address" = ?) AND (A03."rowid" = A01."rowid")) AND (A04."rowid" = A05."rowid") ORDER BY A00."rowid", A01."rowid", A02."rowid"

```

This adjustment results in three joins with an additional check in the WHERE-statement. Given the involvement of three
tables in this request, further reduction in joins may not be feasible. Implement this performance enhancement in your
query:

```codeBlockLines_e6Vv
query get_house_key(address: text): list<(name:text,housekey:pubkey)> {
    return ( house_owner, house, housekey) @* {
        house.address == address,
        house_owner.house == house,
        house_owner.owner == housekey.owner
    } (
        name = housekey.owner.name,
        housekey = housekey.pubkey
    );
}

```

> In short, understanding the intricacies of how SQL statements are generated from Rell code can be quite complex.
> However, this understanding is crucial for ensuring the scalability of your dapp. It involves considering factors like
> the volume of data within each entity and strategies to reduce cardinality, all of which significantly impact your
> dapp's performance as it scales to accommodate millions of users.

As a result of these optimization considerations, your Rell dapp code is refined to look like the following:

```codeBlockLines_e6Vv
entity owner {
    key name;
}

entity housekey {
    key pubkey;
    index owner;
}

entity house {
    key address: text;
    index owner;
}

entity house_owner {
    key house, owner;
    index house, owner;
}

query get_house_key(address: text): list<(name:text,housekey:pubkey)> {
    return ( house, housekey, house_owner) @* {
        house.address == address,
        house_owner.house == house,
        house_owner.owner == housekey.owner
    } (
        name = housekey.owner.name,
        housekey = housekey.pubkey
    );
}

```

- [Analyzing SQL Statements](#analyzing-sql-statements)
- [Optimizing Dapp code](#optimizing-dapp-code)
  - [Keys and Indexing](#keys-and-indexing)
- [Optimizing statement order](#optimizing-statement-order)
- [Streamlining joins for improved performance](#streamlining-joins-for-improved-performance)
  - [Understanding join distribution](#understanding-join-distribution)
  - [Enhancing performance](#enhancing-performance)[Skip to main content](#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.[Skip to main content](#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.[Skip to main content](#__docusaurus_skipToContent_fallback)

Must specify all attributes that don't have default values:

```codeBlockLines_e6Vv
create user(name = 'Bob', company = company @ { .name == 'Amazon' });

```

You don't need to specify the attribute name if it's matched by name or type:

```codeBlockLines_e6Vv
val name = 'Bob';
create user(name, company @ { company.name == 'Amazon' });

```

Can use the created object:

```codeBlockLines_e6Vv
val new_company = create company(name = 'Amazon');
val new_user = create user(name = 'Bob', new_company);
print('Created new user:', new_user);

```

Inserting multiple records:

A new variant of the "create" expression allows for the insertion of multiple database records with a single SQL
statement, improving efficiency compared to inserting records one by one. It accepts a list of structs representing
records of a specific type. If the list is empty, no SQL statement is executed. The expression returns a list of the
inserted entities, maintaining the same size and order as the input list.

```codeBlockLines_e6Vv
create MyEntity(list<struct<MyEntity>>): list<MyEntity>;

```[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Enumeration types, or enums, creates maintainable sets of constants in Rell, enhancing code readability and preventing
errors.

```codeBlockLines_e6Vv
enum account_type {
    single_key_account,
    multi_sig_account
}

entity account {
    key id: byte_array;
    mutable account_type;
    mutable args: byte_array;
}

```

### Enum declaration [â€‹](\#enum-declaration "Direct link to Enum declaration")

Declaring an `enum` involves defining a named collection of related constants. In Rell, each constant is associated with
a unique integer value based on its position within the enum. Here's an example of an `enum` declaration for different
currency types:

```codeBlockLines_e6Vv
enum currency {
    USD,
    EUR,
    GBP
}

```

In this case, `currency` is an enum containing the constants `USD`, `EUR`, and `GBP`.

### Enum usage [â€‹](\#enum-usage "Direct link to Enum usage")

Once an enum is declared, its constants can be used to represent distinct values within your program. For instance:

```codeBlockLines_e6Vv
var c: currency;
c = currency.USD;

```

This snippet demonstrates assigning the `currency.USD` constant to a variable `c`.

`enum` value properties:

- `.name: text` \- the name of the `enum` value.
- `.value: integer` \- the numeric value (index) associated with the `enum` value.

Functions available for all `enum` types:

| Function | Description |
| --- | --- |
| `T.values(): list<T>` | Returns all values of the `enum` in the order of declaration. |
| `T.value(text): T` | Finds a value by name, gives an exception if not found. |
| `T.value(integer): T` | Finds a value by index, gives an exception if not found. |

##### Example [â€‹](\#example "Direct link to Example")

```codeBlockLines_e6Vv
val cs: list<currency> = currency.values()// Returns all values (in the order in which they are declared)

val eur = currency.value("EUR")// Finds enum value by name
val gbp = currency.value(2)// Finds enum value by index

val usd_str: text = currency.USD.name// Returns 'USD'
val usd_value: integer = currency.USD.value
// Returns 0.

```

- `currency.values()`: Retrieves all enum values as a list, maintaining their order of declaration.
- `currency.value('EUR')`: Finds the enum value corresponding to the provided name (e.g., `'EUR'`).
- `currency.value(2)`: Retrieves the enum value based on its index (e.g., the third value, `GBP`).
- `currency.USD.name`: Returns the name of the enum constant (e.g., `'USD'`).
- `currency.USD.value`: Returns the integer value associated with the enum constant (e.g., `0` for `USD`).

- [Enum declaration](#enum-declaration)
- [Enum usage](#enum-usage)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Complex data types in the Rell programming language provide advanced features and capabilities beyond basic types like
integers and strings. They allow for the representation and manipulation of structured data, enabling more sophisticated
programming constructs.

## Nullable types ( `T?`) [â€‹](\#nullable-types-t "Direct link to nullable-types-t")

A nullable type in Rell represents a value that might be absent or undefined. This allows for greater flexibility in
handling optional data.

### Key features [â€‹](\#key-features "Direct link to Key features")

- **Entity attributes**: Cannot be nullable to ensure data integrity.
- **Operators**: Supports `?:`, `?.`, and `!!` operators (similar to Kotlin).
- **Assignments**:
  - Assign a `T` to `T?`, but not the reverse.
  - Assign `null` to `T?`, but not to `T`.
  - Tuple assignments allow `(T)` to be assigned to `(T?)`, but not vice versa.
  - `list<T>` cannot be assigned to `list<T?>`.

#### Examples [â€‹](\#examples "Direct link to Examples")

```codeBlockLines_e6Vv
// Nullable integer function
function f(): integer? {
    return null;
}

function complex_types () {
  val x: integer? = f();  // Nullable integer
  val y = x;              // y is also nullable integer

  val i = y!!;            // Non-null assertion, throws if y is null
  val j = require(y);     // Throws exception if y is null, else assigns y to j

  val a = y ?: 456;       // Elvis operator, assigns y if not null, else 456
  val b = y ?: null;      // b is nullable integer

  val p = y!!;            // Asserts y is non-null
  val q = y?.to_hex();    // Safe call, returns null if y is null

  if (x != null) {
      val u = x;          // type of "u" is "integer" - smart cast is applied to "x"
  } else {
      val v = x;          // type of "v" is "integer?"
  }
}

```

## Tuple [â€‹](\#tuple "Direct link to Tuple")

Tuple offers a concise way to group multiple values of different types into a single, ordered entity.

### Key features [â€‹](\#key-features-1 "Direct link to Key features")

- **Creation**: Enclose elements within parentheses, separated by commas.
- **Access**: By index or by name if named.
  - **By index:** Use numerical indices within square brackets (e.g., `t[0]`).
  - **By name:** Use field names for named tuples (e.g., `named_tuple.x`).
- **Type compatibility**: Tuples are compatible only if elements are identical in order and type.
  - `(x:integer, y:integer)` and `(a:integer,b:integer)` aren't compatible.
  - `(x:integer, y:integer)` and `(integer,integer)` aren't compatible.
- **Unpacking**: Deconstruct tuples into individual variables.

### Examples [â€‹](\#examples-1 "Direct link to Examples")

```codeBlockLines_e6Vv
function complex_types (){
  // Creating tuples
  val single_number: (integer,) = (16,); // Single-element tuple
  val user_tuple: (integer, text) = (26, "Bob"); // Tuple with integer and text
  val named_tuple: (x: integer, y: integer) = (x=32, y=26); // Named tuple. Can access them as `named_tuple.x`, `named_tuple.y`)

  // Accessing elements
  val number = user_tuple[0]; // Access by index
  val name = named_tuple.x;   // Access by name

  // Ignoring elements
  val (_, s) = (123, 'Hello'); // s = 'Hello'
}

// Unpacking tuples
function foo() {
    val t = (123, 'Hello');
    val (n, s) = t; // n = 123, s = 'Hello'
}

// Looping through a list of tuples
function iterateTuples() {
  val l: list<(integer, text)> = [(21, "test")];
  for ((x, y) in l) {
    print(x, y);
  }
}

```

## Range [â€‹](\#range "Direct link to Range")

Ranges represent sequences of numbers, often used in `for` loops and other scenarios requiring iteration.

### Key features [â€‹](\#key-features-2 "Direct link to Key features")

- **Syntax**: `range(start: integer = 0, end: integer, step: integer = 1)` \- start-inclusive, end-exclusive.

- **Inclusive start, exclusive end**: The generated sequence includes the `start` value but excludes the `end` value (as
in Python).

- **Customizable step**: The `step` argument controls the increment or decrement between consecutive values.


### Examples [â€‹](\#examples-2 "Direct link to Examples")

```codeBlockLines_e6Vv
function ranges() {
  // Range examples
  val r1 = range(10);          // 0 to 9
  val r2 = range(5, 10);       // 5 to 9
  val r3 = range(5, 15, 4);    // 5, 9, 13
  val r4 = range(10, 5, -1);   // 10 to 6
  val r5 = range(10, 5, -3);   // 10, 7

  // Checking membership
  if (3 in r1) {
      print("3 is in the range");
  }
}

```

### Special operators [â€‹](\#special-operators "Direct link to Special operators")

- `in` \- returns `true` if the value is in the range (taking `step` into account).

## GTV [â€‹](\#gtv "Direct link to GTV")

GTV is used to represent encoded arguments and results of remote operations and query calls. It can be a simple value,
an array of values, or a string-keyed dictionary.

Queries return data in GTV format like:

```codeBlockLines_e6Vv
query get_all_books() {
  return (
    .title = "Hello Chromia",
    .author = "Chromia"
  ).to_gtv();
}

```

### Key features [â€‹](\#key-features-3 "Direct link to Key features")

- **Compatibility**: Some Rell types aren't GTV-compatible.
- **Functions**: Provides methods to convert between GTV and other types.

### Functions [â€‹](\#functions "Direct link to Functions")

| Function | Description |
| --- | --- |
| `gtv.from_json(text): gtv` | Decodes a `gtv` from a `JSON` string. |
| `gtv.from_json(json): gtv` | Decodes a `gtv` from a `json` value. |
| `gtv.from_bytes(byte_array): gtv` | Decodes a `gtv` value from its binary-encoded form. |
| `gtv.from_bytes_or_null(byte_array): gtv?` | Same as `gtv.from_bytes(byte_array)`, but returns `null` instead of an error if the byte array is not valid. |
| `.to_json(): json` | Converts the `gtv` value to JSON. |
| `.to_bytes(): byte_array` | Converts the `gtv` value to bytes. |
| `.hash(): byte_array` | Returns a cryptographic hash of the `gtv` value, ensuring its integrity. |

### GTV-related functions [â€‹](\#gtv-related-functions "Direct link to GTV-related functions")

Functions available for all GTV-compatible types:

| Function | Description |
| --- | --- |
| `T.from_gtv(gtv): T` | Decode from a `gtv`. |
| `T.from_gtv_pretty(gtv): T` | Decode from a pretty-encoded `gtv`. |
| `.to_gtv(): gtv` | Convert to a `gtv`. |
| `null.to_gtv()` | Returns the `gtv` equivalent of null. |
| `.to_gtv_pretty(): gtv` | Convert to a pretty `gtv`. |
| `.hash(): byte_array` | Returns a cryptographic hash of the `gtv` value, ensuring its integrity. Same as `.to_gtv().hash()`. |

#### Example [â€‹](\#example "Direct link to Example")

```codeBlockLines_e6Vv
function foo() {
  val g = [1, 2, 3].to_gtv();              // Converts a list to GTV
  val l = list<integer>.from_gtv(g);       // Converts GTV back to a list
  print(l);                                // Outputs: [1, 2, 3]
  print(g.hash());                         // Prints the hash value of the GTV
}

```

- [Nullable types ( `T?`)](#nullable-types-t)
  - [Key features](#key-features)
- [Tuple](#tuple)
  - [Key features](#key-features-1)
  - [Examples](#examples-1)
- [Range](#range)
  - [Key features](#key-features-2)
  - [Examples](#examples-2)
  - [Special operators](#special-operators)
- [GTV](#gtv)
  - [Key features](#key-features-3)
  - [Functions](#functions)
  - [GTV-related functions](#gtv-related-functions)- [@chromia/ft4](../index.html)
- [utils](../modules/utils.html)
- [Filter](utils.Filter.html)

# Type alias Filter<T>

Filter< [T](utils.Filter.html#T) >:{

\[K in keyof [T](utils.Filter.html#T)\]: [T](utils.Filter.html#T)\[K\]\[\] \| null

} \| undefined

#### Type Parameters

- T extends Record<string, any>

### Settings

#### Member Visibility

- Protected
- Private
- Inherited

#### Theme

OSLightDark[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Namespaces provide essential structure and clarity to your Rell projects, allowing for better organization and
modularization of code.

Namespaces have the following characteristics:

- **Simplified referencing**: Within a namespace, you can use identifiers directly without specifying the full name. For
example, use `country` instead of `foo.country` when inside the `foo` namespace.
- **Qualified table names**: Tables for entities and objects defined in a namespace include the full namespace path in
their names. For instance, the table for entity `foo.user` is named `c0.foo.user`.
- **Multiple definitions**: You can define a namespace with the same name multiple times, each with different inner
definitions, allowing for distributed declarations across files.

##### Basic namespace usage [â€‹](\#basic-namespace-usage "Direct link to Basic namespace usage")

```codeBlockLines_e6Vv
namespace foo {
    entity user {
        name;
        country;
    }

    struct point {
        x: integer;
        y: integer;
    }

    enum country {
        USA,
        DE,
        FR
    }
}

query get_users_by_country(c: foo.country) = foo.user @* { .country == c };

```

## Anonymous namespaces [â€‹](\#anonymous-namespaces "Direct link to Anonymous namespaces")

Anonymous namespaces allow for focused organization or applying annotations to a group of definitions without creating a
named namespace.

##### Example [â€‹](\#example "Direct link to Example")

```codeBlockLines_e6Vv
namespace {
    // some definitions
}

```

You can use it to apply an annotation to a set of definitions:

```codeBlockLines_e6Vv
@mount('foo.bar')
namespace {
    entity user {}
    entity company {}
}

```

## Nested namespaces [â€‹](\#nested-namespaces "Direct link to Nested namespaces")

Create hierarchical structures using nested namespaces for fine-grained organization. You can use nested namespaces for
complex projects with multiple layers of organization.

##### Short notation: [â€‹](\#short-notation "Direct link to Short notation:")

```codeBlockLines_e6Vv
namespace x.y.z {
        function f() = 123;
}

```

##### Equivalent expanded notation: [â€‹](\#equivalent-expanded-notation "Direct link to Equivalent expanded notation:")

```codeBlockLines_e6Vv
namespace x {
    namespace y {
        namespace z {
            function f() = 123;
        }
    }
}

```

## Splitting namespaces across files [â€‹](\#splitting-namespaces-across-files "Direct link to Splitting namespaces across files")

For improved modularity, you can distribute namespace members across multiple files within a module. When splitting
namespaces across files, ensure consistent naming and organization.

##### Example [â€‹](\#example-1 "Direct link to Example")

```codeBlockLines_e6Vv
// lib/a.rell
namespace ns {
    function f(): integer = 123;
}

// lib/b.rell
namespace ns {
    function g(): integer = 456;
}

// main.rell
import .lib;

function main() {
    print(lib.ns.f()); // Outputs: 123
    print(lib.ns.g()); // Outputs: 456
}

```

- [Anonymous namespaces](#anonymous-namespaces)
- [Nested namespaces](#nested-namespaces)
- [Splitting namespaces across files](#splitting-namespaces-across-files)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In Rell, local variables play a important role in storing and managing data within a specific scope. They provide a way
to temporarily hold values that can be manipulated, utilized, or referenced within a limited context.

### Constants in Rell [â€‹](\#constants-in-rell "Direct link to Constants in Rell")

Constants are values that can't be changed after initiation. They may exist outside the scope of a function. They are
declared using the `val` keyword, followed by an identifier and an assigned value. Here are some examples:

```codeBlockLines_e6Vv
val x = 123;
val y: text = 'Hello';

```

### Variables in Rell [â€‹](\#variables-in-rell "Direct link to Variables in Rell")

Variables are declared using the `var` keyword. However, unlike constants, variables allow for value modification within
their scope. They can't exist outside the scope of a function. Here are some examples:

```codeBlockLines_e6Vv
var x: integer;
var y = 123;
var z: text = 'Hello';

```

- [Constants in Rell](#constants-in-rell)
- [Variables in Rell](#variables-in-rell)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

### `rell.get_rell_version(): text` [â€‹](\#rellget_rell_version-text "Direct link to rellget_rell_version-text")

Retrieves Rell's version information.

**Returns:**

- A string containing the Rell version (e.g., "0.10.1")

### `rell.get_postchain_version(): text` [â€‹](\#rellget_postchain_version-text "Direct link to rellget_postchain_version-text")

Retrieves Postchain's version information.

**Returns:**

- A string containing the Postchain version (e.g., "3.0.0").

### `rell.get_build(): text` [â€‹](\#rellget_build-text "Direct link to rellget_build-text")

Retrieves Rell's detailed build information.

**Returns:**

- A string containing the Rell build description (e.g., "rell: 0.10.1; postchain: 3.0.0; time: 2019-11-25T17:25:52+0000;
branch: v0.10.1; commit: f875de6 (2019-11-25T10:37:18+0000); dirty: true").

### `rell.get_build_details(): map<text, text>` [â€‹](\#rellget_build_details-maptext-text "Direct link to rellget_build_details-maptext-text")

Retrieves Rell's detailed build information as a key-value map.

**Returns:**

- A dictionary containing Rell's build details (e.g., keys: "rell.version", "rell.commit.id").





```codeBlockLines_e6Vv
rell.branch:                 v0.10.1
rell.build.time:             2019-11-25T17:25:52+0000
rell.version:                0.10.1
rell.commit.id:              f875de6
rell.commit.id.full:         f875de60555284a53442e072e4fd4dda0029f792
rell.commit.message.short:   Commit message...
rell.commit.message.full:    Commit message...
rell.commit.time:            2019-11-25T10:37:18+0000
rell.dirty:                  true
postchain.version:           3.0.0
kotlin.version:              1.3.21

```


### `rell.get_app_structure(): map<text, gtv>` [â€‹](\#rellget_app_structure-maptext-gtv "Direct link to rellget_app_structure-maptext-gtv")

Shows how your Rell dapp is built, revealing its modules and definitions. Definitions are entities, objects, structs,
enums, operations, queries and functions.

**Returns:**

- The type of the return value is GTV. Attributes (values) of entities, objects, structs and enums are returned as an
array.

Rell code example:





```codeBlockLines_e6Vv
      struct module_args {
          x: integer;
          y: text;
      }

```









Corresponding app structure example (fragment):





```codeBlockLines_e6Vv
      {
          "structs": {
              "module_args": {
                  "attributes": [\
                      { "mutable": 0, "name": "x", "type": "integer" },\
                      { "mutable": 0, "name": "y", "type": "text" }\
                  ]
              }
          }
      }

```


- [`rell.get_rell_version(): text`](#rellget_rell_version-text)
- [`rell.get_postchain_version(): text`](#rellget_postchain_version-text)
- [`rell.get_build(): text`](#rellget_build-text)
- [`rell.get_build_details(): map<text, text>`](#rellget_build_details-maptext-text)
- [`rell.get_app_structure(): map<text, gtv>`](#rellget_app_structure-maptext-gtv)[Skip to main content](#__docusaurus_skipToContent_fallback)

In Rell, once data is stored within `block` and `transaction` entities, it becomes immutable, meaning it cannot be
altered, modified, or deleted through code execution. This immutability contributes to the integrity of the blockchain
data, ensuring a reliable and tamper-resistant historical record.

```codeBlockLines_e6Vv
entity block {
    block_height: integer;
    block_rid: byte_array;
    timestamp;
}

entity transaction {
    tx_rid: byte_array;
    tx_hash: byte_array;
    tx_data: byte_array;
    block;
}

```

It's impossible to create, modify, or delete the values of these entities in the code.[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In Rell, the fundamental building blocks of programming are encapsulated within basic statements. These statements
enable you to perform a wide range of operations, from assigning values to variables to executing functions and
controlling program flow.

### Assignment statements [â€‹](\#assignment-statements "Direct link to Assignment statements")

Assignment statements allow you to assign values to variables or data structures. This is a core operation for
manipulating data within your program. Examples include:

```codeBlockLines_e6Vv
x = 123;
values[i] = z;
y += 15;

```

Here, you set the value of `x`, assign `z` to an element in the `values` array, and increment the value of `y` by 15.

### Function call statements [â€‹](\#function-call-statements "Direct link to Function call statements")

Function call statements involve invoking functions or procedures to execute specific tasks. For instance:

```codeBlockLines_e6Vv
print('Hello');

```

In this example, the `print` function is called, outputting "Hello" to the console.

### Return statements [â€‹](\#return-statements "Direct link to Return statements")

Return statements are used to exit functions or procedures, optionally returning a value. Examples include:

```codeBlockLines_e6Vv
return;
return 123;

```

These statements allow you to exit the current function or procedure. The second return statement additionally returns
the value `123`.

### Block statements [â€‹](\#block-statements "Direct link to Block statements")

Block statements group multiple statements together within a code block. This aids in organizing code and controlling
variable scope. For example:

```codeBlockLines_e6Vv
{
    val x = calc();
    print(x);
}

```

Here, a code block is used to encapsulate the assignment of `x` and the subsequent function call to `print`.

- [Assignment statements](#assignment-statements)
- [Function call statements](#function-call-statements)
- [Return statements](#return-statements)
- [Block statements](#block-statements)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Entities in Rell are persistent data structures that reside in the database, not in memory. This means they offer
long-term storage and can be explicitly managed using the `create` and `delete` expressions. Structs in Rell are similar
to entities in concept but reside in memory, offering temporary data storage within code execution.

A variable of an entity type holds an ID (primary key) of the corresponding database record but not its attribute
values.

```codeBlockLines_e6Vv
entity company {
    name: text;
    address: text;
}

entity user {
    first_name: text;
    last_name: text;
    year_of_birth: integer;
    mutable salary: integer;
}

```

If the attribute type is not specified, it's the same as the attribute name:

```codeBlockLines_e6Vv
entity user {
    name;       // built-in type "name"
    company;    // user-defined type "company" (error if no such type)
}

```

Attributes may have default values which are applied when the entity is created, but not specified:

```codeBlockLines_e6Vv
entity user {
    home_city: text = 'New York';
}

```

You can use the `rowid` implicit attribute (type `rowid`) to get an entity value's ID (primary database key).

```codeBlockLines_e6Vv
val u = user @ { .name == 'Bob' };
print(u.rowid);

val alice_id = user @ { .name == 'Alice' } ( .rowid );
print(alice_id);

```

## Unique keys and indices [â€‹](\#unique-keys-and-indices "Direct link to Unique keys and indices")

Entities in Rell can be associated with a `key` or an `index`, allowing for organized and efficient data access.

- **Keys**: A `key` is a unique identifier for an entity, ensuring its distinctiveness within the blockchain. Declare a
set of attributes as a `key` to guarantee that no two entities share the same combination of values for those
attributes. This maintains data integrity and prevents duplicates.
- **Indices**: An `index` facilitates fast querying of entities based on specific attributes. Simply put, an index is a
pointer to data in a table. Create an `index` on specific attributes to significantly speed up queries that filter or
retrieve entities based on those attributes. Think of them as specialized pointers that guide you directly to the
relevant data.

```codeBlockLines_e6Vv
entity user {
    name: text;
    address: text;
    key name;
    index address;
}

```

Keys and indices may have multiple attributes:

```codeBlockLines_e6Vv
entity user {
    first_name: text;
    last_name: text;
    key first_name, last_name;
}

```

In this example, you can have multiple with the same `first_name` or `last_name` but not with the combination of both.

You can specify mutability within a key or index clause. Here one can also set a default value:

```codeBlockLines_e6Vv
entity address{
    index mutable city: text = 'Rome';
}

```

note

Mutating an indexed field may be slow if there are many rows in the table.

You can combine attribute definitions with `key` or `index` clauses, but such definition has restrictions (can't specify
`mutable`):

```codeBlockLines_e6Vv
entity user {
    key first_name: text, last_name: text;
    index address: text;
}

```

## Relations [â€‹](\#relations "Direct link to Relations")

Relations in Rell define how entities are connected to each other in the database. They allow you to model the
relationships between different entities, ensuring data integrity and efficient querying. There are several types of
relations, each serving a specific purpose in organizing and accessing data.

### One-to-one [â€‹](\#one-to-one "Direct link to One-to-one")

A one-to-one relation ensures that a record in one entity is linked to a single record in another entity. This type of
relation is used when an entity needs to have a unique association with another entity.

For example, if we want each user to have a unique residence address:

```codeBlockLines_e6Vv
entity residence {
    key user;
    key address;  // Ensures that each address can be associated with at most one user
}

```

Here, the user and address both serve as keys, ensuring that each user can have only one address and each address can be
assigned to only one user.

```codeBlockLines_e6Vv
function get_addresses(user): list<address> = residence @* { user }.address; //will only return zero or one addresses

function get_users(address): list<user> = residence @* { address }.user; // will only return zero to one users

```

These functions enforce the one-to-one relationship by ensuring the uniqueness constraint on both user and address.

### One-to-many [â€‹](\#one-to-many "Direct link to One-to-many")

A one-to-many or many-to-one relation means a single record in one entity can be linked to multiple records in another
entity. This type of relation is used when an entity needs to have multiple associations with another entity, and vice
versa.

For example, if a user can have multiple residences, and a residence can belong to one user:

```codeBlockLines_e6Vv
entity residence {
  key user;
  index address;
}

```

Here, the user is a key, ensuring that each user can have multiple addresses, but each address is indexed for faster
querying.

Functions to query this relationship:

```codeBlockLines_e6Vv
//There is a unique constraint on the user key.
function get_addresses(user): list<address> = residence @* { user }.address; //will only return zero or one addresses

function get_users(address): list<user> = residence @* { address }.user; // will return zero to n users

```

This setup allows a user to have multiple addresses and provides a way to retrieve all addresses associated with a user
or all users associated with an address.

To reverse the relationship, where multiple users can share a single address:

```codeBlockLines_e6Vv
entity residence {
  index user;
  key address;
}

```

This setup allows multiple users to share the same address and provides a way to retrieve all users associated with a
particular address.

### Many-to-many [â€‹](\#many-to-many "Direct link to Many-to-many")

A many-to-many relation allows multiple records in one entity to be linked to multiple records in another entity. This
type of relation is used when there is a need for a complex association between entities.

For example, if users can have multiple addresses and each address can belong to multiple users:

```codeBlockLines_e6Vv
entity user {
  key pubkey;
  index name;
}

entity address {
  key pubkey;
  street: text;
}

entity residence {
  key user, address;
}

```

Here, the composite key (user, address) ensures that each combination of user and address is unique, allowing multiple
users to be associated with multiple addresses.

Functions to query this relationship:

```codeBlockLines_e6Vv
//both queries will result lists of records, as it is a many-to-many relationships
//they might be of different sizes. The constraint is that the composite of the two keys are unique.
function get_addresses(user): list<address> = residence @* { user }.address;
function get_users(address): list<user> = residence @* { address }.user;

```

info

If you're interested in learning more about relationships, consider exploring our course
[Understand Relationships in Rell](https://learn.chromia.com/courses/relationships-course/introduction).

## Annotations [â€‹](\#annotations "Direct link to Annotations")

You can transform entities into immutable historical records by applying the `@log` annotation:

```codeBlockLines_e6Vv
@log entity user {
    name: text;
}

```

The `@log` annotation has the following effects:

- **Transaction context**: Automatically adds a `transaction` attribute of type `transaction` to each entity instance,
capturing its creation within a specific transaction.
- **Immutable nature**: Prevents any modifications to attributes or deletion of instances, ensuring the integrity of
historical data.
- **Automatic timestamp**: Effectively creates a timestamped log of entity events, providing a transparent and auditable
history of data changes.

## Changing entity definitions [â€‹](\#changing-entity-definitions "Direct link to Changing entity definitions")

When you start a Rell dapp, a database structure update happens: tables for new entities and objects get created, and
tables for existing ones get altered. There are limitations on changes that you can make in the existing entities and
objects.

### Compatible changes [â€‹](\#compatible-changes "Direct link to Compatible changes")

- **Adding attributes with defaults**: Seamlessly introduce new attributes to your entity. Each existing record will
receive the defined default value, ensuring predictable behavior.
- **Adding attributes to empty tables**: If no data has been stored yet, you can freely add additional attributes, even
without default values, for future use.
- **Removing attributes**: Declutter your entity by removing attributes. The corresponding database column will be
retained, allowing you to access historical data if needed.
- **Changing attribute mutability**: You can alter an attribute's mutability (from non-mutable to mutable or vice versa)
for entities that are not annotated with `@log`. This provides flexibility in managing attribute update behaviors.

### Incompatible changes [â€‹](\#incompatible-changes "Direct link to Incompatible changes")

- **Key/Index modifications**: Changes to keys or indices can impact data integrity and query performance. Consider
alternative approaches like creating new entities or using versions if significant structural modifications are
necessary.

- **Attribute type changes**: Changing an attribute's type risks compatibility issues and data corruption. Plan your
entity structures effectively to minimize the need for such adjustments.

**Adding/Removing `@log` annotation**: Once you choose the 'immutable history' path with `@log`, you can't switch
back. Adding the annotation to existing entities or removing it entirely is not supported.


- [Unique keys and indices](#unique-keys-and-indices)
- [Relations](#relations)
  - [One-to-one](#one-to-one)
  - [One-to-many](#one-to-many)
  - [Many-to-many](#many-to-many)
- [Annotations](#annotations)
- [Changing entity definitions](#changing-entity-definitions)
  - [Compatible changes](#compatible-changes)
  - [Incompatible changes](#incompatible-changes)- [@chromia/ft4](../index.html)
- [asset](../modules/asset.html)
- [LockAccount](asset.LockAccount.html)

# Type alias LockAccount

LockAccount:{

account: [Account](../interfaces/accounts.Account.html);

type: string;

}

#### Type declaration

- ##### account: [Account](../interfaces/accounts.Account.html)

- ##### type: string


### Settings

#### Member Visibility

- Protected
- Private
- Inherited

#### Theme

OSLightDark[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Rell provides several built-in functions for database operations. Rell allows both the comma notation and the `and`
notation for defining records. However, they are not completely equivalent.

The comma notation allows for shortcut expressions with just a variable name. The keys of the record are automatically
set to the variable names used in the expression, and the corresponding values are the values of the variables.

On the other hand, the `and` notation requires complete expressions for each key-value pair in the record. This notation
allows for more complex expressions that involve logical operators and comparisons.

For example, in the following code:

```codeBlockLines_e6Vv
val name = 'Bill';
val company = 'Microsoft';
return user @ { name, company };

```

The record being returned has two keys: `name` and `company`. The values of these keys are set to the values of the
`name` and `company` variables, respectively. This shorthand is a convenient way to create a record with simple
key-value pairs, but it's important to note that it may not be suitable for more complex expressions.

The `and` notation expression should be complete as follows:

```codeBlockLines_e6Vv
return user @ { .name == name and .company == company };

```

## `@` operator [â€‹](\#-operator "Direct link to -operator")

You can use the at operator, to retrieve database records. The general syntax consists of five parts, some of which you
can omit: `<from> <cardinality> { <where> } [<what>] [limit N]`

**Simplest form**

`user @ { .name == 'Bob' }`

### Cardinality [â€‹](\#cardinality "Direct link to Cardinality")

Specifies whether the expression must return one or many objects:

- `T @? {}` \- returns `T?`, zero or one, fails if more than one is found.
- `T @ {}` \- returns `T`, exactly one, fails if zero or more than one is found.
- `T @* {}` \- returns `list<T>`, zero or more.
- `T @+ {}` \- returns `list<T>`, one or more, fails if none found.

### From part [â€‹](\#from-part "Direct link to From part")

You declare the from-part before `@`. It specifies the entity type that's retrieved.

**Simple (one entity)**

```codeBlockLines_e6Vv
user @* { .name == 'Bob' }

```

**Complex (one or more entities)**

```codeBlockLines_e6Vv
(user, company) @* { user.name == 'Bob' and company.name == 'Microsoft' and user.xyz == company.xyz }

```

**Specifying entity aliases**

```codeBlockLines_e6Vv
(u: user) @* { u.name == 'Bob' }

```

```codeBlockLines_e6Vv
(u: user, c: company) @* { u.name == 'Bob' and c.name == 'Microsoft' and u.xyz == c.xyz }

```

### Where part [â€‹](\#where-part "Direct link to Where part")

You declare the where-part after `@`. It specifies the entity type that's retrieved based on attributes. You can filter
the records by zero or more comma-separated expressions using entity attributes, local variables, or system functions.

- `user @* {}` \- returns all users.
- `user @ { .name == 'Bill', .company == 'Microsoft' }` \- returns a specific user (all conditions must match).
- Can access attributes of an entity with a dot, e. g. `.name` or with an entity name or alias, `user.name`.

Entity attributes are also matched implicitly by name or type.

```codeBlockLines_e6Vv
val ms = company @ { .name == 'Microsoft' };
val name = 'Bill';
return user @ { name, ms };

```

**Explanation**: The first where-expression is the local variable `name`, there is an attribute called `name` in the
entity `user`. The second expression is `ms`, there is no such attribute, but the type of the local variable `ms` is
`company`, and there is an attribute of type `company` in `user`.

### What part [â€‹](\#what-part "Direct link to What part")

You declare the what-part after the where-part to specify the record attributes for retrieval.

- `user @ { .name == 'Bob' } ( .company.name )` \- returns a single value (name of the user's company).
- `user @ { .name == 'Bob' } ( .company.name, .company.address )` \- returns a tuple of two values.

**Sorting**

You can sort tuples by using the @sort (ascending) and @sort\_desc (descending) annotations.

- `user @* {} ( @sort .last_name, @sort .first_name )` \- sort by `last_name` first, then by `first_name`
- `user @* {} ( @sort_desc .year_of_birth, @sort .last_name )` \- sort by `year_of_birth` descending, then by `last_name`
ascending

**Result tuple fields**

Returned tuples can have named fields.

- `user @* {} ( x = .company.name, y = .company.address, z = .year_of_birth )` \- returns a tuple with named fields ( `x`,
`y`, `z`)
- `user @* {} ( @sort x = .last_name, @sort_desc y = .year_of_birth )` \- can combine field names with sorting

When field names aren't specified explicitly, you can infer them implicitly from the attribute name:

```codeBlockLines_e6Vv
val u = user @ { ... } ( .first_name, .last_name, age = 2018 - .year_of_birth );
print(u.first_name, u.last_name, u.age);

```

By default, if a field name isn't specified and the expression is a single name (an attribute of an entity), then you
can use that name as a tuple field name:

```codeBlockLines_e6Vv
val u = user @ { ... } ( .first_name, .last_name );
// Result is a tuple (first_name: text, last_name: text).

```

To have a tuple field without a name, use `_` as field name:

```codeBlockLines_e6Vv
val u = user @ { ... } ( _ = .first_name, _ = .last_name );
// Result is a tuple (text, text).

```

To exclude a field from the result tuple, use `@omit` annotation:

```codeBlockLines_e6Vv
val us = user @* {} ( .last_name, @omit .first_name ) ;
// Result is list<text>, since first_name is excluded, so there is only one expression to return

```

The possibility to exclude a field is useful, for example, when one needs to sort by some expression but doesn't want to
include that expression into the result tuple:

```codeBlockLines_e6Vv
val sorted_users = user @* { } ( _ = .first_name, _ = .last_name, @omit @sort .date_of_birth );
// Returns list<(text,text)>.

```

### Tail part [â€‹](\#tail-part "Direct link to Tail part")

You declare the tail part after the what-part and filter the returned tuples. You can do this by limiting and skipping
records.

**Limiting records**

- `user @* { .company == 'Microsoft' } limit 10` \- Returns at most 10 objects.

The cardinality test happens before the limit applies, so the following code can't fail with the "more than one object"
error:

- `val u: user = user @ { .company == 'Microsoft' } limit 1;` \- Returns one record.

**Skipping records**

- `user @* {}(@sort .company) offset 10`\- Skips the first ten records in the table, and can use it alongside limit to
specify a subset within the found records.
- `people @* {}(@sort .age) offset 10 limit 20` \- Returns the eleventh youngest up to the thirtieth youngest person.

### Result type [â€‹](\#result-type "Direct link to Result type")

The Result type depends on the cardinality, from- and what-parts.

- From- and what-parts define the type of a single record, `T`.
- Cardinality defines the type of the @-operator result: `T?`, `T` or `list<T>`.

**Examples**

- `user @ { ... }` \- returns `user`
- `user @? { ... }` \- returns `user?`
- `user @* { ... }` \- returns `list<user>`
- `user @+ { ... }` \- returns `list<user>`
- `(user, company) @ { ... }` \- returns a tuple `(user,company)`
- `(user, company) @* { ... }` \- returns `list<(user,company)>`
- `user @ { ... } ( .name )` \- returns `text`
- `user @ { ... } ( .first_name, .last_name )` \- returns `(first_name:text,last_name:text)`
- `(user, company) @ { ... } ( user.first_name, user.last_name, company )` \- returns `(text,text,company)`

### Nested at operators [â€‹](\#nested-at-operators "Direct link to Nested at operators")

You can use a nested at-operator in any expression inside another at-operator:

```codeBlockLines_e6Vv
user @* { .company == company @ { .name == 'Microsoft' } } ( ... )

```

This is equivalent to:

```codeBlockLines_e6Vv
val c = company @ { .name == 'Microsoft' };
user @* { .company == c } ( ... )

```

### Inner Join [â€‹](\#inner-join "Direct link to Inner Join")

Each entity in an at-expression can have its own where-expression, which is translated into SQL JOIN ON clause. So
instead of

```codeBlockLines_e6Vv
(u: user, c: contract) @* { c.user == u } ( u, c )

```

one can write:

```codeBlockLines_e6Vv
(
    u: user,
    c: contract @* { c.user == u }
) @* {} ( u, c )

```

The first expression is translated into SQL like:

```codeBlockLines_e6Vv
SELECT U.rowid, C.rowid FROM user U, contract C WHERE C.user = U.rowid

```

while the second one is translated into:

```codeBlockLines_e6Vv
SELECT U.rowid, C.rowid FROM user U JOIN contract C ON C.user = U.rowid

```

The two statements do the same, as inner joins are used by default. But the new syntax makes a difference when using
outer joins.

### Outer Join [â€‹](\#outer-join "Direct link to Outer Join")

With the new join syntax, one can use @outer annotation to make an Outer Join:

```codeBlockLines_e6Vv
(
    u: user,
    @outer c: contract @* { c.user == u }
) @* {} ( u, c )

```

This expression is translated into SQL like:

```codeBlockLines_e6Vv
SELECT U.rowid, C.rowid FROM user U LEFT OUTER JOIN contract C ON C.user = U.rowid

```

If there is no matching "contract" for a "user", a null "contract" record is added to the result set. In contrast, for a
default (Inner) Join, the "user" record wouldn't be added to the result set if there is no matching "contract".

When Outer Join is used, the type of "c" is "contract?", not "contract". This means its attributes can't be accessed
directly, and one shall use null-handling operators, like "?." or "?:".

### Aggregate functions and grouping [â€‹](\#aggregate-functions-and-grouping "Direct link to Aggregate functions and grouping")

You can use @group, @min, @max, and @sum to express equivalents to SQL statements GROUP BY, MIN, MAX, and SUM.

- To calculate an aggregated value (min/max/sum) use @min, @max or @sum.
- annotate with @group to group by an attribute or an expression
- To calculate the count, use @sum 1.

**Example entity**

```codeBlockLines_e6Vv
entity city {
    name;
    country: text;
    population: integer;
}

```

**Examples**

To calculate the number of cities in every country and group it by country, one can write:

```codeBlockLines_e6Vv
city@*{}
( @group
.country, @sum
1 )

```

The result is a list of tuples (text, integer) - (country name, number of cities).

You can calculate the total population of all cities in each country by:

```codeBlockLines_e6Vv
city@*{}
( @group
.country, @sum
1, @sum
.population )

```

You can annotate more than one expression with @group to group by multiple values.

### Collection annotations [â€‹](\#collection-annotations "Direct link to Collection annotations")

Similarly to the aggregation annotations @sum, @min, and @max, there are now annotations to collect values into
collections: @list, @set, and @map.

- `@list T`: returns `list<T>`.
- `@set T`: returns `set<T>`.
- `@map (K, V)`: accepts a two-element tuple, returns `map<K, V>`, fails on key conflict.

**Usage**

```codeBlockLines_e6Vv
entity data { k: integer; v: text; }

data @ {} ( @list .v )           // returns list<text>
data @ {} ( @set .v )            // returns set<text>
data @ {} ( @map (.k, .v) )      // returns map<integer, text>

```

**With grouping**

- `data @* {} ( @group .k, @list .v )` \- returns `list<(integer,list<text>)>`
- `data @* {} ( @group .k, @set .v )` \- returns `list<(integer,set<text>)>`

To group values into a map of lists, combine two at-expressions:

`data @* {} ( @group .k, @list .v ) @ {} ( @map $ )` \- returns `map<integer,list<text>>`

- First at-expression `@*` returns `list<(integer,list<text>)>`.
- Second at-expression `@` converts `list<(integer,list<text>)>` to `map<integer,list<text>>`.

**Notes**

- Expression data `@ {} ( @list .v )` returns `list<text>`, but data `@* {} ( @list .v )` returns `list<list<text>>`,
which always has one element of type `list<text>`.
- When annotation @list, @set or @map is used in a database at-expression, all values (which match the where part) are
read from the database without grouping and aggregation, and then grouped and aggregated in memory.

### Sorting [â€‹](\#sorting "Direct link to Sorting")

You can use @sort with or without the @omit statement to sort.

```codeBlockLines_e6Vv
city@*{}
( @group
.country, @omit
@sort_desc
@sum
1 )

```

In this example, you sort the countries by the number of cities in descending order. You can see that because the @omit
statement is present, hence the number of cities isn't displayed in the result.

### Field names [â€‹](\#field-names "Direct link to Field names")

You can specify tuple field names after annotations:

```codeBlockLines_e6Vv
city@*{}
( @group
.country, @sum
city_count = 1, @sum
total_population = .population )

```

## `$` operator [â€‹](\#-operator-1 "Direct link to -operator-1")

The `$` operator is used to denote the current item within an at-expression. If the item type includes attributes, you
can access them using attribute notation. For instance, if the item has an attribute named `name`, you can access it as
follows: `$.name`.

- [`@` operator](#-operator)
  - [Cardinality](#cardinality)
  - [From part](#from-part)
  - [Where part](#where-part)
  - [What part](#what-part)
  - [Tail part](#tail-part)
  - [Result type](#result-type)
  - [Nested at operators](#nested-at-operators)
  - [Inner Join](#inner-join)
  - [Outer Join](#outer-join)
  - [Aggregate functions and grouping](#aggregate-functions-and-grouping)
  - [Collection annotations](#collection-annotations)
  - [Sorting](#sorting)
  - [Field names](#field-names)
- [`$` operator](#-operator-1)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Rell has a diverse collection of built-in functions that you can use to perform common tasks and write efficient Rell
code.

## Essential calculations [â€‹](\#essential-calculations "Direct link to Essential calculations")

### `abs(value: integer): integer` [â€‹](\#absvalue-integer-integer "Direct link to absvalue-integer-integer")

Gets the absolute value of an integer.

**Parameters:**

- `value: integer` \- The integer for which to calculate the absolute value.

**Returns:**

- The absolute value of the input `value` as an integer.

### `abs(value: big_integer): big_integer` [â€‹](\#absvalue-big_integer-big_integer "Direct link to absvalue-big_integer-big_integer")

Gets the absolute value of a big integer.

**Parameters:**

- `value: big_integer` \- The big integer for which to calculate the absolute value.

**Returns:**

- The absolute value of the input `value` as a big integer.

### `abs(value: decimal): decimal` [â€‹](\#absvalue-decimal-decimal "Direct link to absvalue-decimal-decimal")

Gets the absolute value of a decimal.

**Parameters:**

- `value: decimal` \- The decimal for which to calculate the absolute value.

**Returns:**

- The absolute value of the input `value` as a decimal.

### `function max(value1: integer, value2: integer): integer` [â€‹](\#function-maxvalue1-integer-value2-integer-integer "Direct link to function-maxvalue1-integer-value2-integer-integer")

Identifies the larger of two integer values.

**Parameters:**

- `value1: integer` \- The first integer to compare.
- `value2: integer` \- The second integer to compare.

**Returns:**

- The larger of the two input integers.

### `function max(value1: big_integer, value2: big_integer): big_integer` [â€‹](\#function-maxvalue1-big_integer-value2-big_integer-big_integer "Direct link to function-maxvalue1-big_integer-value2-big_integer-big_integer")

Determines the larger of two big integer values.

**Parameters:**

- `value1: big_integer` \- The first big integer to compare.
- `value2: big_integer` \- The second big integer to compare.

**Returns:**

- The larger of the two input big integers.

### `function max(value1: decimal, value2: decimal): decimal` [â€‹](\#function-maxvalue1-decimal-value2-decimal-decimal "Direct link to function-maxvalue1-decimal-value2-decimal-decimal")

Determines the larger of two decimal values.

**Parameters:**

- `value1: decimal` \- The first decimal to compare.
- `value2: decimal` \- The second decimal to compare.

**Returns:**

- The larger of the two input decimals.

### `function min(value1: integer, value2: integer): integer` [â€‹](\#function-minvalue1-integer-value2-integer-integer "Direct link to function-minvalue1-integer-value2-integer-integer")

Determine the smaller of two integer values.

**Parameters:**

- `value1: integer` \- The first integer to compare.
- `value2: integer` \- The second integer to compare.

**Returns:**

- The smaller of the two input integers.

### `function min(value1: big_integer, value2: big_integer): big_integer` [â€‹](\#function-minvalue1-big_integer-value2-big_integer-big_integer "Direct link to function-minvalue1-big_integer-value2-big_integer-big_integer")

Identify the smaller of two big integer values.

**Parameters:**

- `value1: big_integer` \- The first big integer to compare.
- `value2: big_integer` \- The second big integer to compare.

**Returns:**

- The smaller of the two input big integers.

### `function min(value1: decimal, value2: decimal): decimal` [â€‹](\#function-minvalue1-decimal-value2-decimal-decimal "Direct link to function-minvalue1-decimal-value2-decimal-decimal")

Pinpoint the smaller of two decimal values.

**Parameters:**

- `value1: decimal` \- The first decimal to compare.
- `value2: decimal` \- The second decimal to compare.

**Returns:**

- The smaller of the two input decimals.

## Collection checks [â€‹](\#collection-checks "Direct link to Collection checks")

### `empty(value: T?): boolean` [â€‹](\#emptyvalue-t-boolean "Direct link to emptyvalue-t-boolean")

Determines if a value is null or an empty collection.

**Parameters:**

- `value: T?` \- The value to check for emptiness, which can be any nullable type.

**Returns:**

- `True` if the value is null or an empty collection, `False` otherwise.

### `empty(list: list<T>): boolean` [â€‹](\#emptylist-listt-boolean "Direct link to emptylist-listt-boolean")

Specifically checks if a list is empty.

**Parameters:**

- `list: list<T>` \- The list to check for emptiness.

**Returns:**

- `True` if the list contains no elements, `False` otherwise.

### `empty(set: set<T>): boolean` [â€‹](\#emptyset-sett-boolean "Direct link to emptyset-sett-boolean")

Verifies if a set is empty.

**Parameters:**

- `set: set<T>` \- The set to check for emptiness.

**Returns:**

- `True` if the set contains no elements, `False` otherwise.

### `empty(map: map<K, V>): boolean` [â€‹](\#emptymap-mapk-v-boolean "Direct link to emptymap-mapk-v-boolean")

Checks if a map is empty.

**Parameters:**

- `map: map<K, V>` \- The map to check for emptiness.

**Returns:**

- `True` if the map contains no key-value pairs, `False` otherwise.

### Nested `at-expressions` with `empty()` [â€‹](\#nested-at-expressions-with-empty "Direct link to nested-at-expressions-with-empty")

The `empty()` function supports nested `at-expressions`, allowing them to access entities from an outer `at-expression`.
This enhancement enables more complex and efficient database queries.

**Example:**

```codeBlockLines_e6Vv
user @* {
    empty(company @* { .city == user.city })
}

```

**Translated SQL query:**

```codeBlockLines_e6Vv
SELECT U."name"
FROM "c0.user" U
WHERE NOT EXISTS(
    SELECT C."rowid"
    FROM "c0.company" C
    WHERE C."city" = U."city"
)

```

**Usage in `update` and `delete` statements:**

```codeBlockLines_e6Vv
delete user @* { empty( company @* { .city == user.city } ) } ;

```

**Notes on cardinality:**

- Use `@*` in nested `at-expressions` to ensure the entire query is executed as a single SQL query.
- Using operators `@+`, `@?`, or `@` will result in independent SQL queries, potentially reducing performance due to
loading the entire result set into memory.

**Simplified attribute matching:**

- In the `where` part of a nested `at-expression`, you can use `outer_entity.attribute` directly.

**Example:**

```codeBlockLines_e6Vv
user @* {
    empty(company @* { user.city })
}

```

### `exists(value: T?): boolean` [â€‹](\#existsvalue-t-boolean "Direct link to existsvalue-t-boolean")

Confirms the presence of a value.

**Parameters:**

- `value: T?` \- The value to check for existence, which can be any nullable type.

**Returns:**

- `True` if the value is not null and contains elements (for collections), `False` otherwise.

### `exists(list: list<T>): boolean` [â€‹](\#existslist-listt-boolean "Direct link to existslist-listt-boolean")

Specifically verifies if a list contains elements.

**Parameters:**

- `list: list<T>` \- The list to check for the existence of elements.

**Returns:**

- `True` if the list has at least one element, `False` if it's empty.

### `exists(set: set<T>): boolean` [â€‹](\#existsset-sett-boolean "Direct link to existsset-sett-boolean")

Determines if a set contains elements.

**Parameters:**

- `set: set<T>` \- The set to check for the existence of elements.

**Returns:**

- `True` if the set has at least one element, `False` if it's empty.

### `exists(map: map<K, V>): boolean` [â€‹](\#existsmap-mapk-v-boolean "Direct link to existsmap-mapk-v-boolean")

Checks if a map contains key-value pairs.

**Parameters:**

- `map: map<K, V>` \- The map to check for the existence of key-value pairs.

**Returns:**

- `True` if the map has at least one key-value pair, `False` if it's empty.

### Nested `at-expressions` with `exists()` [â€‹](\#nested-at-expressions-with-exists "Direct link to nested-at-expressions-with-exists")

The `exists()` function supports nested `at-expressions`, allowing them to access entities from an outer
`at-expression`. This enhancement enables more complex and efficient database queries.

**Example:**

```codeBlockLines_e6Vv
user @* {
    exists(company @* { .city == user.city })
}

```

**Translated SQL query:**

```codeBlockLines_e6Vv
SELECT U."name"
FROM "c0.user" U
WHERE EXISTS(
    SELECT C."rowid"
    FROM "c0.company" C
    WHERE C."city" = U."city"
)

```

**Usage in `update` and `delete` statements:**

```codeBlockLines_e6Vv
delete user @* { not exists( company @* { .city == user.city } ) } ;

```

**Notes on cardinality:**

- Use `@*` in nested `at-expressions` to ensure the entire query is executed as a single SQL query.
- Using operators `@+`, `@?`, or `@` will result in independent SQL queries, potentially reducing performance due to
loading the entire result set into memory.

**Simplified attribute matching:**

- In the `where` part of a nested `at-expression`, you can use `outer_entity.attribute` directly.

**Example:**

```codeBlockLines_e6Vv
user @* {
    empty(company @* { .city == user.city })
}

```

## Output and logging [â€‹](\#output-and-logging "Direct link to Output and logging")

### `function print(...)` [â€‹](\#function-print "Direct link to function-print")

Prints a message to `STDOUT`.

**Example:**

- `print()` \- prints an empty line.
- `print('Hello', 123)` \- prints "Hello 123".

**Parameters:**

- `...`: Accepts any number of arguments to be printed, including strings, numbers, variables, and expressions.

**Returns:**

- `None` (no explicit return value).

### `function log(...)` [â€‹](\#function-log "Direct link to function-log")

Generates a detailed record of program execution for debugging and analysis purposes.

**Parameters:**

- `...`: Accepts any number of arguments to be logged, similar to `print`.

**Returns:**

- `None` (no explicit return value).

## Cryptographic hashes [â€‹](\#cryptographic-hashes "Direct link to Cryptographic hashes")

### `function keccak256(byte_array: byte_array): byte_array` [â€‹](\#function-keccak256byte_array-byte_array-byte_array "Direct link to function-keccak256byte_array-byte_array-byte_array")

Produces a 32-byte Keccak256 hash from a given byte array.

**Parameters:**

- `byte_array: byte_array` \- The byte array to be hashed.

**Returns:**

- A 32-byte byte array representing the Keccak256 hash of the input `byte_array`.

### `function sha256(byte_array: byte_array): byte_array` [â€‹](\#function-sha256byte_array-byte_array-byte_array "Direct link to function-sha256byte_array-byte_array-byte_array")

Generates a 32-byte SHA-256 hash from a provided byte array.

**Parameters:**

- `byte_array: byte_array` \- The byte array to be hashed.

**Returns:**

- A 32-byte byte array representing the SHA-256 hash of the input `byte_array`.

## Signature verification [â€‹](\#signature-verification "Direct link to Signature verification")

### `function verify_signature(message: byte_array, pubkey: pubkey, signature: byte_array): boolean` [â€‹](\#function-verify_signaturemessage-byte_array-pubkey-pubkey-signature-byte_array-boolean "Direct link to function-verify_signaturemessage-byte_array-pubkey-pubkey-signature-byte_array-boolean")

Verifies the authenticity of a given signature, ensuring data integrity and non-repudiation.

**Parameters:**

- `message: byte_array` \- The original message that was signed.
- `pubkey: pubkey` \- The public key allegedly used for signing.
- `signature: byte_array` \- The signature to be verified.

**Returns:**

- `True` if the signature is valid for the given message and public key, `False` otherwise.

## Ethereum public key recovery [â€‹](\#ethereum-public-key-recovery "Direct link to Ethereum public key recovery")

### `function eth_ecrecover(r: byte_array, s: byte_array, rec_id: integer, hash: byte_array): byte_array` [â€‹](\#function-eth_ecrecoverr-byte_array-s-byte_array-rec_id-integer-hash-byte_array-byte_array "Direct link to function-eth_ecrecoverr-byte_array-s-byte_array-rec_id-integer-hash-byte_array-byte_array")

Derives the Ethereum public key from a signature and hash, enabling identity recovery in blockchain transactions.

**Parameters:**

- `r: byte_array` \- The R component of the elliptic curve signature.
- `s: byte_array` \- The S component of the elliptic curve signature.
- `rec_id: integer` \- The recovery ID, indicating which signature variant was used.
- `hash: byte_array` \- The hash of the message that was signed.

**Returns:**

- The 64-byte Ethereum public key recovered from the provided signature and hash components.

## Error handling with `try_call` [â€‹](\#error-handling-with-try_call "Direct link to error-handling-with-try_call")

### `function try_call()` [â€‹](\#function-try_call "Direct link to function-try_call")

Catches exceptions within a function call, providing graceful error handling and fallback mechanisms.

**Variants:**

1. **`try_call(f: ()->T): T?`**
   - Calls the function `f`.
   - Returns the result of `f` on success or `null` if an exception occurs.
2. **`try_call(f: ()->unit): boolean`**
   - Calls the function `f` that doesn't return a value.
   - Returns `true` on success or `false` if an exception occurs.
3. **`try_call(f: ()->T, fallback: T): T`**
   - Calls the function `f`.
   - Returns the result of `f` on success or the specified `fallback` value if an exception occurs.

note

The `try_call` method restores the state of a program in the event of a failure.
This means that even if the program writes data to the database, all changes will be reverted in case of an error.

**Examples:**

- `val int_or_null = try_call(integer.from_hex(s, *));` \- converts the hexadecimal string `s` to an integer and assigns
it to `int_or_null`, or assigns `None` if the conversion fails.
- `val int_or_default = try_call(integer.from_hex(s, *), -1);` \- converts the hexadecimal string `s` to an integer and
assigns it to `int_or_default`, or assigns `-1` if the conversion fails.
- `val l = try_call(list<integer>.from_gtv(my_gtv, *));` \- converts the GTV `my_gtv` to a list of integers and assigns
it to `l` or assigns `None` if the conversion fails.

## Text pattern matching with `text.like` [â€‹](\#text-pattern-matching-with-textlike "Direct link to text-pattern-matching-with-textlike")

### `text.like(pattern: text): boolean` [â€‹](\#textlikepattern-text-boolean "Direct link to textlikepattern-text-boolean")

The `text.like()` function provides a simple way to perform pattern matching, similar to the SQL `LIKE` clause. It
operates consistently in both interpreted expressions and at-expressions.

**Parameters:**

- `pattern: text` \- The pattern to match against the text, incorporating wildcards for flexibility.

**Returns:**

- `True` if the text matches the pattern, `False` otherwise.

**Special Characters:**

- `_`: Matches any single character, similar to the SQL LIKE clause.
- `%`: Matches any string of zero or more characters, enabling broader matching capabilities.

**Examples:**

- **Basic pattern matching**: `print(name.like(% von %))` \- returns all names that have a von inside.

- **Pattern matching in collections**: `user @* { .name.like('% von %') }` \- returns all users whose names contain the
substring " von ".

- **Escaping special characters**: To match the special characters `_` or `%`, you need to escape them with a backslash
( `\`). Note that in string literals, you must use a double backslash ( `\\`) to produce a single backslash at runtime.

`title.like('string\\_with\\_underscores')` \- this matches the string `string_with_underscores` where `_` is treated
as a literal underscore rather than a wildcard.


- [Essential calculations](#essential-calculations)
  - [`abs(value: integer): integer`](#absvalue-integer-integer)
  - [`abs(value: big_integer): big_integer`](#absvalue-big_integer-big_integer)
  - [`abs(value: decimal): decimal`](#absvalue-decimal-decimal)
  - [`function max(value1: integer, value2: integer): integer`](#function-maxvalue1-integer-value2-integer-integer)
  - [`function max(value1: big_integer, value2: big_integer): big_integer`](#function-maxvalue1-big_integer-value2-big_integer-big_integer)
  - [`function max(value1: decimal, value2: decimal): decimal`](#function-maxvalue1-decimal-value2-decimal-decimal)
  - [`function min(value1: integer, value2: integer): integer`](#function-minvalue1-integer-value2-integer-integer)
  - [`function min(value1: big_integer, value2: big_integer): big_integer`](#function-minvalue1-big_integer-value2-big_integer-big_integer)
  - [`function min(value1: decimal, value2: decimal): decimal`](#function-minvalue1-decimal-value2-decimal-decimal)
- [Collection checks](#collection-checks)
  - [`empty(value: T?): boolean`](#emptyvalue-t-boolean)
  - [`empty(list: list<T>): boolean`](#emptylist-listt-boolean)
  - [`empty(set: set<T>): boolean`](#emptyset-sett-boolean)
  - [`empty(map: map<K, V>): boolean`](#emptymap-mapk-v-boolean)
  - [Nested `at-expressions` with `empty()`](#nested-at-expressions-with-empty)
  - [`exists(value: T?): boolean`](#existsvalue-t-boolean)
  - [`exists(list: list<T>): boolean`](#existslist-listt-boolean)
  - [`exists(set: set<T>): boolean`](#existsset-sett-boolean)
  - [`exists(map: map<K, V>): boolean`](#existsmap-mapk-v-boolean)
  - [Nested `at-expressions` with `exists()`](#nested-at-expressions-with-exists)
- [Output and logging](#output-and-logging)
  - [`function print(...)`](#function-print)
  - [`function log(...)`](#function-log)
- [Cryptographic hashes](#cryptographic-hashes)
  - [`function keccak256(byte_array: byte_array): byte_array`](#function-keccak256byte_array-byte_array-byte_array)
  - [`function sha256(byte_array: byte_array): byte_array`](#function-sha256byte_array-byte_array-byte_array)
- [Signature verification](#signature-verification)
  - [`function verify_signature(message: byte_array, pubkey: pubkey, signature: byte_array): boolean`](#function-verify_signaturemessage-byte_array-pubkey-pubkey-signature-byte_array-boolean)
- [Ethereum public key recovery](#ethereum-public-key-recovery)
  - [`function eth_ecrecover(r: byte_array, s: byte_array, rec_id: integer, hash: byte_array): byte_array`](#function-eth_ecrecoverr-byte_array-s-byte_array-rec_id-integer-hash-byte_array-byte_array)
- [Error handling with `try_call`](#error-handling-with-try_call)
  - [`function try_call()`](#function-try_call)
- [Text pattern matching with `text.like`](#text-pattern-matching-with-textlike)
  - [`text.like(pattern: text): boolean`](#textlikepattern-text-boolean)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Virtual types use Merkle trees to efficiently verify data integrity and selectively retrieve specific elements.

Type `virtual<T>` supports the following types of `T`:

- `list<*>`
- `set<*>`
- `map<text, *>`

### `T` elements constraints [â€‹](\#t-elements-constraints "Direct link to t-elements-constraints")

Additionally, types of all internal elements of `T` must satisfy the following constraints:

- must be Gtv-compatible
- for a `map` type, the key type must be `text` (i. e. `map<text, *>`)

### Virtual types operations [â€‹](\#virtual-types-operations "Direct link to Virtual types operations")

- **Member access**: Access elements using `[]` for lists and maps, `.name` for structs and tuples.
- **`.to_full(): T`**: Converts a virtual value to its full, original form if all elements are present; otherwise throws
an exception.

### Features of `virtual<T>` [â€‹](\#features-of-virtualt "Direct link to features-of-virtualt")

- Virtual values cannot be modified after creation.
- Member access returns virtual values of the corresponding type, maintaining partial representation. Reading a member
of type `list<*>`, `map<*,*>`, `struct` or tuple returns a value of the corresponding virtual type, not of the actual
member type.
- Cannot get converted to Gtv, so can't use it as a return type of a `query`.

##### Example [â€‹](\#example "Direct link to Example")

```codeBlockLines_e6Vv
struct Record {
    t: text;
    s: integer;
}

operation processRecords(virtualRecords: virtual<list<Record>>) {
    for (virtualRecord in virtualRecords) {       // "virtualRecord" is of type "virtual<Record>"
        val fullRecord = virtualRecord.to_full(); // "fullRecord" is of type "Record", fails if the value is not full
        print(fullRecord.t);                      // Print the 't' field of the fully retrieved Record
    }
}

```

## `Virtual<list<T>>` functions [â€‹](\#virtuallistt-functions "Direct link to virtuallistt-functions")

- **`.empty(): boolean`**: Checks if the virtual value is empty.

- **`.get(integer): virtual<T>`**: Retrieves an element by index (same as `[]`).

- **`.join_to_text(): text`**: Creates a text from all elements using the specified separator, prefix, and postfix.

- **`.size(): integer`**: Returns the number of elements.

- **`.to_full(): list<T>`**: Converts to the original list, fails if the value isn't full.

- **`.to_text(): text`**: Returns a text representation.


#### Special operators [â€‹](\#special-operators "Direct link to Special operators")

- `[]`: Element read, returns `virtual<T>` (or just `T` for simple types).
- `in`: Returns `true` if the given integer index is present in the virtual list.

##### Example [â€‹](\#example-1 "Direct link to Example")

```codeBlockLines_e6Vv
operation listExample(virtualList: virtual<list<integer>>) {
    print(virtualList.empty());          // Check if the list is empty
    print(virtualList.size());           // Print the size of the list
    print(virtualList[0]);     // Access and print the first element

    for (i in virtualList) {
        print(virtualList[i]); // Iterate and print all elements
    }
}

```

## `Virtual<set<T>>` functions [â€‹](\#virtualsett-functions "Direct link to virtualsett-functions")

- **`.empty(): boolean`**: Checks if the virtual set is empty.
- **`.join_to_text(): text`**: Creates a text from all elements using the specified separator, prefix, and postfix.
- **`.size(): integer`**: Returns the number of elements.
- **`.to_full(): set<T>`**: Converts to the original set, fails if the value isn't full.
- **`.to_text(): text`**: Returns a text representation.

#### Special operators [â€‹](\#special-operators-1 "Direct link to Special operators")

- `in`: Returns `true` if the given value is present in the virtual set; the type of the operand is `virtual<T>` (or
just `T` for simple types).

##### Example [â€‹](\#example-2 "Direct link to Example")

```codeBlockLines_e6Vv
operation setExample(virtualSet: virtual<set<text>>) {
    print(virtualSet.empty());           // Check if the set is empty
    print(virtualSet.size());            // Print the size of the set

    if ("example" in virtualSet) {       // Check if an element is in the set
        print("Element 'example' is in the set");
    }

    for (element in virtualSet.to_full()) {
        print(element);                  // Iterate and print all elements
    }
}

```

## `Virtual<map<text, T>>` functions [â€‹](\#virtualmaptext-t-functions "Direct link to virtualmaptext-t-functions")

- **`.contains(K): boolean`**: Checks if a key is in the map (same as the operator `in`).
- **`.empty(): boolean`**: Checks if the virtual mal is empty.
- **`.get(K): virtual<V>`**: Gets the value associated with a key in the map. Fails if the key is not found.
- **`.get_or_default (key: K, default: R): R`**: Gets the value associated with a key in the map, or a default value if
the key is not found.
- **`.get_or_null(key: K): V?`**: Gets the value associated with a key in the map, returning `null` if the key is not
found.
- **`.join_to_text(): text`**: Creates a text from all elements using the specified separator, prefix, and postfix.
- **`.keys(): set<K>`**: Returns a copy of keys.
- **`.size(): integer`**: Returns the number of elements.
- **`.to_full(): map<K, V>`**: Converts to the original map, fails if the value isn't full.
- **`.to_text(): text`**: Converts the map to text.
- **`.values(): list<virtual<V>>`**: Returns a copy of values (if `V` is a simple type, returns `list<V>`).

#### Special operators [â€‹](\#special-operators-2 "Direct link to Special operators")

- `[]`: Get value by key, fails if not found, returns `virtual<V>` (or just `V` for simple types).
- `in`: Returns `true` if a key is in the map.

##### Example [â€‹](\#example-3 "Direct link to Example")

```codeBlockLines_e6Vv
operation mapExample(virtualMap: virtual<map<text, integer>>) {
    print(virtualMap.empty());           // Check if the map is empty
    print(virtualMap.size());            // Print the size of the map

    if ("key" in virtualMap) {           // Check if a key is in the map
        print(virtualMap["key"]); // Access and print the value associated with the key
    }

    for (k in virtualMap.keys()) {
        print(k);                      // Iterate and print all keys
    }

    for (value in virtualMap.values()) {
        print(value);          // Iterate and print all values
    }
}

```

- [`T` elements constraints](#t-elements-constraints)
- [Virtual types operations](#virtual-types-operations)
- [Features of `virtual<T>`](#features-of-virtualt)
- [`Virtual<list<T>>` functions](#virtuallistt-functions)
- [`Virtual<set<T>>` functions](#virtualsett-functions)
- [`Virtual<map<text, T>>` functions](#virtualmaptext-t-functions)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Accounts can have multiple account descriptors connected to them. Each can be made to serve a different purpose, but the
most important one is the main auth descriptor.

The auth descriptor itself is a simple struct:

```codeBlockLines_e6Vv
struct auth_descriptor {
    auth_type;
    args: list<gtv>;
    rules: gtv;
}

```

The struct is then connected to the account using the **account\_auth\_descriptor** entity.

```codeBlockLines_e6Vv
entity account_auth_descriptor {
    /** a unique identifier for the auth descriptor */
    id: byte_array;
    /** the account it allows access to */
    key account, id;
    index id;
    /** whether it's single-sig or multi-sig. It will influence the `args` property. */
    auth_type;
    /**
     * It specifies signers and level of access for the auth descriptor.
     * It should be either of the following structs, encoded into a byte array:
     * - `single_sig_args`, if `auth_type` is `S`
     * - `multi_sig_args`, if `auth_type` is `M`
     */
    args: byte_array;
    /**
     * Must be one of these values, converted to gtv and then encoded into a byte array:
     * - **no rules**: `null` (when encoded, it will be converted to `GTV_NULL_BYTES`)
     * - **a simple rule**: a `rule_expression`
     * - **a complex rule**: a list starting with the value `"and"` and followed by
     *   `rule_expression`s
     *
     * The amount of rule expressions should always be less than or equal to
     * `auth_descriptor_config.max_rules`.
     *
     * After the expiration conditions are reached, this auth descriptor
     * will automatically be deleted as soon as the account that owns it sends an
     * operation.
     *
     * Must be `GTV_NULL_BYTES` if this is the `main_auth_descriptor` for the account.
     *
     * @see `rule_expression` explains what it means to expire
     */
    rules: byte_array;
    /**
     * Used for the `op_count` expiration rule, counts how many operations this auth
     * descriptor has authenticated.
     */
    mutable ctr: integer;
    /** When was this auth descriptor registered */
    created: timestamp;
}

```

See the auth descriptor section for more information on auth descriptors.

## Main auth descriptor [â€‹](\#main-auth-descriptor "Direct link to Main auth descriptor")

Each account has a main account auth descriptor which is set during account creation. The main account descriptor can
only be substituted, it can't be deleted.

```codeBlockLines_e6Vv
entity main_auth_descriptor {
    /** the account of which this auth descriptor is the manager of */
    key account;
    /** the auth descriptor that manages the account */
    key auth_descriptor: account_auth_descriptor;
}

```

The main auth descriptor can be updated to another one using the **update\_main\_auth\_descriptor** function, which can
only be called from an operation.

```codeBlockLines_e6Vv
function update_main_auth_descriptor(account, auth_descriptor)

```

The main auth descriptor cannot be bound by any rules, meaning it's always valid until replaced. As other descriptors it
needs to have manadatory flags set before the update. The previous main auth descriptor is always deleted during the
update, and the new one is set as the main auth descriptor if none of the checks above fail.

## Adding other auth descriptors [â€‹](\#adding-other-auth-descriptors "Direct link to Adding other auth descriptors")

As the **update\_main\_auth\_descriptor** function, the **add\_auth\_descriptor** function can only be called from an
operation.

```codeBlockLines_e6Vv
function add_auth_descriptor(account, auth_descriptor): account_auth_descriptor

```

There is also an operation ready to be used with the same name. The only argument it has is the account auth descriptor
which is then used in the function call above:

```codeBlockLines_e6Vv
operation add_auth_descriptor(new_desc: accounts.auth_descriptor)

```

The checks which are performed are:

1. check if the number of maximum configured auth descriptors has been exceeded
2. check if the auth descriptor args correspond to `single_sig_args` or `multi_sig_args`, which is a set of required
flags and number of signers in case of multi\_sig\_args
3. check auth descriptor rules (to see if the auth descriptor is initially valid)

If the checks pass, the account\_auth\_descriptor will be created, and the signer(s) will be associated with the account
by calling `add_signers` which will create an `auth_descriptor_signer` entity.

```codeBlockLines_e6Vv
entity auth_descriptor_signer {
    /** Either the pubkey or, for EVM signers, the EVM address (without `0x`) */
    id: byte_array;
    /** the auth descriptor this signer can access */
    key account_auth_descriptor, id;
}

```

note

If the signer is using an EVM wallet like MetaMask, only store the EVM address without the leading 0x here.

#### Creating an account with an auth descriptor [â€‹](\#creating-an-account-with-an-auth-descriptor "Direct link to Creating an account with an auth descriptor")

The most typical way of creating a new account is by calling `create_account_with_auth` which takes a before-created
auth descriptor and optionally an id for the account.

```codeBlockLines_e6Vv
function create_account_with_auth(auth_descriptor, account_id: byte_array? = null): account

```

As is the case with updating the `main_auth_descriptor`, during account creation, the auth descriptor needs to be
without any rules and have mandatory flags. If those 2 checks are passed, the account is created.

note

If native Postchain pubkeys are used, the account\_id will be `hash(pubkey)`. In case EVM pubkeys are used, the
account\_id will be `hash(evm_address)`.

After the id is derived and the account created, the auth descriptor is added as the main auth descriptor. Finally, the
rate limiter state ( `rl_state`) is created for the account, which is set from default values configured on the chain.

- [Main auth descriptor](#main-auth-descriptor)
- [Adding other auth descriptors](#adding-other-auth-descriptors)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Gets meta-information (like the mount name of an operation).

| Member | Description |
| --- | --- |
| `constructor(definition)` | Constructor method. Returns a value of type `rell.meta` describing the specified definition. The definition can be an `entity`, `object`, `operation`, `query`. |
| `simple_name: text` | Represents the simple name of the definition. For example, `bar` if the full name is `lib:foo.bar`. |
| `full_name: text` | Represents the full name, including the module name, in the format `<module_name>:[<namespace_path>.]<simple_name>`. For instance, `:foo` for the root module, `my_module:bar`, or `my_module:my_namespace.bar`. |
| `module_name: text` | Represents the module name. It can be an empty string for the root module. |
| `mount_name: text` | Represents the mount name. If the definition has a mount name, it provides the mount name; otherwise, it generates a runtime error. All supported definitions have mount names. |

#### Example - getting the mount name of an operation [â€‹](\#example---getting-the-mount-name-of-an-operation "Direct link to Example - getting the mount name of an operation")

```codeBlockLines_e6Vv
operation my_op() {}
query get_op_name() = rell.meta(my_op).mount_name;

```

This example retrieves the mount name of the `my_op` operation.[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

You can only use system namespace `op_context` in an operation or a function called from an operation, but not in a query.

- [Functions](#functions)
  - [`op_context.block_height -> integer`](#op_contextblock_height---integer)
  - [`op_context.last_block_time -> integer`](#op_contextlast_block_time---integer)
  - [`op_context.op_index -> integer`](#op_contextop_index---integer)
  - [`op_context.exists -> boolean`](#op_contextexists---boolean)
  - [`op_context.get_signers() -> list<byte_array>`](#op_contextget_signers---listbyte_array)
  - [`op_context.is_signer(public_key: byte_array) -> boolean`](#op_contextis_signerpublic_key-byte_array---boolean)
  - [`op_context.get_all_operations() -> list<gtx_operation>`](#op_contextget_all_operations---listgtx_operation)
  - [`op_context.get_current_operation() -> gtx_operation`](#op_contextget_current_operation---gtx_operation)
  - [`op_context.emit_event`](#op_contextemit_event)
  - [`op_context.transaction -> transaction`](#op_contexttransaction---transaction)

## Functions [â€‹](\#functions "Direct link to Functions")

### `op_context.block_height -> integer` [â€‹](\#op_contextblock_height---integer "Direct link to op_contextblock_height---integer")

Provides the height of the block currently being built.

**Parameters:**

- None

**Returns:**

- `integer`: The height of the block being built.

### `op_context.last_block_time -> integer` [â€‹](\#op_contextlast_block_time---integer "Direct link to op_contextlast_block_time---integer")

Returns the timestamp of the last block in milliseconds.

**Parameters:**

- None

**Returns:**

- `integer`: The timestamp of the last block, or -1 if there is no last block.

### `op_context.op_index -> integer` [â€‹](\#op_contextop_index---integer "Direct link to op_contextop_index---integer")

Indicates the index of the operation being executed within the transaction.

**Parameters:**

- None

**Returns:**

- `integer`: The index of the operation being executed.

### `op_context.exists -> boolean` [â€‹](\#op_contextexists---boolean "Direct link to op_contextexists---boolean")

Indicates whether the code is being called from an operation.

**Parameters:**

- None

**Returns:**

- `boolean`: `true` if the code is being called from an operation, `false` otherwise.

### `op_context.get_signers() -> list<byte_array>` [â€‹](\#op_contextget_signers---listbyte_array "Direct link to op_contextget_signers---listbyte_array")

Returns a list of pubkeys representing the signers of the current transaction.

**Parameters:**

- None

**Returns:**

- `list<byte_array>`: A list of pubkeys of the signers.

### `op_context.is_signer(public_key: byte_array) -> boolean` [â€‹](\#op_contextis_signerpublic_key-byte_array---boolean "Direct link to op_contextis_signerpublic_key-byte_array---boolean")

Checks if the provided public key is one of the signers of the current transaction.

**Parameters:**

- `public_key`: The public key to check.

**Returns:**

- `boolean`: `true` if the public key is a signer, `false` otherwise.

### `op_context.get_all_operations() -> list<gtx_operation>` [â€‹](\#op_contextget_all_operations---listgtx_operation "Direct link to op_contextget_all_operations---listgtx_operation")

Returns a list of all operations within the current transaction.

**Parameters:**

- None

**Returns:**

- `list<gtx_operation>`: A list of all operations in the transaction.

### `op_context.get_current_operation() -> gtx_operation` [â€‹](\#op_contextget_current_operation---gtx_operation "Direct link to op_contextget_current_operation---gtx_operation")

Retrieves the current operation efficiently.

**Parameters:**

- None

**Returns:**

- `gtx_operation`: The current operation object.

### `op_context.emit_event` [â€‹](\#op_contextemit_event "Direct link to op_contextemit_event")

Facilitates communication from Rell code to Postchain components.

**Parameters:**

- `type`: Represents the type of event processor to invoke.
- `data`: Contains the value to pass to the event processor.

**Returns:**

- None

### `op_context.transaction -> transaction` [â€‹](\#op_contexttransaction---transaction "Direct link to op_contexttransaction---transaction")

Represents the transaction currently being built.

**Parameters:**

- None

**Returns:**

- `transaction`: The transaction object.

warning

You must not use `op_context.transaction.block` because, except `block_height`, its attributes are null, so reading them gives a run-time error.

- [Functions](#functions)
  - [`op_context.block_height -> integer`](#op_contextblock_height---integer)
  - [`op_context.last_block_time -> integer`](#op_contextlast_block_time---integer)
  - [`op_context.op_index -> integer`](#op_contextop_index---integer)
  - [`op_context.exists -> boolean`](#op_contextexists---boolean)
  - [`op_context.get_signers() -> list<byte_array>`](#op_contextget_signers---listbyte_array)
  - [`op_context.is_signer(public_key: byte_array) -> boolean`](#op_contextis_signerpublic_key-byte_array---boolean)
  - [`op_context.get_all_operations() -> list<gtx_operation>`](#op_contextget_all_operations---listgtx_operation)
  - [`op_context.get_current_operation() -> gtx_operation`](#op_contextget_current_operation---gtx_operation)
  - [`op_context.emit_event`](#op_contextemit_event)
  - [`op_context.transaction -> transaction`](#op_contexttransaction---transaction)[Skip to main content](#__docusaurus_skipToContent_fallback)

In Rell, `when` statement is similar to `switch` in C++ or Java, but uses the syntax of `when` in Kotlin. The `when`
expression is a versatile construct used for multi-way branching based on the value of an expression. It allows you to
define different cases and actions to be taken depending on the value of the given expression. Here's an example:

```codeBlockLines_e6Vv
when(x) {
    1 -> return 'One';
    2, 3 -> return 'Few';
    else -> {
        val res = 'Many: ' + x;
        return res;
    }
}

```

In this example:

1. `x` is the expression that is being evaluated in the `when` statement. The value of `x` will determine which branch
of the `when` expression will be executed.
2. `1 -> return 'One';`: This line specifies the first case. If `x` is equal to `1`, the expression `'One'` will be
returned.
3. `2, 3 -> return 'Few';`: This line specifies the second case. If `x` is either `2` or `3`, the expression `'Few'`
will be returned.
4. `else -> { ... }`: This is the default branch, executed when none of the previous cases match. It allows for more
complex code to be executed. In this case:
   - A local variable `res` is declared to store the result.
   - The value of `x` is concatenated to the string `'Many: '` using the `+` operator.
   - The entire constructed string is stored in `res`.
   - Finally, `res` is returned.

**Features**

- It can use both constants as well as arbitrary expressions.
- When using constant values, the compiler checks that all values are unique.
- When used with an enum type, values use simple names, not full names.

A form of `when` without an argument is equivalent to a chain of `if` ... `else` `if`:

```codeBlockLines_e6Vv
when {
    x == 1 -> return 'One';
    x >= 2 and x <= 7 -> return 'Several';
    x == 11, x == 111 -> return 'Magic number';
    some_value > 1000 -> return 'Special case';
    else -> return 'Unknown';
}

```

- Can use arbitrary boolean expressions.
- When you specify multiple comma-separated expressions, any triggers the block (combined via OR).

You can use both forms of `when` (with and without an argument) as an expression:

```codeBlockLines_e6Vv
return when(x) {
    1 -> 'One';
    2, 3 -> 'Few';
    else -> 'Many';
}

```

- If you are using `when` as an expression, it must be exhaustive, the `else` statement can make it exhaustive.
- You can use it in at-expression, in which case it's translated to SQL `CASE WHEN` ... `THEN` expression.[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

A struct is similar to an entity, but its instances exist in memory, not in a database.

Structs have the following characteristics:

- Attributes are immutable by default and only mutable when declared with a `mutable` keyword
- An attribute might have a default value that's used if the attribute isn't specified during construction
- Structs get deleted from memory implicitly by a garbage collector

##### Example [â€‹](\#example "Direct link to Example")

```codeBlockLines_e6Vv
struct user {
    name: text;
    address: text;
    mutable balance: integer = 0;
}

```

### Create structs [â€‹](\#create-structs "Direct link to Create structs")

Employ the struct name as a function to create instances, specifying attribute values as arguments.

##### Example [â€‹](\#example-1 "Direct link to Example")

```codeBlockLines_e6Vv
val u = user(name = 'Bob', address = 'New York');

```

### Struct-copy of entities and objects [â€‹](\#struct-copy-of-entities-and-objects "Direct link to Struct-copy of entities and objects")

You can use `.to_struct()` to create a struct-copy of an entity or an object.

##### Example [â€‹](\#example-2 "Direct link to Example")

```codeBlockLines_e6Vv
entity user{
  name;
  address: text;
}

val u = user @ {.name == 'Bob'};
val s = u.to_struct();  // returns struct <user>

```

### Create entities from structs [â€‹](\#create-entities-from-structs "Direct link to Create entities from structs")

Conveniently create entities directly from `struct<entity>` values.

##### Example [â€‹](\#example-3 "Direct link to Example")

```codeBlockLines_e6Vv
create user(s); // s is struct<user>

```

Same rules as for the `create` expression apply: no need to specify attribute name if you can resolve it implicitly by
name or type:

```codeBlockLines_e6Vv
val name = 'Bob';
val address = 'New York';
val u = user(name, address);
val u2 = user(address, name); // Order does not matter - same struct value is created.

```

### Access struct attributes [â€‹](\#access-struct-attributes "Direct link to Access struct attributes")

You can use `.` dot notation to access struct attributes.

##### Example [â€‹](\#example-4 "Direct link to Example")

```codeBlockLines_e6Vv
print(u.name, u.address);

```

### Safe access for nullable structs [â€‹](\#safe-access-for-nullable-structs "Direct link to Safe access for nullable structs")

You can use the safe-access operator `?.` to read or modify attributes of a nullable struct.

##### Example [â€‹](\#example-5 "Direct link to Example")

```codeBlockLines_e6Vv
val u: user? = find_user('Bob');
u?.balance += 100;        // no-op if 'u' is null

```

### `Struct<mutable T>` [â€‹](\#structmutable-t "Direct link to structmutable-t")

`Struct<mutable T>` designates a struct where all attributes are mutable, enabling modifications after creation.

tip

When working with functions that require a substantial number of arguments, it's recommended to use structs to enhance
code organization and readability. This approach promotes better code maintainability and reduces the likelihood of
errors arising from argument order confusion.

Consider the following example function that creates a project:

```codeBlockLines_e6Vv
function create_project(
  name: text,
  description: text,
  rules: text,
  public_name: text
) {
  ...
}

```

While this function is straightforward, the potential for argument order mix-ups exists. To address this concern, we can
introduce a dedicated struct to encapsulate the function's arguments:

```codeBlockLines_e6Vv
struct create_project_arguments {
  name: text,
  description: text,
  rules: text,
  public_name: text
};

```

By defining this struct, we can now utilize it to create a type-safe and self-documenting function parameter:

```codeBlockLines_e6Vv
function create_project(project_arguments: create_project_arguments) {
  // ... Project creation logic
}

```

To invoke this function, we can instantiate the `create_project_arguments` struct and assign values to its properties:

```codeBlockLines_e6Vv
val arguments = create_project_arguments(
  name: "test_project",
  description: "my project description",
  rules: "",
  public_name: "my fancy test project"
);

create_project(arguments);

```

### `Struct<mutable T>` [â€‹](\#structmutable-t-1 "Direct link to structmutable-t-1")

`struct<mutable T>` represents a struct where all attributes are mutable, allowing for modification after creation.

#### Convert entities and objects to mutable structs [â€‹](\#convert-entities-and-objects-to-mutable-structs "Direct link to Convert entities and objects to mutable structs")

Use `.to_mutable_struct()` to create a mutable struct representation:

```codeBlockLines_e6Vv
val u = user @ { .name == 'Bob' };
val s = u.to_mutable_struct();   // will return a struct<mutable user>

```

#### Convert mutable and immutable structs [â€‹](\#convert-mutable-and-immutable-structs "Direct link to Convert mutable and immutable structs")

- Employ `.to_mutable()` to convert a `struct<T>` to a `struct<mutable T>`.
- Use `.to_immutable()` to convert a `struct<mutable T>` to a `struct<T>`.

```codeBlockLines_e6Vv
val s = u.to_struct();
val mut = s.to_mutable();
val imm = mut.to_immutable();

```

### `struct<operation>` [â€‹](\#structoperation "Direct link to structoperation")

The type `struct<operation>` defines a struct that has the same attributes as a given operations parameters:

##### Example [â€‹](\#example-6 "Direct link to Example")

```codeBlockLines_e6Vv
operation add_user(name: text, rating: integer) {
    // ...
}

query can_add_user(user: struct<add_user>) {
    if (user.name == '') return false;
    if (user.rating < 0) return false;
    return true;
}

```

Functions available for all `struct` types:

| Function | Description |
| --- | --- |
| `T.from_bytes(byte_array): T` | Decode from a binary-encoded `gtv`. Same as `T.from_gtv(gtv.from_bytes(x))`. |
| `T.from_gtv(gtv): T` | Decode from a `gtv`. |
| `T.from_gtv_pretty(gtv): T` | Decode from a pretty-encoded `gtv`. |
| `.to_bytes(): byte_array` | Encode in binary format. Same as `.to_gtv().to_bytes()`. |
| `.to_gtv(): gtv` | Convert to a `gtv`. |
| `.to_gtv_pretty(): gtv` | Convert to a pretty `gtv`. |
| `.to_gtx_operation(): gtx_operation` | Converts a `struct<operation>` to `gtx_operation`. |
| `.to_test_op(): rell.test.op` | Converts a `gtx_operation` to a `rell.test.op`. |

## Enhanced examples for struct usage [â€‹](\#enhanced-examples-for-struct-usage "Direct link to Enhanced examples for struct usage")

### `struct gtx_operation` [â€‹](\#struct-gtx_operation "Direct link to struct-gtx_operation")

Encapsulates individual operations within a transaction.

```codeBlockLines_e6Vv
struct gtx_operation {
        name: text;
        args: list<gtv>;
}

```

### `struct gtx_transaction_body` [â€‹](\#struct-gtx_transaction_body "Direct link to struct-gtx_transaction_body")

Defines the core content of a transaction, excluding signatures.

```codeBlockLines_e6Vv
struct gtx_transaction_body {
    blockchain_rid: byte_array;
    operations: list<gtx_operation>;
    signers: list<gtv>;
}

```

### `struct gtx_transaction` [â€‹](\#struct-gtx_transaction "Direct link to struct-gtx_transaction")

Represents a complete transaction, including signatures.

```codeBlockLines_e6Vv
struct gtx_transaction {
    body: gtx_transaction_body;
    signatures: list<gtv>;
}

```

### `struct rell.test.keypair` [â€‹](\#struct-relltestkeypair "Direct link to struct-relltestkeypair")

Facilitates test keypair generation and usage.

```codeBlockLines_e6Vv
struct rell.test.keypair {
      priv: byte_array; // private key, must be 32 bytes
      pub: byte_array; // public key, must be 33 bytes
}

```

- [Create structs](#create-structs)
- [Struct-copy of entities and objects](#struct-copy-of-entities-and-objects)
- [Create entities from structs](#create-entities-from-structs)
- [Access struct attributes](#access-struct-attributes)
- [Safe access for nullable structs](#safe-access-for-nullable-structs)
- [`Struct<mutable T>`](#structmutable-t)
- [`Struct<mutable T>`](#structmutable-t-1)
- [`struct<operation>`](#structoperation)
- [Enhanced examples for struct usage](#enhanced-examples-for-struct-usage)
  - [`struct gtx_operation`](#struct-gtx_operation)
  - [`struct gtx_transaction_body`](#struct-gtx_transaction_body)
  - [`struct gtx_transaction`](#struct-gtx_transaction)
  - [`struct rell.test.keypair`](#struct-relltestkeypair)- [@chromia/ft4](../index.html)
- [ft-session](../modules/ft_session.html)
- [createConnectionToBlockchainRid](ft_session.createConnectionToBlockchainRid.html)

# Function createConnectionToBlockchainRid

- createConnectionToBlockchainRid(oldConnection, newBlockchainRid): Promise< [Connection](../interfaces/ft_session.Connection.html) > [Permalink](#createConnectionToBlockchainRid)
- Uses the provided connection to create a new connection to the specified blockchain rid.
The new brid must be available in the cluster that the old connection is configured to use.





#### Parameters



- oldConnection: [Connection](../interfaces/ft_session.Connection.html)


a connection that can be used to fetch the new blockchain info

- newBlockchainRid: [BufferId](../types/utils.BufferId.html)


the rid of the blockchain to create connection for


#### Returns Promise< [Connection](../interfaces/ft_session.Connection.html) >

Connection instance configured to use the specified blockchain

### Settings

#### Member Visibility

- Protected
- Private
- Inherited

#### Theme

OSLightDark[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Namespace used for cryptographic functions.

- [Functions](#functions)
  - [`crypto.keccak256(byte_array): byte_array`](#cryptokeccak256byte_array-byte_array)
  - [`crypto.sha256(byte_array): byte_array`](#cryptosha256byte_array-byte_array)
  - [`crypto.privkey_to_pubkey(privkey: byte_array, compress: boolean = false): byte_array`](#cryptoprivkey_to_pubkeyprivkey-byte_array-compress-boolean--false-byte_array)
  - [`verify_signature(message: byte_array, pubkey: pubkey, signature: byte_array): boolean`](#verify_signaturemessage-byte_array-pubkey-pubkey-signature-byte_array-boolean)
  - [`crypto.eth_sign(hash: byte_array, privkey: byte_array): (byte_array, byte_array, integer)`](#cryptoeth_signhash-byte_array-privkey-byte_array-byte_array-byte_array-integer)
  - [`eth_ecrecover(r: byte_array, s: byte_array, rec_id: integer, hash: byte_array) -> byte_array`](#eth_ecrecoverr-byte_array-s-byte_array-rec_id-integer-hash-byte_array---byte_array)
  - [`crypto.eth_privkey_to_address(privkey: byte_array) -> byte_array`](#cryptoeth_privkey_to_addressprivkey-byte_array---byte_array)
  - [`crypto.eth_pubkey_to_address(pubkey: byte_array) -> byte_array`](#cryptoeth_pubkey_to_addresspubkey-byte_array---byte_array)
  - [`crypto.pubkey_encode(pubkey: byte_array, compressed: boolean = false) -> byte_array`](#cryptopubkey_encodepubkey-byte_array-compressed-boolean--false---byte_array)
  - [`crypto.pubkey_to_xy(pubkey: byte_array) -> (big_integer, big_integer)`](#cryptopubkey_to_xypubkey-byte_array---big_integer-big_integer)
  - [`crypto.xy_to_pubkey(x: big_integer, y: big_integer, compressed: boolean = false) -> byte_array`](#cryptoxy_to_pubkeyx-big_integer-y-big_integer-compressed-boolean--false---byte_array)

## Functions [â€‹](\#functions "Direct link to Functions")

### `crypto.keccak256(byte_array): byte_array` [â€‹](\#cryptokeccak256byte_array-byte_array "Direct link to cryptokeccak256byte_array-byte_array")

Calculates a Keccak256 hash of a byte array and returns a byte array of size 32. For example, `crypto.keccak256('Hello world!'.to_bytes())` produces `x'ecd0e108a98e192af1d2c25055f4e3bed784b5c877204e73219a5203251feaab'`.

**Parameters:**

- `byte_array`: The byte array to be hashed.

**Returns:**

- `byte_array`: A 32-byte Keccak256 hash of the input byte array.

### `crypto.sha256(byte_array): byte_array` [â€‹](\#cryptosha256byte_array-byte_array "Direct link to cryptosha256byte_array-byte_array")

Calculates an SHA-256 hash of a byte array and returns a byte array of size 32. For example, `crypto.sha256('Hello world!'.to_bytes())` produces `x'c0535e4be2b79ffd93291305436bf889314e4a3faec05ecffcbb7df31ad9e51a'`.

**Parameters:**

- `byte_array`: The byte array to be hashed.

**Returns:**

- `byte_array`: A 32-byte Keccak256 hash of the input byte array.

### `crypto.privkey_to_pubkey(privkey: byte_array, compress: boolean = false): byte_array` [â€‹](\#cryptoprivkey_to_pubkeyprivkey-byte_array-compress-boolean--false-byte_array "Direct link to cryptoprivkey_to_pubkeyprivkey-byte_array-compress-boolean--false-byte_array")

Calculates a public key from the private key. Takes a 32-byte private key and returns either a 65-byte (compress = `false`) or a 33-byte (compress = `true`) public key. For example, `crypto.privkey_to_pubkey(x'000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F', true)` produces `x'036d6caac248af96f6afa7f904f550253a0f3ef3f5aa2fe6838a95b216691468e2'`.

**Parameters:**

- `privkey`: The 32-byte private key.
- `compress` (optional): Boolean flag indicating whether to return the compressed (33-byte) or uncompressed (65-byte) public key. Defaults to `False` (uncompressed).

**Returns:**

- `byte_array`: The public key corresponding to the private key in the specified format (compressed or uncompressed).

### `verify_signature(message: byte_array, pubkey: pubkey, signature: byte_array): boolean` [â€‹](\#verify_signaturemessage-byte_array-pubkey-pubkey-signature-byte_array-boolean "Direct link to verify_signaturemessage-byte_array-pubkey-pubkey-signature-byte_array-boolean")

Verifies a signature against a message and public key. Returns `true` if the signature is valid, indicating that the owner of the private key corresponding to the provided public key indeed signed the message.

**Parameters:**

- `message`: The byte array representing the message that was signed.
- `pubkey`: The public key to verify the signature against.
- `signature`: The 64-byte signature to verify.

**Returns:**

- `boolean`: `true` if the signature is valid, `false` otherwise.

### `crypto.eth_sign(hash: byte_array, privkey: byte_array): (byte_array, byte_array, integer)` [â€‹](\#cryptoeth_signhash-byte_array-privkey-byte_array-byte_array-byte_array-integer "Direct link to cryptoeth_signhash-byte_array-privkey-byte_array-byte_array-byte_array-integer")

Calculates an Ethereum signature. Takes a hash and a private key and returns values `r`, `s`, and `rec_id` that are accepted by `eth_ecrecover()`.

**Parameters:**

- `hash`: The byte array representing the hash to be signed.
- `privkey`: The 32-byte private key used for signing.

**Returns:**

- ( `byte_array`, `byte_array`, `integer`): A tuple containing the following elements:
  - `r`: The first component of the Ethereum signature.
  - `s`: The second component of the Ethereum signature.
  - `rec_id`: The recovery identifier used for signature recovery.

### `eth_ecrecover(r: byte_array, s: byte_array, rec_id: integer, hash: byte_array) -> byte_array` [â€‹](\#eth_ecrecoverr-byte_array-s-byte_array-rec_id-integer-hash-byte_array---byte_array "Direct link to eth_ecrecoverr-byte_array-s-byte_array-rec_id-integer-hash-byte_array---byte_array")

Calculates an Ethereum public key from a signature and hash. Returns a byte array representing the public key.

**Parameters:**

- `r`: The first component of the Ethereum signature.
- `s`: The second component of the Ethereum signature.
- `rec_id`: The recovery identifier used for signature recovery.
- `hash`: The byte array representing the hash that was signed.

**Returns:**

- `byte_array`: The byte array representing the recovered public key.

### `crypto.eth_privkey_to_address(privkey: byte_array) -> byte_array` [â€‹](\#cryptoeth_privkey_to_addressprivkey-byte_array---byte_array "Direct link to cryptoeth_privkey_to_addressprivkey-byte_array---byte_array")

**Description:**

Derives a 20-byte Ethereum address from a 32-byte private key.

**Parameters:**

- `privkey`: The 32-byte private key.

**Returns:**

- `byte_array`: The 20-byte Ethereum address.

### `crypto.eth_pubkey_to_address(pubkey: byte_array) -> byte_array` [â€‹](\#cryptoeth_pubkey_to_addresspubkey-byte_array---byte_array "Direct link to cryptoeth_pubkey_to_addresspubkey-byte_array---byte_array")

Derives a 20-byte Ethereum address from a public key (33, 64, or 65 bytes).

**Parameters:**

- `pubkey`: The public key (33, 64, or 65 bytes).

**Returns:**

- `byte_array`: The 20-byte Ethereum address.

### `crypto.pubkey_encode(pubkey: byte_array, compressed: boolean = false) -> byte_array` [â€‹](\#cryptopubkey_encodepubkey-byte_array-compressed-boolean--false---byte_array "Direct link to cryptopubkey_encodepubkey-byte_array-compressed-boolean--false---byte_array")

Converts a public key between compressed (33-byte) and uncompressed (65-byte) formats.

**Parameters:**

- `pubkey`: The public key to be encoded.
- `compressed` (optional): Boolean flag indicating whether to return the compressed (33-byte) or uncompressed (65-byte) public key. Defaults to `false` (uncompressed).

**Returns:**

- `byte_array`: The encoded public key in the specified format.

### `crypto.pubkey_to_xy(pubkey: byte_array) -> (big_integer, big_integer)` [â€‹](\#cryptopubkey_to_xypubkey-byte_array---big_integer-big_integer "Direct link to cryptopubkey_to_xypubkey-byte_array---big_integer-big_integer")

Extracts the EC point coordinates (x, y) from a public key.

**Parameters:**

- `pubkey`: The public key.

**Returns:**

- ( `big_integer`, `big_integer`): A tuple containing the EC point coordinates (x, y).

### `crypto.xy_to_pubkey(x: big_integer, y: big_integer, compressed: boolean = false) -> byte_array` [â€‹](\#cryptoxy_to_pubkeyx-big_integer-y-big_integer-compressed-boolean--false---byte_array "Direct link to cryptoxy_to_pubkeyx-big_integer-y-big_integer-compressed-boolean--false---byte_array")

Constructs a public key (compressed or uncompressed) from EC point coordinates.

**Parameters:**

- `x`: The x-coordinate of the EC point.
- `y`: The y-coordinate of the EC point.
- `compressed` (optional): Boolean flag indicating whether to return the compressed (33-byte) or uncompressed (65-byte) public key. Defaults to `false` (uncompressed).

**Returns:**

- `byte_array`: The constructed public key in the specified format.

note

All functions that take a public key support three kinds of public keys:

- Compressed 33-byte public key.
- Uncompressed 65-byte public key.
- Uncompressed 64-byte public key - same as the 65-byte key, but without the first byte; such key is returned by the `crypto.eth_ecrecover()` function.

#### Example - verify signature [â€‹](\#example---verify-signature "Direct link to Example - verify signature")

```codeBlockLines_e6Vv
val pubkey = x'036d6caac248af96f6afa7f904f550253a0f3ef3f5aa2fe6838a95b216691468e2';
// = crypto.privkey_to_pubkey(x'000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F', true)

val message = x'DEADBEEF';
val signature = x'8ac02f17b508815fa9495177395925e41fd7db595ad35e54a56be6284e5b8e0824a3bd0e056dcfded7f8073d509b2b674607a06571abebdcb0bd27b12372aff2';

val ok = crypto.verify_signature(message, pubkey, signature);
print(ok); // prints "true"

```

#### Example - calculate an Ethereum signature with `eth_sign()` and recover the public key with `eth_ecrecover()` [â€‹](\#example---calculate-an-ethereum-signature-with-eth_sign-and-recover-the-public-key-with-eth_ecrecover "Direct link to example---calculate-an-ethereum-signature-with-eth_sign-and-recover-the-public-key-with-eth_ecrecover")

```codeBlockLines_e6Vv
val privkey = x'000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f';
val pubkey = crypto.privkey_to_pubkey(privkey);

val hash = 'Hello'.to_bytes();
val (r, s, rec_id) = crypto.eth_sign(hash, privkey);

val recovered_pubkey = x'04' + crypto.eth_ecrecover(r, s, rec_id, hash);
require(recovered_pubkey == pubkey);

```

- [Functions](#functions)
  - [`crypto.keccak256(byte_array): byte_array`](#cryptokeccak256byte_array-byte_array)
  - [`crypto.sha256(byte_array): byte_array`](#cryptosha256byte_array-byte_array)
  - [`crypto.privkey_to_pubkey(privkey: byte_array, compress: boolean = false): byte_array`](#cryptoprivkey_to_pubkeyprivkey-byte_array-compress-boolean--false-byte_array)
  - [`verify_signature(message: byte_array, pubkey: pubkey, signature: byte_array): boolean`](#verify_signaturemessage-byte_array-pubkey-pubkey-signature-byte_array-boolean)
  - [`crypto.eth_sign(hash: byte_array, privkey: byte_array): (byte_array, byte_array, integer)`](#cryptoeth_signhash-byte_array-privkey-byte_array-byte_array-byte_array-integer)
  - [`eth_ecrecover(r: byte_array, s: byte_array, rec_id: integer, hash: byte_array) -> byte_array`](#eth_ecrecoverr-byte_array-s-byte_array-rec_id-integer-hash-byte_array---byte_array)
  - [`crypto.eth_privkey_to_address(privkey: byte_array) -> byte_array`](#cryptoeth_privkey_to_addressprivkey-byte_array---byte_array)
  - [`crypto.eth_pubkey_to_address(pubkey: byte_array) -> byte_array`](#cryptoeth_pubkey_to_addresspubkey-byte_array---byte_array)
  - [`crypto.pubkey_encode(pubkey: byte_array, compressed: boolean = false) -> byte_array`](#cryptopubkey_encodepubkey-byte_array-compressed-boolean--false---byte_array)
  - [`crypto.pubkey_to_xy(pubkey: byte_array) -> (big_integer, big_integer)`](#cryptopubkey_to_xypubkey-byte_array---big_integer-big_integer)
  - [`crypto.xy_to_pubkey(x: big_integer, y: big_integer, compressed: boolean = false) -> byte_array`](#cryptoxy_to_pubkeyx-big_integer-y-big_integer-compressed-boolean--false---byte_array)- [@chromia/ft4](../index.html)
- [ft-session](ft_session.html)

# Module ft-session

### Index

### Interfaces

[Connection](../interfaces/ft_session.Connection.html) [Session](../interfaces/ft_session.Session.html)

### Type Aliases

[KeyStoreInteractor](../types/ft_session.KeyStoreInteractor.html) [OptionalLimit](../types/ft_session.OptionalLimit.html) [OptionalPageCursor](../types/ft_session.OptionalPageCursor.html) [PageCursor](../types/ft_session.PageCursor.html) [PagedResponse](../types/ft_session.PagedResponse.html)

### Functions

[call](../functions/ft_session.call.html) [callWithoutNop](../functions/ft_session.callWithoutNop.html) [createAuthDataService](../functions/ft_session.createAuthDataService.html) [createClientToBlockchain](../functions/ft_session.createClientToBlockchain.html) [createConnection](../functions/ft_session.createConnection.html) [createConnectionToBlockchainRid](../functions/ft_session.createConnectionToBlockchainRid.html) [createKeyStoreInteractor](../functions/ft_session.createKeyStoreInteractor.html) [createSession](../functions/ft_session.createSession.html)

### Settings

#### Member Visibility

- Protected
- Private
- Inherited

#### Theme

OSLightDark- [@chromia/ft4](../index.html)
- [events](../modules/events.html)
- [FTEventEmitter](events.FTEventEmitter.html)

# Class FTEventEmitter

Special case of the EventEmitter which is configured to emit events
defined in [events.FTEvents](../types/events.FTEvents.html)

#### Hierarchy ( [view full](../hierarchy.html\#events.FTEventEmitter))

- [EventEmitter](events.EventEmitter.html) < [FTEvents](../types/events.FTEvents.html) >
  - FTEventEmitter

##### Index

### Constructors

[constructor](events.FTEventEmitter.html#constructor)

### Methods

[emit](events.FTEventEmitter.html#emit) [off](events.FTEventEmitter.html#off) [on](events.FTEventEmitter.html#on)

## Constructors

### constructor [Permalink](\#constructor)

- new FTEventEmitter(): [FTEventEmitter](events.FTEventEmitter.html) [Permalink](#constructor.new_FTEventEmitter)
- #### Returns [FTEventEmitter](events.FTEventEmitter.html)


## Methods

### emit [Permalink](\#emit)

- emit< [K](events.FTEventEmitter.html#emit.emit-1.K) >(event, ...args): void [Permalink](#emit.emit-1)
- Fires the event, calling all registered listeners with the provided arguments.




#### Type Parameters



- K extends keyof [FTEvents](../types/events.FTEvents.html)

#### Parameters

- event: [K](events.FTEventEmitter.html#emit.emit-1.K)


The event name.

- `Rest`...args: [FTEvents](../types/events.FTEvents.html)\[ [K](events.FTEventEmitter.html#emit.emit-1.K)\]


The arguments for the listeners.


#### Returns void

### off [Permalink](\#off)

- off< [K](events.FTEventEmitter.html#off.off-1.K-1) >(event, listener): void [Permalink](#off.off-1)
- Removes a listener for the event.




#### Type Parameters



- K extends keyof [FTEvents](../types/events.FTEvents.html)

#### Parameters

- event: [K](events.FTEventEmitter.html#off.off-1.K-1)


The event name.

- listener: [Listener](../types/events.Listener.html) < [FTEvents](../types/events.FTEvents.html)\[ [K](events.FTEventEmitter.html#off.off-1.K-1)\]>


The listener callback.


#### Returns void

### on [Permalink](\#on)

- on< [K](events.FTEventEmitter.html#on.on-1.K-2) >(event, listener): (() =\> void) [Permalink](#on.on-1)
- Registers a new listener for the event.




#### Type Parameters



- K extends keyof [FTEvents](../types/events.FTEvents.html)

#### Parameters

- event: [K](events.FTEventEmitter.html#on.on-1.K-2)


The event name.

- listener: [Listener](../types/events.Listener.html) < [FTEvents](../types/events.FTEvents.html)\[ [K](events.FTEventEmitter.html#on.on-1.K-2)\]>


The listener callback.


#### Returns (() =\> void)

A function that removes the listener when called.

  - (): void
  - #### Returns void

### Settings

#### Member Visibility

- Protected
- Private
- Inherited

#### Theme

OSLightDark

### On This Page

[constructor](#constructor) [emit](#emit) [off](#off) [on](#on)- [@chromia/ft4](../index.html)
- [asset](../modules/asset.html)
- [getAssetsByType](asset.getAssetsByType.html)

# Function getAssetsByType

- getAssetsByType(queryable, type, limit?, cursor?): Promise< [PaginatedEntity](../types/utils.PaginatedEntity.html) < [Asset](../types/asset.Asset.html) >> [Permalink](#getAssetsByType)
- Retrieves all assets of a specific type, e.g., `"ft4"`, as a paginated entity





#### Parameters



- queryable: Queryable


object to use when querying the blockchain

- type: string


the type of assets to return

- limit: [OptionalLimit](../types/ft_session.OptionalLimit.html) = null


maximum page size

- cursor: [OptionalPageCursor](../types/ft_session.OptionalPageCursor.html) = null


where the page should start


#### Returns Promise< [PaginatedEntity](../types/utils.PaginatedEntity.html) < [Asset](../types/asset.Asset.html) >>

### Settings

#### Member Visibility

- Protected
- Private
- Inherited

#### Theme

OSLightDark- [@chromia/ft4](../index.html)
- [accounts](../modules/accounts.html)
- [AuthFlag](accounts.AuthFlag.html)

# Variable AuthFlag `Const`

AuthFlag:Readonly<{

Account: "A";

Transfer: "T";

}> = ...

#### Type declaration

- ##### Account: "A"

- ##### Transfer: "T"


### Settings

#### Member Visibility

- Protected
- Private
- Inherited

#### Theme

OSLightDark- [@chromia/ft4](../index.html)
- [admin](../modules/admin.html)
- [registerAccountAdmin](admin.registerAccountAdmin.html)

# Function registerAccountAdmin

- registerAccountAdmin(chromiaClient, adminSignatureProvider, authDescriptor): Promise< [TransactionCompletion](../types/utils.TransactionCompletion.html) > [Permalink](#registerAccountAdmin)
- registers a new account on the blockchain





#### Parameters



- chromiaClient: IClient


a client to connect to the blockchain

- adminSignatureProvider: SignatureProvider


a signature provider with the keypair stored
in chromia.yml under `lib.ft4.core.admin`

- authDescriptor: [AnyAuthDescriptorRegistration](../types/accounts.AnyAuthDescriptorRegistration.html)


the auth descriptor that will be used to access the
account. The account id will be copied from the auth descriptor id


#### Returns Promise< [TransactionCompletion](../types/utils.TransactionCompletion.html) >

a TransactionReceipt object that allows to check the status of the
transaction and its RID

### Settings

#### Member Visibility

- Protected
- Private
- Inherited

#### Theme

OSLightDark[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In Rell, loop statements include the `for`, `while`, `break`, and `continue` statements, each serving distinct purposes
for controlling program flow. This summary provides an overview of these loop statements and their applications.

### The `for` loop [â€‹](\#the-for-loop "Direct link to the-for-loop")

The `for` loop iterates over a specified range or collection, executing a block of code for each element. For example:

```codeBlockLines_e6Vv
for (x in range(10)) {
    print(x);
}

for (u in user @* {}) {
    print(u.name);
}

```

In the first `for` loop:

- `x` takes on values from 0 to 9 (inclusive) because of `range(10)`, which generates a sequence of numbers from 0 to 9.
- During each iteration, the `print(x)` statement prints the current value of `x`.

In the second `for` loop:

- `u` iterates over each `user` entity that matches the condition `@* {}`, which selects all users without any filtering
criteria.
- During each iteration, the `print(u.name)` statement prints the `name` attribute of the current `user` entity.

The expression after `in` may return a `range` or a collection ( `list`, `set`, `map`).

Can use tuple unpacking in a loop:

```codeBlockLines_e6Vv
val l: list<(integer, text)> = get_list();
for ((n, s) in l) { ... }

```

### The `while` loop [â€‹](\#the-while-loop "Direct link to the-while-loop")

The `while` loop repeatedly executes a block of code as long as a specified condition remains true. For example:

```codeBlockLines_e6Vv
while (x < 10) {
    print(x);
    x = x + 1;
}

```

This loop prints values of `x` while `x` is less than 10.

### The `break` statement [â€‹](\#the-break-statement "Direct link to the-break-statement")

The `break` statement is used to prematurely exit a loop when a certain condition is met. For example:

```codeBlockLines_e6Vv
for (u in user @* {}) {
    if (u.company == 'Facebook') {
        print(u.name);
        break;
    }
}

while (x < 5) {
    if (values[x] == 3) break;
    x = x + 1;
}

```

In the first `for` code snippet,

- The `for` loop iterates over all `user` entities in the blockchain (specified by `user @* {}`).
- During each iteration, it checks if the `company` attribute of the current `user` entity is equal to `'Facebook'`.
- If the condition is met, the `print(u.name)` statement prints the `name` attribute of the current user and then the
`break` statement is executed.
- The `break` statement immediately terminates the loop, meaning that no more iterations will occur even if there are
more `user` entities to process.
- This loop searches for a user whose company is `'Facebook'`, and as soon as such a user is found and printed, the loop
stops.

In the second `while` code snippet,

- The `while` loop continues to execute as long as the condition `x < 5` is true.
- Within the loop, there's a conditional statement that checks if the value at index `x` in the `values` array is equal
to `3`.
- If the condition is met, the `break` statement is executed, causing the loop to immediately terminate.
- If the condition is not met, the loop continues to the next iteration, incrementing the value of `x` by 1.
- This loop iterates through the `values` array, looking for the value `3`. As soon as it finds such a value, the loop
stops executing.

In both cases, the `break` statement is used to exit a loop prematurely based on a specific condition. It provides a way
to control the flow of the loop and terminate it early when certain criteria are met.

### The `continue` statement [â€‹](\#the-continue-statement "Direct link to the-continue-statement")

The `continue` statement is used to skip the remaining iterations of the current loop iteration and proceed to the next
iteration. For example:

```codeBlockLines_e6Vv
for (u in user @* {}) {
    if (u.company == 'BigCompanyCo') {
        continue;
    }
    print(u.name); // Will print every user who does not work at BigCompanyCo.
}

```

In this example:

- The `for` loop iterates over all `user` entities (specified by `user @* {}`).
- During each iteration, it checks if the `company` attribute of the current `user` entity is equal to `'BigCompanyCo'`.
- If the condition is met (if the user works at 'BigCompanyCo'), the `continue` statement is executed.
- The `continue` statement causes the loop to skip the rest of the code inside the loop block and move on to the next
iteration immediately.
- If the condition is not met (if the user does not work at 'BigCompanyCo'), the `print(u.name)` statement is executed,
printing the `name` attribute of the current user.

- [The `for` loop](#the-for-loop)
- [The `while` loop](#the-while-loop)
- [The `break` statement](#the-break-statement)
- [The `continue` statement](#the-continue-statement)- [@chromia/ft4](../index.html)
- [utils](../modules/utils.html)
- [getTransactionRid](utils.getTransactionRid.html)

# Function getTransactionRid

- getTransactionRid(tx): Buffer [Permalink](#getTransactionRid)
- Computes the transaction rid of the provided `RawGtx`





#### Parameters



- tx: RawGtx


the tx to compute the rid for


#### Returns Buffer

### Settings

#### Member Visibility

- Protected
- Private
- Inherited

#### Theme

OSLightDark- [@chromia/ft4](../index.html)
- [accounts](../modules/accounts.html)
- [Account](accounts.Account.html)

# Interface Account

Represents a blockchain account which is read only.
That is, using this object you can get information about
an account, but you cannot submit authenticated operations with it.

For an account to which it is possible to write, see [AuthenticatedAccount](accounts.AuthenticatedAccount.html)

interface Account{

[blockchainRid](accounts.Account.html#blockchainRid): Buffer;

[getAuthDescriptorById](accounts.Account.html#getAuthDescriptorById): ((authDescriptorId) =\> Promise< [AnyAuthDescriptor](../types/accounts.AnyAuthDescriptor.html) >);

[getAuthDescriptors](accounts.Account.html#getAuthDescriptors): (() =\> Promise< [AnyAuthDescriptor](../types/accounts.AnyAuthDescriptor.html)\[\]>);

[getAuthDescriptorsBySigner](accounts.Account.html#getAuthDescriptorsBySigner): ((signer) =\> Promise< [AnyAuthDescriptor](../types/accounts.AnyAuthDescriptor.html)\[\]>);

[getBalanceByAssetId](accounts.Account.html#getBalanceByAssetId): ((assetId) =\> Promise<null \| [Balance](../types/asset.Balance.html) >);

[getBalances](accounts.Account.html#getBalances): ((limit?, cursor?) =\> Promise< [PaginatedEntity](../types/utils.PaginatedEntity.html) < [Balance](../types/asset.Balance.html) >>);

[getLastPendingCrosschainTransfer](accounts.Account.html#getLastPendingCrosschainTransfer): ((targetBlockchainRid, recipientId, assetId, amount) =\> Promise<null \| [PendingTransfer](../types/crosschain.PendingTransfer.html) >);

[getMainAuthDescriptor](accounts.Account.html#getMainAuthDescriptor): (() =\> Promise< [AnyAuthDescriptor](../types/accounts.AnyAuthDescriptor.html) >);

[getPendingCrosschainTransfers](accounts.Account.html#getPendingCrosschainTransfers): ((limit?, cursor?) =\> Promise< [PaginatedEntity](../types/utils.PaginatedEntity.html) < [PendingTransfer](../types/crosschain.PendingTransfer.html) >>);

[getRateLimit](accounts.Account.html#getRateLimit): (() =\> Promise< [RateLimit](../types/accounts.RateLimit.html) >);

[getTransferHistory](accounts.Account.html#getTransferHistory): ((limit?, filter?, cursor?) =\> Promise< [PaginatedEntity](../types/utils.PaginatedEntity.html) < [TransferHistoryEntry](../types/accounts.TransferHistoryEntry.html) >>);

[getTransferHistoryEntry](accounts.Account.html#getTransferHistoryEntry): ((rowid) =\> Promise<null \| [TransferHistoryEntry](../types/accounts.TransferHistoryEntry.html) >);

[id](accounts.Account.html#id): Buffer;

[isAuthDescriptorValid](accounts.Account.html#isAuthDescriptorValid): ((authDescriptorId) =\> Promise<boolean>);

}

#### Hierarchy ( [view full](../hierarchy.html\#accounts.Account))

- Account
  - [AuthenticatedAccount](accounts.AuthenticatedAccount.html)

##### Index

### Properties

[blockchainRid](accounts.Account.html#blockchainRid) [getAuthDescriptorById](accounts.Account.html#getAuthDescriptorById) [getAuthDescriptors](accounts.Account.html#getAuthDescriptors) [getAuthDescriptorsBySigner](accounts.Account.html#getAuthDescriptorsBySigner) [getBalanceByAssetId](accounts.Account.html#getBalanceByAssetId) [getBalances](accounts.Account.html#getBalances) [getLastPendingCrosschainTransfer](accounts.Account.html#getLastPendingCrosschainTransfer) [getMainAuthDescriptor](accounts.Account.html#getMainAuthDescriptor) [getPendingCrosschainTransfers](accounts.Account.html#getPendingCrosschainTransfers) [getRateLimit](accounts.Account.html#getRateLimit) [getTransferHistory](accounts.Account.html#getTransferHistory) [getTransferHistoryEntry](accounts.Account.html#getTransferHistoryEntry) [id](accounts.Account.html#id) [isAuthDescriptorValid](accounts.Account.html#isAuthDescriptorValid)

## Properties

### blockchainRid [Permalink](\#blockchainRid)

blockchainRid:Buffer

### getAuthDescriptorById [Permalink](\#getAuthDescriptorById)

getAuthDescriptorById:((authDescriptorId) =\> Promise< [AnyAuthDescriptor](../types/accounts.AnyAuthDescriptor.html) >)

Fetches an auth descriptor by its ID.

#### Type declaration

- (authDescriptorId): Promise< [AnyAuthDescriptor](../types/accounts.AnyAuthDescriptor.html) >
- #### Parameters



- authDescriptorId: [BufferId](../types/utils.BufferId.html)


the id of the auth descriptor to fetch


#### Returns Promise< [AnyAuthDescriptor](../types/accounts.AnyAuthDescriptor.html) >

#### Remarks

the auth descriptor in question needs to be associated with this account and if no auth descriptor
is found, this method will throw an error

### getAuthDescriptors [Permalink](\#getAuthDescriptors)

getAuthDescriptors:(() =\> Promise< [AnyAuthDescriptor](../types/accounts.AnyAuthDescriptor.html)\[\]>)

Retrieves all auth descriptors associated with this account

#### Type declaration

- (): Promise< [AnyAuthDescriptor](../types/accounts.AnyAuthDescriptor.html)\[\]>
- #### Returns Promise< [AnyAuthDescriptor](../types/accounts.AnyAuthDescriptor.html)\[\]>

### getAuthDescriptorsBySigner [Permalink](\#getAuthDescriptorsBySigner)

getAuthDescriptorsBySigner:((signer) =\> Promise< [AnyAuthDescriptor](../types/accounts.AnyAuthDescriptor.html)\[\]>)

Retrieves all auth descriptors on which the specified signer is also a signer.

#### Type declaration

- (signer): Promise< [AnyAuthDescriptor](../types/accounts.AnyAuthDescriptor.html)\[\]>
- #### Parameters



- signer: [BufferId](../types/utils.BufferId.html)


the signer whose auth descriptors to retrieve


#### Returns Promise< [AnyAuthDescriptor](../types/accounts.AnyAuthDescriptor.html)\[\]>

### getBalanceByAssetId [Permalink](\#getBalanceByAssetId)

getBalanceByAssetId:((assetId) =\> Promise<null \| [Balance](../types/asset.Balance.html) >)

Retrieves the balance for a specific asset

#### Type declaration

- (assetId): Promise<null \| [Balance](../types/asset.Balance.html) >
- #### Parameters



- assetId: [BufferId](../types/utils.BufferId.html)


the id of the asset to fetch balance for


#### Returns Promise<null \| [Balance](../types/asset.Balance.html) >

#### Returns

the balance of the asset on this account, or `null` if this account does not have the asset

### getBalances [Permalink](\#getBalances)

getBalances:((limit?, cursor?) =\> Promise< [PaginatedEntity](../types/utils.PaginatedEntity.html) < [Balance](../types/asset.Balance.html) >>)

Retrieves all the balances of all assets that is available on the account and returns them as
a paginated entity.

#### Type declaration

- (limit?, cursor?): Promise< [PaginatedEntity](../types/utils.PaginatedEntity.html) < [Balance](../types/asset.Balance.html) >>
- #### Parameters



- `Optional` limit: number


maximum page size

- `Optional` cursor: [OptionalPageCursor](../types/ft_session.OptionalPageCursor.html)


where the page should start


#### Returns Promise< [PaginatedEntity](../types/utils.PaginatedEntity.html) < [Balance](../types/asset.Balance.html) >>

### getLastPendingCrosschainTransfer [Permalink](\#getLastPendingCrosschainTransfer)

getLastPendingCrosschainTransfer:((targetBlockchainRid, recipientId, assetId, amount) =\> Promise<null \| [PendingTransfer](../types/crosschain.PendingTransfer.html) >)

Retrieves the most recent pending transfer which matches the specified arguments

#### Type declaration

- (targetBlockchainRid, recipientId, assetId, amount): Promise<null \| [PendingTransfer](../types/crosschain.PendingTransfer.html) >
- #### Parameters



- targetBlockchainRid: [BufferId](../types/utils.BufferId.html)


the rid of the blockchain that the transfer was targeting

- recipientId: [BufferId](../types/utils.BufferId.html)


the id of the account that is going to receive the transfer

- assetId: [BufferId](../types/utils.BufferId.html)


the id of the asset that is being transferred

- amount: bigint


how much of the asset that is being transferred


#### Returns Promise<null \| [PendingTransfer](../types/crosschain.PendingTransfer.html) >

#### Returns

the latest pending transfer that matches the criteria. Or null if no such transfer is found

### getMainAuthDescriptor [Permalink](\#getMainAuthDescriptor)

getMainAuthDescriptor:(() =\> Promise< [AnyAuthDescriptor](../types/accounts.AnyAuthDescriptor.html) >)

Retrieves the main auth descriptor of this account

#### Type declaration

- (): Promise< [AnyAuthDescriptor](../types/accounts.AnyAuthDescriptor.html) >
- #### Returns Promise< [AnyAuthDescriptor](../types/accounts.AnyAuthDescriptor.html) >

### getPendingCrosschainTransfers [Permalink](\#getPendingCrosschainTransfers)

getPendingCrosschainTransfers:((limit?, cursor?) =\> Promise< [PaginatedEntity](../types/utils.PaginatedEntity.html) < [PendingTransfer](../types/crosschain.PendingTransfer.html) >>)

Retrieves all pending (i.e., started but not yet completed) cross chain transfers initiated by this account.

#### Type declaration

- (limit?, cursor?): Promise< [PaginatedEntity](../types/utils.PaginatedEntity.html) < [PendingTransfer](../types/crosschain.PendingTransfer.html) >>
- #### Parameters



- `Optional` limit: [OptionalLimit](../types/ft_session.OptionalLimit.html)


maximum page size

- `Optional` cursor: [OptionalPageCursor](../types/ft_session.OptionalPageCursor.html)


where the page should start


#### Returns Promise< [PaginatedEntity](../types/utils.PaginatedEntity.html) < [PendingTransfer](../types/crosschain.PendingTransfer.html) >>

### getRateLimit [Permalink](\#getRateLimit)

getRateLimit:(() =\> Promise< [RateLimit](../types/accounts.RateLimit.html) >)

Retrieves the current rate limit for this account. I.e., how many points this account currently has.

#### Type declaration

- (): Promise< [RateLimit](../types/accounts.RateLimit.html) >
- #### Returns Promise< [RateLimit](../types/accounts.RateLimit.html) >

### getTransferHistory [Permalink](\#getTransferHistory)

getTransferHistory:((limit?, filter?, cursor?) =\> Promise< [PaginatedEntity](../types/utils.PaginatedEntity.html) < [TransferHistoryEntry](../types/accounts.TransferHistoryEntry.html) >>)

Retrieves the full transfer history for this account as a paginated entity.

#### Type declaration

- (limit?, filter?, cursor?): Promise< [PaginatedEntity](../types/utils.PaginatedEntity.html) < [TransferHistoryEntry](../types/accounts.TransferHistoryEntry.html) >>
- #### Parameters



- `Optional` limit: number


maximum page size

- `Optional` filter: [TransferHistoryFilter](../types/accounts.TransferHistoryFilter.html)


a filter to determine what type of transfer history entries to fetch

- `Optional` cursor: [OptionalPageCursor](../types/ft_session.OptionalPageCursor.html)


where the page should start


#### Returns Promise< [PaginatedEntity](../types/utils.PaginatedEntity.html) < [TransferHistoryEntry](../types/accounts.TransferHistoryEntry.html) >>

### getTransferHistoryEntry [Permalink](\#getTransferHistoryEntry)

getTransferHistoryEntry:((rowid) =\> Promise<null \| [TransferHistoryEntry](../types/accounts.TransferHistoryEntry.html) >)

Retrieves a specific `TransferHistoryEntry`

#### Type declaration

- (rowid): Promise<null \| [TransferHistoryEntry](../types/accounts.TransferHistoryEntry.html) >
- #### Parameters



- rowid: number


the rowid of the `TransferHistoryEntry`


#### Returns Promise<null \| [TransferHistoryEntry](../types/accounts.TransferHistoryEntry.html) >

#### Returns

the requested transfer history entry, or `null` if that `rowid` does not exist.

### id [Permalink](\#id)

id:Buffer

### isAuthDescriptorValid [Permalink](\#isAuthDescriptorValid)

isAuthDescriptorValid:((authDescriptorId) =\> Promise<boolean>)

Determines whether the auth descriptor with the specified id is valid.

#### Type declaration

- (authDescriptorId): Promise<boolean>
- #### Parameters



- authDescriptorId: [BufferId](../types/utils.BufferId.html)


the id of the auth descriptor to check


#### Returns Promise<boolean>

#### Returns

true or false depending on if the auth descriptor is valid or not

### Settings

#### Member Visibility

- Protected
- Private
- Inherited

#### Theme

OSLightDark

### On This Page

[blockchainRid](#blockchainRid) [getAuthDescriptorById](#getAuthDescriptorById) [getAuthDescriptors](#getAuthDescriptors) [getAuthDescriptorsBySigner](#getAuthDescriptorsBySigner) [getBalanceByAssetId](#getBalanceByAssetId) [getBalances](#getBalances) [getLastPendingCrosschainTransfer](#getLastPendingCrosschainTransfer) [getMainAuthDescriptor](#getMainAuthDescriptor) [getPendingCrosschainTransfers](#getPendingCrosschainTransfers) [getRateLimit](#getRateLimit) [getTransferHistory](#getTransferHistory) [getTransferHistoryEntry](#getTransferHistoryEntry) [id](#id) [isAuthDescriptorValid](#isAuthDescriptorValid)- [@chromia/ft4](../index.html)
- [authentication](../modules/authentication.html)
- [createWeb3ProviderEvmKeyStore](authentication.createWeb3ProviderEvmKeyStore.html)

# Function createWeb3ProviderEvmKeyStore

- createWeb3ProviderEvmKeyStore(externalProvider): Promise< [EvmKeyStore](../interfaces/authentication.EvmKeyStore.html) > [Permalink](#createWeb3ProviderEvmKeyStore)
- Creates a keystore that wraps an external evm keystore, such as MetaMask.
In a browser context where the user has the MetaMask browser extension installed
and connected to the page, this could be used like:



```
createWeb3ProviderEvmKeyStore(window.ethereum)
Copy
```





#### Parameters



- externalProvider: [Eip1193Provider](../interfaces/authentication.Eip1193Provider.html)


interface to use when communicating with the external provider


#### Returns Promise< [EvmKeyStore](../interfaces/authentication.EvmKeyStore.html) >

### Settings

#### Member Visibility

- Protected
- Private
- Inherited

#### Theme

OSLightDark# RellSystemLibrary

relltest

The Rell Standard Library contains the essential building blocks for writing your rell dapp. It contains:

- Basic data types

- Cryptographic functions

- Chain metadata

- Test library functions


The Rell Standard Library contains the essential building blocks for writing your rell dapp. It contains:

- Basic data types

- Cryptographic functions

- Chain metadata

- Test library functions


## Namespaces

[\[root\]](-rell -system -library/[root]/index.html)

Link copied to clipboard

rell

test

Global namespace containing types and functions accessible without any namespace prefix.

[chain\_context](-rell -system -library/chain_context/index.html)

Link copied to clipboard

rell

Blockchain metadata and module arguments.

[crypto](-rell -system -library/crypto/index.html)

Link copied to clipboard

rell

Cryptographic functions.

[op\_context](-rell -system -library/op_context/index.html)

Link copied to clipboard

rell

Functions and properties that are only accessible withing the scope of an operation.

[rell](-rell -system -library/rell/index.html)

Link copied to clipboard

rell

Meta information about rell types.

[rell.test](-rell -system -library/rell.test/index.html)

Link copied to clipboard

test

The rell.test namespace is only accessible within test modules

[rell.test.keypairs](-rell -system -library/rell.test.keypairs/index.html)

Link copied to clipboard

test

Predefined keypairs that can be used for testing.

[rell.test.privkeys](-rell -system -library/rell.test.privkeys/index.html)

Link copied to clipboard

test

Predefined private keys that can be used for testing.

[rell.test.pubkeys](-rell -system -library/rell.test.pubkeys/index.html)

Link copied to clipboard

test

Predefined public keys that can be used for testing.[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In Rell, the concept of subtypes enhances code flexibility and reusability by allowing seamless assignment between
compatible types.

If type `B` is a subtype of type `A`, you can freely assign a value of type `B` to a variable of type `A` or pass it as
an argument to a function expecting type `A`.

### Common subtype relationships [â€‹](\#common-subtype-relationships "Direct link to Common subtype relationships")

- **Optional types**:
  - `T` is a subtype of `T?` (a non-nullable type is a subtype of its nullable counterpart).
  - `null` is a subtype of `T?` (null can be assigned to any nullable type).
- **Tuples**:
  - `(T, P)` is a subtype of `(T?, P?)`, `(T?, P)`, and `(T, P?)` (tuples with more specific types are subtypes of
    tuples with more general types).

- [Common subtype relationships](#common-subtype-relationships)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Rell offers various data types for managing information in your dapps. Here's an overview of the fundamental types
you'll use.

### Simple values [â€‹](\#simple-values "Direct link to Simple values")

- **Null**: Represents the absence of a value. It has its own distinct type, `null`.
- **Boolean**: Represents logical values, either `true` or `false`. Employ them for conditional logic and
decision-making.
- **Integer**: Represents whole numbers, both positive and negative, like `123`, `0`, and `-456`. Use them for counting,
indexing, and mathematical operations.
- **Text**: Represents sequences of characters, enclosed in either single quotes ( `'Hello'`) or double quotes
( `"World"`). Store and manipulate text data effectively.
- **Byte array**: Represents a sequence of bytes, essential for handling binary data. Prefix them with `x'` for single
quotes or `x"` for double quotes (e.g., `x'1234'`, `x"ABCD"`).
- **Big integer**: Represents arbitrarily large whole numbers, denoted by a suffix of `L` (e.g.,
`9223372036854775832L`). Handle massive numerical values with ease.
- **Decimal**: Represents numbers with decimal places, like `123.456`. Crucial for precise calculations and financial
applications.

### Text literals [â€‹](\#text-literals "Direct link to Text literals")

- **Standard**: `\r` (carriage return), `\n` (line feed), `\t` (tab), `\b` (backspace)
- **Special characters**: `\"` (double quote), `\'` (single quote), `\\` (backslash)
- **Unicode**: `\u003A` (e.g., represents a colon)

- [Simple values](#simple-values)
- [Text literals](#text-literals)- [@chromia/ft4](../index.html)
- [authentication](../modules/authentication.html)
- [authFlags](authentication.authFlags.html)

# Function authFlags

- authFlags(operation): QueryObject<string\[\], {

op\_name: string;

}> [Permalink](#authFlags)
- Retrieves the required auth flags for the specified operation





#### Parameters



- operation: Operation


the operation to get flags for


#### Returns QueryObject<string\[\], {   op\_name: string;   }>

list of required flags, or empty list if no specific flags are required

### Settings

#### Member Visibility

- Protected
- Private
- Inherited

#### Theme

OSLightDark- [@chromia/ft4](../index.html)
- [accounts](../modules/accounts.html)
- [getBySigner](accounts.getBySigner.html)

# Function getBySigner

- getBySigner(connection, id, limit?, cursor?): Promise< [PaginatedEntity](../types/utils.PaginatedEntity.html) < [Account](../interfaces/accounts.Account.html) >> [Permalink](#getBySigner)
- Fetches all accounts that the provided signer has access to as a paginated entity





#### Parameters



- connection: [Connection](../interfaces/ft_session.Connection.html)


the blockchain connection to use

- id: [BufferId](../types/utils.BufferId.html)


signer pubkey or evm address (without `0x`-prefix)

- limit: [OptionalLimit](../types/ft_session.OptionalLimit.html) = null


maximum page size

- cursor: [OptionalPageCursor](../types/ft_session.OptionalPageCursor.html) = null


where the page should start


#### Returns Promise< [PaginatedEntity](../types/utils.PaginatedEntity.html) < [Account](../interfaces/accounts.Account.html) >>

### Settings

#### Member Visibility

- Protected
- Private
- Inherited

#### Theme

OSLightDark- [@chromia/ft4](../index.html)
- [authentication](../modules/authentication.html)
- [EvmKeyStore](authentication.EvmKeyStore.html)

# Interface EvmKeyStore

Represents a key store which holds an evm key

interface EvmKeyStore{

[address](authentication.EvmKeyStore.html#address): Buffer;

[id](authentication.EvmKeyStore.html#id): Buffer;

[isInteractive](authentication.EvmKeyStore.html#isInteractive): boolean;

[createKeyHandler](authentication.EvmKeyStore.html#createKeyHandler.createKeyHandler-1)(authDescriptor): [KeyHandler](authentication.KeyHandler.html);

[signMessage](authentication.EvmKeyStore.html#signMessage.signMessage-1)(message): Promise< [Signature](../types/authentication.Signature.html) >;

}

#### Hierarchy ( [view full](../hierarchy.html\#authentication.EvmKeyStore))

- [KeyStore](authentication.KeyStore.html)
- [EvmSigner](authentication.EvmSigner.html)
  - EvmKeyStore

##### Index

### Properties

[address](authentication.EvmKeyStore.html#address) [id](authentication.EvmKeyStore.html#id) [isInteractive](authentication.EvmKeyStore.html#isInteractive)

### Methods

[createKeyHandler](authentication.EvmKeyStore.html#createKeyHandler) [signMessage](authentication.EvmKeyStore.html#signMessage)

## Properties

### address [Permalink](\#address)

address:Buffer

### id [Permalink](\#id)

id:Buffer

### isInteractive [Permalink](\#isInteractive)

isInteractive:boolean

## Methods

### createKeyHandler [Permalink](\#createKeyHandler)

- createKeyHandler(authDescriptor): [KeyHandler](authentication.KeyHandler.html) [Permalink](#createKeyHandler.createKeyHandler-1)
- Creates a KeyHandler instance from this KeyStore instance





#### Parameters



- authDescriptor: [AnyAuthDescriptor](../types/accounts.AnyAuthDescriptor.html)


the auth descriptor to use with the KeyHandler


#### Returns [KeyHandler](authentication.KeyHandler.html)

### signMessage [Permalink](\#signMessage)

- signMessage(message): Promise< [Signature](../types/authentication.Signature.html) > [Permalink](#signMessage.signMessage-1)
- Signs an auth message





#### Parameters



- message: string


the message to sign


#### Returns Promise< [Signature](../types/authentication.Signature.html) >

### Settings

#### Member Visibility

- Protected
- Private
- Inherited

#### Theme

OSLightDark

### On This Page

[address](#address) [id](#id) [isInteractive](#isInteractive) [createKeyHandler](#createKeyHandler) [signMessage](#signMessage)- [@chromia/ft4](../index.html)
- [registration](../modules/registration.html)
- [subscriptionDetails](registration.subscriptionDetails.html)

# Function subscriptionDetails

- subscriptionDetails(accountId): QueryObject<{

asset\_id: Buffer;

last\_payment: number;

period\_millis: number;

}, {

account\_id: Buffer;

}> [Permalink](#subscriptionDetails)
- Creates a query object for the `get_subscription_details` \- query





#### Parameters



- accountId: [BufferId](../types/utils.BufferId.html)


the id of the account to fetch subscription details for


#### Returns QueryObject<{   asset\_id: Buffer;   last\_payment: number;   period\_millis: number;   }, {   account\_id: Buffer;   }>

### Settings

#### Member Visibility

- Protected
- Private
- Inherited

#### Theme

OSLightDark[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In Rell, functions streamline repetitive tasks by encapsulating reusable logic, such as validation or data retrieval.

- Functions can return various data types, including custom entities and objects. Without an explicit return type
declaration, a function implicitly returns `unit` (no value).
- When called within operations, functions can modify the database, enabling dynamic and interactive applications.
- Functions can be invoked from queries, operations, and other functions, promoting code organization and modularity.

#### Short form (concise expressions): [â€‹](\#short-form-concise-expressions "Direct link to Short form (concise expressions):")

```codeBlockLines_e6Vv
function f(x: integer): integer = x * x;

```

#### Full form (multi-line logic): [â€‹](\#full-form-multi-line-logic "Direct link to Full form (multi-line logic):")

```codeBlockLines_e6Vv
function f(x: integer): integer {
    return x * x;
}

```

#### Return types: [â€‹](\#return-types "Direct link to Return types:")

- **Explicitly declared**: Use a colon and the desired type name to clearly define the expected return value.
- **Implicit `unit`**: If no return type is specified, the function implicitly returns `unit`.

```codeBlockLines_e6Vv
function f(x: integer) {
    print(x);
}

```

## Default parameter values [â€‹](\#default-parameter-values "Direct link to Default parameter values")

Streamline function calls by providing default values for certain parameters. The default parameters get used if you
don't specify the parameters in the function call.

```codeBlockLines_e6Vv
function f(user: text = 'Bob', score: integer = 123) {...}
...
f();        // means f('Bob', 123)
f('Alice'); // means f('Alice', 123)
f(score=456);  // means f('Bob', 456)

```

## Named function arguments [â€‹](\#named-function-arguments "Direct link to Named function arguments")

Improve readability and maintainability by explicitly naming arguments during function calls.

```codeBlockLines_e6Vv
function f(x: integer, y: text) {}
...
f(x = 123, y = 'Hello');

```

## Using a function as a value [â€‹](\#using-a-function-as-a-value "Direct link to Using a function as a value")

Pass functions as arguments to other functions, enabling powerful abstractions and code reuse. If you want to pass a
function to another function, then you can use the function as a value by using the following syntax:

```codeBlockLines_e6Vv
() -> boolean
(integer) -> text
(byte_array, decimal) -> integer

```

Within the parentheses, you specify the function input type of the passed function after the arrow follows the
function's return type.

An example could look like this:

```codeBlockLines_e6Vv
function filter(values: list<integer>, predicate: (integer) -> boolean): list<integer> {
    return values @* { predicate($) };
}

```

## Partial function application [â€‹](\#partial-function-application "Direct link to Partial function application")

Create new functions by pre-filling some arguments of an existing function, promoting code flexibility. You can use the
wildcard symbol `*` to create a reference to a function (to obtain a value of a function).

```codeBlockLines_e6Vv
function multiply(x: integer, y: integer) = x * y;

val double = multiply(2, *);
// Type of "double" is (integer) -> integer
 double(456);                // Invocation of multiply(2, 456) via "g"

```

## Extendable functions [â€‹](\#extendable-functions "Direct link to Extendable functions")

You can declare a function as extendable by adding `@extendable` before the function declaration. You can define an
arbitrary number of extensions for an extendable function by expressing `@extend` before the function declaration.

In the example below, function `f` is a base function, and functions `g` and `h` are extension functions.

```codeBlockLines_e6Vv
@extendable function f(x: integer) {
    print('f', x);
}

@extend(f) function g(x: integer) {
    print('g', x);
}

@extend(f) function h(x: integer) {
    print('h', x);
}

```

When you call the base function, all its extension functions get executed, and the base function itself gets executed.
However, extendable functions support a limited set of return types, and this behavior depends on the return type.

### Return type-specific behavior [â€‹](\#return-type-specific-behavior "Direct link to Return type-specific behavior")

- **Unit**: All extensions and the base function execute unconditionally.
- **Boolean**: Extensions execute until one returns `true`; the base function executes only if all extensions return
`false`. The last executed function's result is returned.
- **Optional ( `T?`)**: Similar to Boolean, but extensions execute until one returns a non-null value.
- **List ( `list<T>`)**: All extensions and the base function execute, and their lists are concatenated in the returned
result.
- **Map ( `map<K, V>`)**: Similar to List, but maps are combined into a union, failing if key conflicts arise.

- [Default parameter values](#default-parameter-values)
- [Named function arguments](#named-function-arguments)
- [Using a function as a value](#using-a-function-as-a-value)
- [Partial function application](#partial-function-application)
- [Extendable functions](#extendable-functions)
  - [Return type-specific behavior](#return-type-specific-behavior)- [@chromia/ft4](../index.html)
- [authentication](../modules/authentication.html)
- [FtKeyStore](authentication.FtKeyStore.html)

# Interface FtKeyStore

Represents a key store which holds an ft key

interface FtKeyStore{

[id](authentication.FtKeyStore.html#id): Buffer;

[isInteractive](authentication.FtKeyStore.html#isInteractive): boolean;

[pubKey](authentication.FtKeyStore.html#pubKey): Buffer;

[createKeyHandler](authentication.FtKeyStore.html#createKeyHandler.createKeyHandler-1)(authDescriptor): [KeyHandler](authentication.KeyHandler.html);

[sign](authentication.FtKeyStore.html#sign.sign-1)(transaction): Promise<Buffer>;

}

#### Hierarchy ( [view full](../hierarchy.html\#authentication.FtKeyStore))

- [KeyStore](authentication.KeyStore.html)
- [FtSigner](authentication.FtSigner.html)
  - FtKeyStore

##### Index

### Properties

[id](authentication.FtKeyStore.html#id) [isInteractive](authentication.FtKeyStore.html#isInteractive) [pubKey](authentication.FtKeyStore.html#pubKey)

### Methods

[createKeyHandler](authentication.FtKeyStore.html#createKeyHandler) [sign](authentication.FtKeyStore.html#sign)

## Properties

### id [Permalink](\#id)

id:Buffer

### isInteractive [Permalink](\#isInteractive)

isInteractive:boolean

### pubKey [Permalink](\#pubKey)

pubKey:Buffer

## Methods

### createKeyHandler [Permalink](\#createKeyHandler)

- createKeyHandler(authDescriptor): [KeyHandler](authentication.KeyHandler.html) [Permalink](#createKeyHandler.createKeyHandler-1)
- Creates a KeyHandler instance from this KeyStore instance





#### Parameters



- authDescriptor: [AnyAuthDescriptor](../types/accounts.AnyAuthDescriptor.html)


the auth descriptor to use with the KeyHandler


#### Returns [KeyHandler](authentication.KeyHandler.html)

### sign [Permalink](\#sign)

- sign(transaction): Promise<Buffer> [Permalink](#sign.sign-1)
- Signs a transaction





#### Parameters



- transaction: RawGtx \| GTX


the transaction to sign


#### Returns Promise<Buffer>

the signed transaction, serialized to a `Buffer`

### Settings

#### Member Visibility

- Protected
- Private
- Inherited

#### Theme

OSLightDark

### On This Page

[id](#id) [isInteractive](#isInteractive) [pubKey](#pubKey) [createKeyHandler](#createKeyHandler) [sign](#sign)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Rell supports the following collection types:

- `list<T>` \- An ordered list that allows duplicate elements.
- `set<T>` \- An unordered set that does not contain duplicate elements.
- `map<K,V>` \- A key-value map.

## Properties of collection types [â€‹](\#properties-of-collection-types "Direct link to Properties of collection types")

- **Mutable:** You can dynamically add or remove elements.
- **Map key or set element:** Only non-mutable types can be used as map keys or set elements.

## Mutable collection types [â€‹](\#mutable-collection-types "Direct link to Mutable collection types")

- **Collection types (list, set, map):** Always mutable.
- **Nullable type:** Only if the underlying type is mutable.
- **Struct type:** If the struct has a mutable field or a field of a mutable type.
- **Tuple:** If an element type is mutable.

## Creating collections [â€‹](\#creating-collections "Direct link to Creating collections")

```codeBlockLines_e6Vv
function foo() {
  // list
  val l1 = [1, 2, 3, 4, 5, 1];
  val l2 = list < integer > ();

  // set
  val s = set < integer > ();

  // map
  val m1 = ['Bob': 123, 'Alice': 456];
  val m2 = map < text, integer > ();
}

```

## `list<T>` [â€‹](\#listt "Direct link to listt")

A list is an ordered collection type that allows duplicate elements.

### Constructors [â€‹](\#constructors "Direct link to Constructors")

- `list<T>()` \- Creates a new empty list.

- `list<T>(list<T>)` \- Creates a copy of the given list (a list of a subtype is also acceptable).

- `list<T>(set<T>)` \- Creates a copy of the given set (a set of a subtype is also acceptable).


### Functions [â€‹](\#functions "Direct link to Functions")

| Function | Description |
| --- | --- |
| `.add(T): boolean` | Adds an element to the end of the list. Always returns `true`. |
| `.add(pos: integer, T): boolean` | Inserts an element at a given position in the list. Always returns `true`. |
| `.add_all(list<T>): boolean` | Adds all elements from the given list to the end of the list. |
| `.add_all(set<T>): boolean` | Adds all elements from the given set to the end of the list. |
| `.add_all(pos: integer, list<T>): boolean` | Inserts all elements from the given list at the specified position in the list. |
| `.add_all(pos: integer, set<T>): boolean` | Inserts all elements from the given set at the specified position in the list. |
| `.clear()` | Removes all elements from the list. |
| `.contains(T): boolean` | Checks if the list contains the specified element. |
| `.contains_all(list<T>): boolean` | Checks if the list contains all elements from the given list. |
| `.contains_all(set<T>): boolean` | Checks if the list contains all elements from the given set. |
| `.empty(): boolean` | Returns true if the list is empty, otherwise returns false. |
| `.index_of(T): integer` | Returns the position of the first occurrence of the element in the list. Returns `-1` if the element isn't found. |
| `.remove(T): boolean` | Removes the first occurrence of the specified element from the list. Returns `true` if found. |
| `.remove_all(list<T>): boolean` | Removes all elements from the list that are present in the given list. |
| `.remove_all(set<T>): boolean` | Removes all elements from the list that are present in the given set. |
| `.remove_at(pos: integer): T` | Removes the element at the given position in the list and returns it. |
| `.repeat(n: integer): list<T>` | Returns a new list, which is the old list repeated "n" times. Always creates a new list (even if n = 1). |
| `.size(): integer` | Returns the number of elements in the list. |
| `.reverse()` | Reverses the order of elements in the list in place. Returns nothing. |
| `.reversed(): list<T>` | Returns a reversed copy of the list. Always creates a new list (even if the old list is empty or has one element). |
| `._sort()` | Sorts the list in ascending order. Returns nothing. |
| `.sorted(): list<T>` | Returns a sorted copy of the list in ascending order. |
| `.to_text(): text` | Returns a text representation of the list, e.g., `'[1, 2, 3, 4, 5]'`. |
| `.sub(start: integer[, end: integer]): list<T>` | Returns a sub-list (start-inclusive, end-exclusive) from the list. |

### Special operators [â€‹](\#special-operators "Direct link to Special operators")

- `[]` \- Accesses or modifies an element at a specified index in the list.
- `in` \- Checks if a specified value exists in the list, returning `true` if it does.

#### Example: [â€‹](\#example "Direct link to Example:")

```codeBlockLines_e6Vv
function example_list() {
    // Creating a list of transactions
    val transactions = list<Transaction>();

    // Adding transactions to the list
    transactions.add(Transaction(id = 1, amount = 100, sender = "Alice", recipient = "Bob"));
    transactions.add(Transaction(id = 2, amount = 200, sender = "Bob", recipient = "Charlie"));
    transactions.add(Transaction(id = 3, amount = 150, sender = "Charlie", recipient = "Alice"));

    // Accessing a transaction by index
    val firstTransaction = transactions[0];
    print("First transaction amount: ${firstTransaction.amount}");

    // Modifying a transaction at a specific index
    transactions[1] = Transaction(id = 2, amount = 250, sender = "Bob", recipient = "Charlie");

    // Using contains with a custom equality check
    val searchTransaction = Transaction(id = 3, amount = 150, sender = "Charlie", recipient = "Alice");
    if (searchTransaction in transactions) {
        print("Transaction found in the list");
    }

    // Using sub to get a portion of the list
    val subList = transactions.sub(0, 2);
    print("Sub-list size: ${subList.size()}");

    // Creating a reversed copy of the list
    val reversedList = transactions.reversed();

    // Converting the list to text
    print("Transactions: ${transactions.to_text()}");
}

```

## `set<T>` [â€‹](\#sett "Direct link to sett")

An unordered collection type that does not allow duplicate elements.

```codeBlockLines_e6Vv
struct Address {
    value: text;
}

function example_set() {
    // Creating a set of unique addresses
    val uniqueAddresses = set<Address>();

    // Adding addresses to the set
    uniqueAddresses.add(Address("0xabc123"));
    uniqueAddresses.add(Address("0xdef456"));
    uniqueAddresses.add(Address("0xabc123")); // This won't be added as it's a duplicate

    // Checking if an address exists in the set
    if (Address("0xabc123") in uniqueAddresses) {
        print("Address 0xabc123 is in the set");
    }

    // Removing an address from the set
    uniqueAddresses.remove(Address("0xabc123"));

    // Adding multiple addresses at once
    val newAddresses = [Address("0xghi789"), Address("0xjkl012")];
    uniqueAddresses.add_all(newAddresses);

    // Printing the set
    print("Unique addresses: ${uniqueAddresses.to_text()}");
}

```

### Constructors [â€‹](\#constructors-1 "Direct link to Constructors")

- `set<T>()` \- Creates a new empty set.

- `set<T>(set<T>)` \- Creates a copy of the given set (a set of a subtype is also acceptable).

- `set<T>(list<T>)` \- Creates a copy of the given list (with duplicates removed).


### Functions [â€‹](\#functions-1 "Direct link to Functions")

| Function | Description |
| --- | --- |
| `.add(T): boolean` | If the element isn't in the set, adds it and returns `true`. |
| `.add_all(list<T>): boolean` | Adds all elements from the given list to the set. Returns `true` if at least one element was added. |
| `.add_all(set<T>): boolean` | Adds all elements from the given set to the set. Returns `true` if at least one element was added. |
| `.clear()` | Removes all elements from the set. |
| `.contains(T): boolean` | Checks if the set contains the specified element. |
| `.contains_all(list<T>): boolean` | Checks if the set contains all elements from the given list. |
| `.contains_all(set<T>): boolean` | Checks if the set contains all elements from the given set. |
| `.empty(): boolean` | Returns true if the set is empty, otherwise returns false. |
| `.remove(T): boolean` | Removes the specified element from the set. Returns `true` if the element was found and removed. |
| `.remove_all(list<T>): boolean` | Removes all elements from the set that are present in the given list. Returns `true` if at least one element was removed. |
| `.remove_all(set<T>): boolean` | Removes all elements from the set that are present in the given set. Returns `true` if at least one element was removed. |
| `.size(): integer` | Returns the number of elements in the set. |
| `.sorted(): list<T>` | Returns a sorted copy of the set as a list. |
| `.to_text(): text` | Returns a text representation of the set, e.g., `'[1, 2, 3, 4, 5]'`. |

### Special operators [â€‹](\#special-operators-1 "Direct link to Special operators")

- `in` \- Checks if a specified value exists in the set, returning `true` if it does.

#### Example: [â€‹](\#example-1 "Direct link to Example:")

```codeBlockLines_e6Vv
struct Address {
    value: text;
}

function example_set() {
     // Creating a set of unique addresses
    val uniqueAddresses = set<Address>();

    // Adding addresses to the set
    uniqueAddresses.add(Address("0xabc123"));
    uniqueAddresses.add(Address("0xdef456"));
    uniqueAddresses.add(Address("0xabc123")); // This won't be added as it's a duplicate

    // Using 'in' operator to check if an address exists in the set
    if (Address("0xabc123") in uniqueAddresses) {  // 'in' operator
        print("Address 0xabc123 is in the set");
    }

    // Additional examples using the 'in' operator
    val addressesToCheck = [\
        Address("0xabc123"),\
        Address("0xdef456"),\
        Address("0xghi789"),\
        Address("0xjkl012")\
    ];

    for (addr in addressesToCheck) {
        if (addr in uniqueAddresses) {  // 'in' operator
            print("Address ${addr.value} is in the set");
        } else {
            print("Address ${addr.value} is not in the set");
        }
    }

    // Removing an address from the set
    uniqueAddresses.remove(Address("0xabc123"));

    // Adding multiple addresses at once
    val newAddresses = [Address("0xghi789"), Address("0xjkl012")];
    uniqueAddresses.add_all(newAddresses);

    // Printing the set
    print("Unique addresses: ${uniqueAddresses.to_text()}");
}

```

## `map<K,V>` [â€‹](\#mapkv "Direct link to mapkv")

A key-value pair collection type.

```codeBlockLines_e6Vv
struct Balance {
    amount: integer;
    lastUpdated: timestamp;
}

function example_map() {
    // Creating a map of blockchain addresses and their balances
    val balances = map<text, Balance>();

    // Adding balances to the map
    balances["0xabc123"] = Balance(amount = 1000, lastUpdated = 1723472827);
    balances["0xdef456"] = Balance(amount = 2000, lastUpdated = 1723472900);

    // Accessing a balance by address
    val aliceBalance = balances["0xabc123"];
    print("Alice's balance: ${aliceBalance.amount}, Last updated: ${aliceBalance.lastUpdated}");
}

```

### Constructors [â€‹](\#constructors-2 "Direct link to Constructors")

- `map<K,V>()` \- Creates a new empty map.
- `map<K,V>(iterable<(K,V)>)` \- Creates a new map from list, set, or map key-value pairs.

### Functions [â€‹](\#functions-2 "Direct link to Functions")

| Function | Description |
| --- | --- |
| `.clear()` | Removes all key-value pairs from the map. |
| `.contains(K): boolean` | Checks if the map contains the specified key. |
| `.empty(): boolean` | Returns true if the map is empty, otherwise returns false. |
| `.get(K): V` | Get the value associated with the specified key. |
| `.get_or_null(key: K): V?` | Returns null if the key isn't in the map; otherwise returns the associated value. |
| `.get_or_default(key: K, default_value: V2): V2` | Returns a default value if the key isn't in the map; otherwise returns the associated value. |
| `.remove_or_null(key: K): V?` | Removes the specified key from the map. Returns null if the key isn't in the map. |
| `.put(K, V)` | Adds/replaces a key-value pair in the map. |
| `.keys(): set<K>` | Returns a copy of keys in the map. |
| `.put_all(map<K, V>)` | Adds/replaces all key-value pairs from the given map to the map. |
| `.remove(K): V` | Removes the key-value pair associated with the specified key from the map. |
| `.size(): integer` | Returns the number of key-value pairs in the map. |
| `.to_text(): text` | Returns a text representation of the map, e.g., `'{x=123, y=456}'`. |
| `.values(): list<V>` | Returns a copy of values in the map. |

### Special operators [â€‹](\#special-operators-2 "Direct link to Special operators")

- `[]` \- Accesses or modifies a value by key.
- `in` \- Checks if a specified key exists in the map, returning `true` if it does.

#### Example: [â€‹](\#example-2 "Direct link to Example:")

```codeBlockLines_e6Vv
struct Balance {
    mutable amount: integer;
    lastUpdated: timestamp;
}

function example_map() {
    /// Creating a map of blockchain addresses and their balances
    val balances = map<text, Balance>();

    // Using [] operator to add and modify balances
    balances["0xabc123"] = Balance(amount = 1000, lastUpdated = 1723472827);
    balances["0xdef456"] = Balance(amount = 2000, lastUpdated = 1723472937);
    balances["0xghi789"] = Balance(amount = 3000, lastUpdated = 1723473427);

    // Using [] operator to access balances
    print("Alice's balance: ${balances[0xabc123].amount}");
    print("Bob's balance: ${balances[0xdef456].amount}");

    // Using [] operator to modify an existing balance
    balances["0xabc123"].amount += 500;
    print("Alice's updated balance: ${balances[0xabc123].amount}");

    // Using 'in' operator to check for key existence
    val addresses = ["0xabc123", "0xdef456", "0xjkl012", "0xmno345"];
    for (address in addresses) {
        if (address in balances) {
            print("Address ${address} exists in the map with balance: ${balances[address].amount}");
        } else {
            print("Address ${address} does not exist in the map");
        }
    }

    // Combining [] and 'in' operators for safe access
    val charlieAddress = "0xghi789";
    if (charlieAddress in balances) {
        val charlieBalance = balances[charlieAddress];
        print("Charlie's balance: ${charlieBalance.amount}, Last updated: ${charlieBalance.lastUpdated}");
    }

    // Using [] operator with get_or_default for safe access with a default value
    val davidAddress = "0xjkl012";
    val davidBalance = if (davidAddress in balances) balances[davidAddress] else Balance(0, block.timestamp);
    print("David's balance: ${davidBalance.amount}");

    // Printing updated balances
    for ((address, balance) in balances) {
        print("Address: ${address}, Updated Balance: ${balance.amount}");
    }
}

```

- [Properties of collection types](#properties-of-collection-types)
- [Mutable collection types](#mutable-collection-types)
- [Creating collections](#creating-collections)
- [`list<T>`](#listt)
  - [Constructors](#constructors)
  - [Functions](#functions)
  - [Special operators](#special-operators)
- [`set<T>`](#sett)
  - [Constructors](#constructors-1)
  - [Functions](#functions-1)
  - [Special operators](#special-operators-1)
- [`map<K,V>`](#mapkv)
  - [Constructors](#constructors-2)
  - [Functions](#functions-2)
  - [Special operators](#special-operators-2)- [@chromia/ft4](../index.html)
- [ft-session](../modules/ft_session.html)
- [createKeyStoreInteractor](ft_session.createKeyStoreInteractor.html)

# Function createKeyStoreInteractor

- createKeyStoreInteractor(client, keyStore): [KeyStoreInteractor](../types/ft_session.KeyStoreInteractor.html) [Permalink](#createKeyStoreInteractor)
- Creates a `KeyStoreInteractor` instance.





#### Parameters



- client: IClient


client that will be used to communicate with the blockchain

- keyStore: [KeyStore](../interfaces/authentication.KeyStore.html)


the keystore which this interactor will interact with


#### Returns [KeyStoreInteractor](../types/ft_session.KeyStoreInteractor.html)

### Settings

#### Member Visibility

- Protected
- Private
- Inherited

#### Theme

OSLightDark- [@chromia/ft4](../index.html)
- [authentication](../modules/authentication.html)
- [createEvmKeyHandler](authentication.createEvmKeyHandler.html)

# Function createEvmKeyHandler

- createEvmKeyHandler(authDescriptor, keyStore): [KeyHandler](../interfaces/authentication.KeyHandler.html) [Permalink](#createEvmKeyHandler)
- Creates a new instance of a `KeyHandler` which wraps an Evm key.





#### Parameters



- authDescriptor: [AnyAuthDescriptor](../types/accounts.AnyAuthDescriptor.html)


the associated auth descriptor

- keyStore: [EvmKeyStore](../interfaces/authentication.EvmKeyStore.html)


the keystore that holds the key


#### Returns [KeyHandler](../interfaces/authentication.KeyHandler.html)

### Settings

#### Member Visibility

- Protected
- Private
- Inherited

#### Theme

OSLightDark[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

## Language overview [â€‹](\#language-overview "Direct link to Language overview")

[Rell](/intro/terminology#rell) is a language for relational [blockchain](/intro/terminology#blockchain)
programming. It combines the following features:

1. Relational data modelling and queries similar to SQL. People familiar with SQL should feel at home once they learn
the new syntax.
2. Normal programming constructs: variables, loops, functions, collections, etc.
3. Constructs that specifically target app backends and, in particular, blockchain-style programming, including request
routing, authorization, etc.

Rell aims to make programming as ergonomic as possible. It minimizes boilerplate and repetition. At the same time, as a
A static type system can detect and prevent many kinds of defects.

## Blockchain programming [â€‹](\#blockchain-programming "Direct link to Blockchain programming")

There are many different styles of blockchain programming. In the context of Rell, we see blockchain as a method for
securely synchronizing databases on the system nodes. Thus, Rell is very database-centric.

Programming in Rell is identical to programming app backends: you need to handle requests to modify the data in the
database and other requests to retrieve data from a database. Handling these two types of requests is all that a backend
does. But, of course, before you implement request handlers, you need to describe your data model first.

## Entity definitions [â€‹](\#entity-definitions "Direct link to Entity definitions")

You usually define your data model using SQL's `CREATE TABLE` syntax. In Java, you can define data objects using `class`
definition.

In Rell, we define them as `entity`. An entity is similar to a table in relational databases. So, let's create our
`Book` entity. We will first add the Rell code needed to establish the entity and then delve into the specifics.

Rell uses persistent objects. Thus, entity definition automatically creates the storage (e.g. a table) necessary to
persist objects of an entity. As you might expect, Rellâ€™s entity definition includes a list of attributes:

```codeBlockLines_e6Vv
entity book {
    key isbn: text;
    title: text;
    author: text;
}

```

- The `entity` keyword initiates the definition of our entity, similar to creating a table in a database.

- Attributes, like columns in a database table, each hold specific data types related to the book.

- `key isbn: text` this is our unique index for each book, and is defined in Rell as the key for the entity. Each book
possesses a distinct ISBN, and the `key` keyword underscores this uniqueness. `text` designates that the ISBN is
stored as textual data.

- `title: text` and `author: text` are self-explanatory attributes containing textual information about the book's title
and author, respectively.


**Examples**:

| Action | Entity | Description |
| --- | --- | --- |
| Define basic entity | `entity user { pubkey; name; }` | Create an entity `user` with attributes `pubkey` and `name`. |
| Add unique identifier (key) | `entity user { key name; }` | Define a unique key based on the `name` attribute for the `user` entity. |
| Create an index for efficient retrieval | `entity user { key name; index pubkey; }` | Add an index for the `pubkey` attribute to enable fast retrieval in the `user` entity. |
| Ensure uniqueness with multiple keys | `entity user { key name; key pubkey; }` | Define both `name` and `pubkey` as keys to ensure uniqueness within the `user` entity. |
| Establish one-to-many relationship | `entity channel { index owner: user; key name; }` | Create an entity `channel` with an index on `owner` and a key based on `name`. |
| Create a composite key for contextual uniqueness | `entity channel { key owner: user, name; }` | Define a composite key ( `owner` and `name`) for ensuring uniqueness within a user's context. |
| Make user reference unique per channel table | `entity channel { key owner: user; key name; }` | Use separate keys ( `owner` and `name`) to enforce unique references in the `channel` entity. |

## Managing data requests [â€‹](\#managing-data-requests "Direct link to Managing data requests")

In Rell, we handle requests through two types of actions:

1. **Data-modifying requests (Operations):** These operations modify the database state.
2. **Data-retrieving requests (Queries):** These are requests for retrieving data.

But we will need to refer to things in the database for both types of requests, so letâ€™s consider relational operators
first.

### Relational operator basics [â€‹](\#relational-operator-basics "Direct link to Relational operator basics")

First, letâ€™s look at how we create objects:

```codeBlockLines_e6Vv
create user (pubkey=x"0373599a61cc6b3bc02a78c34313e1737ae9cfd56b9bb24360b437d469efdf3b15", name="Alice");

```

This is essentially the same as SQL's `INSERT` operation, but the syntax is slightly different. Rell is smart enough to
identify the connection between arguments and attributes based on their type. `x"..."` notation is a hexadecimal
`byte_array` literal compatible with the `pubkey` type. On the other hand, the name is provided via `text` literal.
Thus, we can write:

```codeBlockLines_e6Vv
create user("Alice", x"0373599a61cc6b3bc02a78c34313e1737ae9cfd56b9bb24360b437d469efdf3b15");

```

The order of arguments does not matter here; they are matched with attributes based on type.

How do we find that object now?

```codeBlockLines_e6Vv
val alice = user @ { .name == "Alice" };

```

The `@` operator retrieves a single record (or an object in this case), satisfying the search criteria you provided. If
no such record exists or more than one exists, it raises an error. Itâ€™s recommended to use this construct when an
operation needs a single record to operate on. If this requirement is violated, the operation will be aborted, and all
its effects will be rolled back. Thus, it is a concise and effective way to deal with requirements.

( `val` defines a read-only variable, which can later be used in an expression. A variable defined using `var` can be
reassigned later.)

You can use the `@*` operator to retrieve a list of users. For example:

```codeBlockLines_e6Vv
val all_users = user @* { };

```

This returns a list of all users (since no filter expression was provided, all users match it). Value declarations can
include a type, for example; we can specify that `all_users` is of type `list<user>` like this:

```codeBlockLines_e6Vv
val all_users: list<user> = user @* { };

```

Since the Rell compiler knows the type of every expression, it does not need a type declaration. However, if one is
provided, it will check against it. Type declarations are mostly valid as documentation for programmers reading the code
and should be omitted in cases where there is no ambiguity.

`@` and `@*` correspond to `SELECT` in SQL.

### Operations [â€‹](\#operations "Direct link to Operations")

An operation in Rell is similar to the functionality of API endpoints using `POST`, `UPDATE`, and `DELETE` methods.
These operations allow you to make changes to the database, including adding new data, updating existing records, and
deleting entries. Unlike queries, which only allow data retrieval (similar to the `GET` method in APIs), operations
enable modifications to the database.

This capability is crucial for maintaining and updating data, ensuring that the database reflects the most current
information. For instance, adding a new book entity, updating an existing bookâ€™s details, or removing a book from the
database would be performed through Rell operations, akin to how these actions are executed in APIs.

Let's create a `create_book` operation, which enables us to store book entries by committing transactions to the
blockchain.

In Rell, operations serve as functions that can be included in a transaction.

Let's define the operation for creating a new book:

```codeBlockLines_e6Vv
operation create_book(isbn: text, title: text, author: text) {
  create book(isbn = isbn, title = title, author = author);
}

```

Letâ€™s go through this line by line. First, we declare the operation name and a list of parameters:

```codeBlockLines_e6Vv
operation create_book(isbn: text, title: text, author: text)

```

This is very similar to function definitions in other languages. An operation is a function of a particular kind: it can
be invoked using a blockchain transaction by its name.

Whenever you encounter the `operation` keyword, think of it as a function where the function body contains logic to
change the dapp table state. A transaction can contain one or many operations and the logic of each operation will alter
the dapp table state.

```codeBlockLines_e6Vv
operation create_book(isbn: text, title: text, author: text)

```

Our operation `create_book` is designed to accept three parameters: an ISBN, a title, and an author for the book. Inside
the operation, we have the `create` command with parameters from the operation.

### Queries [â€‹](\#queries "Direct link to Queries")

A query in Rell is similar to performing a `SELECT` operation in a SQL database and can be thought of as analogous to an
API endpoint using the `GET` method. Queries in Rell allow you to retrieve specific data from the database, just as a
`SELECT` operation would in SQL.

Letâ€™s consider a simple example: retrieving a collection of book entities. This Rell query would be used to select all
books from a database, much like how you would use a SQL query to select rows from a table. This approach enables
efficient data access and manipulation, similar to how API endpoints allow data retrieval in web applications.

```codeBlockLines_e6Vv
query get_all_books() {
    return book @* { } (
        .isbn,
        .title,
        .author
    );
}

```

This query employs the `@*` operand in `book @*` to retrieve a collection of book entities. `@*` means that we expect 0
or more objects of this type from the query. The curly braces at the end, as seen in `book @* {}`, is where we would
specify our filter criteria for the query. We'll keep it simple and talk more about the filter criteria in later
lessons.

The subsequent segment of the query defines which attributes we wish to retrieve. It's analogous to specifying columns
in a `SELECT` statement.

In this case, we intend to retrieve:

- `.isbn`
- `.title`
- `.author`

Combining these components, we formulate a query that retrieves all books in a collection, with each item containing the
attributes `isbn`, `title`, and `author`.

### Functions [â€‹](\#functions "Direct link to Functions")

Sometimes, multiple operations (or queries) need the same piece functionality, e.g., a validation code or code which
retrieves objects in a particular way. To avoid repeating yourself, you can use `function`. Functions work similarly to
operations: they get some input, perform validations, and work with data. They also have a return type that can be
specified after the list of parameters.

**Example**:

```codeBlockLines_e6Vv
function create_book(title: text, library_name: text, shelf_number: integer) {
    val library = get_library_by_name(library_name);
    val shelf = get_shelf_by_number(library, shelf_number);
    create book ( title, shelf );
}

```

The function `create_book` created a new book entity within a specific library and shelf.

- The function calls `get_library_by_name` with the `library_name` parameter to retrieve the library object.
- Using the previously retrieved `library` object, the function calls `get_shelf_by_number` with `library` and
`shelf_number` as arguments to get the specific shelf within that library.
- The `create` statement is used to create a new book entity with the given `title`, and it associates this book with
the `shelf` identified in the previous step.

## Relational expressions [â€‹](\#relational-expressions "Direct link to Relational expressions")

In general, a relational expression consists of five parts, some of which can be omitted:

```codeBlockLines_e6Vv
FROM        CARDINALITY  WHERE         WHAT  TAIL
entity_name @            { condition } ()    ;

```

1. FROM: represents the table from where to make the query. Same as SQL FROM.

2. [CARDINALITY](/rell/language-features/database/overview#cardinality) : specifies the number of results that are
expected from the query. The query will fail if this condition can't be matched.
   - @ exactly one result
   - @? zero or one result
   - @\+ more than one result
   - @\\* zero or many results
3. WHERE: represents a filter similar to the WHERE part of an SQL query.

4. WHAT: The actual values to retrieve from the query. It can be one or several attributes or left empty to get a
reference (rowid) of the entity. Here, you can also
[sort, group, or omit fields](/rell/language-features/database/overview#what-part).

5. TAIL: Additional SQL-related statements such as `limit` or `offset` that can be used when retrieving multiple
results.


In SQL, the logical processing order does not match the order in which clauses are written. For example, `FROM` is
logically processed before `SELECT` even though `SELECT` comes first. (SQL logical processing order can be found, e.g.
in [SQL Server documentation](https://stackoverflow.com/questions/4596467/order-of-execution-of-the-sql-query)).

The order of components of a relational expression in Rell matches the logical processing order. So, first, a set is
defined, then it is filtered, and then it is post-processed. Of course, the query planner can perform operations in a
different order, but that shouldnâ€™t affect the results. Thus, a relational expression can be understood as a pipeline.

Letâ€™s see an example. In this example, there is a message entity from where we'll search the messages of a specific
user.

```codeBlockLines_e6Vv
entity message {
    index channel;
    index timestamp;
    text;
}

```

We can retrieve all messages of a given user:

```codeBlockLines_e6Vv
(channel, message) @* {
    channel.owner == given_user,
    message.channel == channel
}(message.text);

```

So, we joined the `channel` with the `message`. We can shorten the expression using entity aliases:

```codeBlockLines_e6Vv
(c: channel, m: message) @* {
    c.owner == given_user,
    m.channel == c
}(m.text, m.timestamp);

```

We can easily read this expression from left to right:

- consider all pairs `(c, m)` where `c` is `channel` and `m` is `message`
- find those where `c.owner` equals `given_user` and `m.channel` equals `c`
- extract `text` and `timestamp` from `m`

The result of this expression is a list of tuples with `text` and `timestamp` attributes.

The above expression can be easily modified to retrieve the latest 25 messages:

```codeBlockLines_e6Vv
(c: channel, m: message) @* {
    c.owner == given_user,
    m.channel == c
}(m.text, -sort m.timestamp) limit 25;

```

Here, we sorted results by timestamp in a descending order using `-sort` (minus prefix means descending) and limited the
number of returned rows.

## Keys and indexes [â€‹](\#keys-and-indexes "Direct link to Keys and indexes")

Indexes are crucial in improving database performance by allowing faster data retrieval. To understand the significance
of indexes in Rell, let's start with the basics.

Imagine that you have a large dataset and need to find a specific entry within it. Without an index, searching through
all the data can be time-consuming with a worst-case time complexity of _O(n)_. However, when an attribute is indexed in
Rell, it dramatically enhances query performance, reducing the time complexity to _O(log(n))_, thanks to PostgreSQL's
underlying binary tree structure.

In Rell, you have two options to mark an attribute for indexing: `key` and `index`. While both improve query
performance, they serve different purposes:

### Key [â€‹](\#key "Direct link to Key")

A `key` is an index that enforces a unique constraint on the indexed attribute. This uniqueness constraint guarantees
that entities with the same attribute value will not exist in your database, making it less error-prone when creating
entries.

### Index [â€‹](\#index "Direct link to Index")

An `index` is used to improve query performance for non-unique attributes.

note

Note that both keys and indexes introduce extra time in _creating_ entities, so be sure to mark your attributes
cautiously.

### Key and index example [â€‹](\#key-and-index-example "Direct link to Key and index example")

Consider the scenario where multiple houses share the same street, each with its unique id. This could be modelled like:

```codeBlockLines_e6Vv
entity house {
    key id: integer;
    index street: text;
}

```

Now, the following queries would be high performant:

```codeBlockLines_e6Vv
val unique_house = house @ {
    .id == 10
};

val houses_on_main_street = house @* {
    .street == "main street"
};

```

### Composite index [â€‹](\#composite-index "Direct link to Composite index")

To further optimize your database queries, you can add a composite index. This is particularly useful when finding
entries based on a combination of attributes. For instance, if your app often queries all houses owned by a specific
owner on a particular street, you can create a multi-column inde

```codeBlockLines_e6Vv
index owner, street;

```

The order of the fields in a multi-column index is crucial for performance. This is how composite indexes work in SQL,
where each column precedes the latter. To create the most efficient index, place the most significant attribute first.
For instance, if you want to query all houses with exactly four rooms and a floor area greater than 100:

```codeBlockLines_e6Vv
house@ { .number_of_rooms == 4, .floor_area > 100 };

```

In this case, an optimal index configuration would be:

```codeBlockLines_e6Vv
index number_of_rooms, floor_area;

```

Composite keys work the same way. If a specific combination of entries can only exist once, adding a composite key will
ensure this constraint in the database. Place the attribute yielding the fewest results first to achieve optimal
performance.

**Example**:

This example is focused on creating the `house` records and requesting specific `house` records.

Add the `house` entity:

```codeBlockLines_e6Vv
entity house {
    index street;
    number: integer;
    key street, number;
    number_of_rooms: integer;
    number_of_floors: integer;
    floor_area: integer;
    index number_of_rooms, floor_area;
}

```

Let's query the newly created `house` records:

```codeBlockLines_e6Vv
query get_specific_houses(
    number_of_rooms: integer,
    floor_area: integer
) = house @* { .number_of_rooms == number_of_rooms, .floor_area >= floor_area } ( $.to_struct() );

```

The result of the query above is as follows:

result

```codeBlockLines_e6Vv
[\
  [\
    "floor_area": 200,\
    "number": 30,\
    "number_of_floors": 1,\
    "number_of_rooms": 4,\
    "street": 1\
  ],\
  [\
    "floor_area": 109,\
    "number": 32,\
    "number_of_floors": 1,\
    "number_of_rooms": 4,\
    "street": 1\
  ]\
]

```

note

While common with SQL databases, this approach is vital in resource-constrained decentralized systems like Rell. As a
developer, it would be best to comprehend query behavior and index utilization for optimal results.

- [Language overview](#language-overview)
- [Blockchain programming](#blockchain-programming)
- [Entity definitions](#entity-definitions)
- [Managing data requests](#managing-data-requests)
  - [Relational operator basics](#relational-operator-basics)
  - [Operations](#operations)
  - [Queries](#queries)
  - [Functions](#functions)
- [Relational expressions](#relational-expressions)
- [Keys and indexes](#keys-and-indexes)
  - [Key](#key)
  - [Index](#index)
  - [Key and index example](#key-and-index-example)
  - [Composite index](#composite-index)[Skip to main content](#__docusaurus_skipToContent_fallback)

[**ğŸ”—FT4 Rell Library API**](/pages/ft4-rell/index.html)[**ğŸ”—FT4 TypeScript Client API**](/pages/ft4-ts-client/client/index.html)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

This topic outlines how to deploy a Filechain, which serves as a storage solution for managing and storing file chunks
in the Chromia Filehub ecosystem.

## Prerequisites [â€‹](\#prerequisites "Direct link to Prerequisites")

Before you begin, make sure you have access to the following tools and resources:

- [Chromia CLI](/intro/installation/cli-installation)
- Git
- Docker

## Step 1: Create a Container [â€‹](\#step-1-create-a-container "Direct link to Step 1: Create a Container")

Start by [creating a container](/intro/deployment/mainnet/get-container) for your Filechain instance.

## Step 2: Prepare `chromia.yml` [â€‹](\#step-2-prepare-chromiayml "Direct link to step-2-prepare-chromiayml")

Next, configure your `chromia.yml` file with the required settings, making sure to include the `trusted_filehub_brid`
field with the blockchain RID from your Filehub deployment.

## Step 3: Deploy the Filechain Blockchain [â€‹](\#step-3-deploy-the-filechain-blockchain "Direct link to Step 3: Deploy the Filechain Blockchain")

Follow the [blockchain deployment guide](/intro/deployment/mainnet/deploy-dapp) to deploy the Filechain blockchain.
This blockchain will be responsible for storing file chunks and validating transactions for files uploaded through
Filehub.

For additional storage capacity, repeat these steps for each Filechain you plan to deploy.

- [Prerequisites](#prerequisites)
- [Step 1: Create a Container](#step-1-create-a-container)
- [Step 2: Prepare `chromia.yml`](#step-2-prepare-chromiayml)
- [Step 3: Deploy the Filechain Blockchain](#step-3-deploy-the-filechain-blockchain)[Skip to main content](#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In Rell, there are several simple data types to represent different kinds of data. They're not composed of other data
types and serve as the building blocks for more complex data structures.

### Boolean [â€‹](\#boolean "Direct link to Boolean")

A simple data type that represents two values: `true` and `false`. Booleans are often used for logical operations and
decision-making.

```codeBlockLines_e6Vv
val using_rell = true;
function foo() {
  if (using_rell) print("Awesome!");
}

```

### Integer [â€‹](\#integer "Direct link to Integer")

A data type for representing whole numbers without fractional parts. Integers are typically used for counting, indexing,
and mathematical operations.

```codeBlockLines_e6Vv
val user_age: integer = 26;

```

| Field | Description |
| --- | --- |
| `integer.MIN_VALUE` | Minimum value (-2^63) |
| `integer.MAX_VALUE` | Maximum value (2^63-1) |
| `integer(s: text, radix: integer = 10)` | Parse a signed string representation of an integer, fails if invalid |
| `integer(decimal)` | Converts a decimal to an integer, rounding towards 0 (5.99 becomes 5, -5.99 becomes -5), throws an exception if the resulting value is out of range |
| `integer.from_text(s: text, radix: integer = 10)` | Same as `integer(text, integer)` |
| `integer.from_hex(text)` | Parse an unsigned HEX representation |
| `.abs()` | Absolute value |
| `.max(integer)` | Maximum of two values |
| `.max(decimal)` | Maximum of two values (converts this integer to decimal) |
| `.min(integer)` | Minimum of two values |
| `.min(decimal)` | Minimum of two values (converts this integer to decimal) |
| `.to_text(radix: integer = 10)` | Convert to a signed string representation |
| `.to_hex()` | Convert to an unsigned HEX representation |
| `.sign()` | Returns -1, 0, or 1 depending on the sign |

### big\_integer [â€‹](\#big_integer "Direct link to big_integer")

A data type that represents large integers with high precision, capable of handling very large numbers.

```codeBlockLines_e6Vv
val bi: big_integer = 9223372036854775832L;

```

> You must add `L` to the value to specify that the value must be interpreted and treated as a `big_integer`.

Internally, the type `java.lang.BigInteger` gets used in the interpreter, and `NUMERIC` in SQL.

| Field | Description |
| --- | --- |
| `big_integer.PRECISION` | The maximum number of digits (131072) |
| `big_integer.MIN_VALUE` | Minimum value ( `-(10^131072)+1`) |
| `big_integer.MAX_VALUE` | Maximum value ( `(10^131072)-1`) |
| `big_integer(integer)` | Creates a `big_integer` from `integer` |
| `big_integer(text)` | Creates a `big_integer` from a `decimal` string representation, possibly with a sign. It fails if the string is not valid. |
| `big_integer.to_integer()` | Converts `big_integer` to `integer`. Fails if the value is out of range. |
| `integer.to_big_integer()` | Converts `integer` to `big_integer` |
| `big_integer.to_decimal()` | Converts `big_integer` to `decimal` |
| `decimal.to_big_integer()` | Converts `decimal` to `big_integer`. Truncates the fractional part. |
| `big_integer.to_bytes()` | Converts a signed (positive or negative) `big_integer` to a `byte_array`. |
| `big_integer.from_bytes(byte_array)` | Converts a `byte_array` produced by `.to_bytes()` back to `big_integer`. |
| `big_integer.to_bytes_unsigned()` | Converts a positive `big_integer` to a `byte_array`. Fails if a negative value is provided. |
| `big_integer.from_bytes_unsigned(byte_array)` | Converts a `byte_array` produced by `.to_bytes_unsigned()` back to `big_integer`. |
| `.abs()` | Absolute value of the `big_integer` |
| `.max(big_integer)` | Maximum of two values |
| `.max(decimal)` | Maximum of two values (converts this `big_integer` to `decimal`) |
| `.min(big_integer)` | Minimum of two values |
| `.min(decimal)` | Minimum of two values (converts this `big_integer` to `decimal`) |
| `.to_text()` | Converts to a decimal string representation. |
| `.from_text(text)` | Converts from a decimal string representation. |
| `.to_text(radix: integer)` | Converts to a string representation with a specific base (radix, from 2 to 36) |
| `.from_text(text, radix: integer)` | Converts from a string representation with a specific base (radix, from 2 to 36) |
| `.to_hex()` | Convert to an unsigned HEX representation. Supports positive and negative numbers. |
| `.from_hex(text)` | Parse an unsigned HEX representation. Supports positive and negative numbers. |
| `.sign()` | Returns `-1`, `0`, or `1` depending on the sign. |

### Decimal [â€‹](\#decimal "Direct link to Decimal")

A data type for representing real numbers with high precision.

```codeBlockLines_e6Vv
val approx_pi: decimal = 3.14159;
val scientific_value: decimal = 55.77e-5;

```

It's not a normal floating-point type found in many other languages (like `float` and `double` in C/C++/Java):

- `decimal` type is accurate when working with numbers within its range. All decimal numbers (results of decimal
operations) are implicitly rounded to 20 decimal places. For instance, `decimal('1E-20')` returns a non-zero, while
`decimal('1E-21')` returns a zero value.

- Numbers get stored in a decimal form, not binary form, so conversions to and from a string are lossless (except when
rounding occurs if there are more than 20 digits after the point).

- Floating-point types allow storing much smaller numbers, like `1E-300`; `decimal` can only store `1E-20`, but not a
smaller nonzero number.

- Operations on decimal numbers may be considerably slower than integer operations (at least ten times slower for the
same integer numbers).

- Large decimal numbers may require a lot of space: ~0.41 bytes per decimal digit (~54KiB for 1E+131071) in memory and
~0.5 bytes per digit in a database.

- Internally, the type `java.lang.BigDecimal` gets used in the interpreter, and `NUMERIC` in SQL.

- In the code, one can use decimal literals:





```codeBlockLines_e6Vv
123.456
0.123
.456
33E+10
55.77e-5

```


Such numbers have a `decimal` type. Simple numbers without a decimal point and exponent, like 12345, have `integer`
type.

| Field | Description |
| --- | --- |
| `decimal.PRECISION` | The maximum number of decimal digits (131072 + 20) |
| `decimal.SCALE` | The maximum number of decimal digits after the decimal point (20) |
| `decimal.INT_DIGITS` | The maximum number of digits before the decimal point (131072) |
| `decimal.MIN_VALUE` | The smallest nonzero absolute value that a `decimal` can store |
| `decimal.MAX_VALUE` | The largest value that you can store in a `decimal` (1E+131072 - 1) |
| `decimal(integer)` | Converts an `integer` to `decimal` |
| `decimal(big_integer)` | Converts a `big_integer` to `decimal` |
| `decimal(text)` | Converts a text representation of a number to `decimal` |
| `.abs()` | Absolute value |
| `.ceil()` | Ceiling value: rounds 1.0 to 1.0, 1.00001 to 2.0, -1.99999 to -1.0, etc. |
| `.floor()` | Floor value: rounds 1.0 to 1.0, 1.9999 to 1.0, -1.0001 to -2.0, etc. |
| `.min(decimal)` | Minimum of two values |
| `.max(decimal)` | Maximum of two values |
| `.round(scale: integer = 0)` | Rounds to a specific number of decimal places to a closer value. |
| `.sign()` | Returns `-1`, `0`, or `1` depending on the sign |
| `.to_integer()` | Converts a decimal to an integer, rounding towards 0. |
| `.to_text(scientific: boolean = false)` | Convert to string |

note

In Rell, the equality comparison for decimal numbers (using the == and != operators) considers two decimal values equal
if they represent the same numerical value, regardless of their specific representation or format.

**Example:** `1.0E+2` is considered equal to `10.0E+1` , thus, `1.0E+2 == 10.0E+1` returns `true`.

### Text [â€‹](\#text "Direct link to Text")

A data type for representing textual information, such as strings of characters. Text data types allow for text
manipulation and processing. Same as `string` type in some other languages.

```codeBlockLines_e6Vv
val placeholder = "Lorem ipsum donor sit amet";
function foo() {
  print(placeholder.size()); // 26
  print(placeholder.empty()); // false
}

```

| Field | Description |
| --- | --- |
| `text.from_bytes(byte_array, ignore_invalid: boolean = false)` | If `ignore_invalid` is `false`, throws an exception when the byte array is not a valid UTF-8 encoded string, otherwise replaces invalid characters with a placeholder. |
| `.empty()` | Returns true if the `text` is empty, otherwise returns false |
| `.size()` | Returns the number of characters. |
| `.compare_to(text)` | Returns 0 if texts match, otherwise a positive or negative value |
| `.starts_with(text)` | Returns true if it starts with the input text, otherwise returns false |
| `.ends_with(text)` | Returns true if it ends with the input text, otherwise returns false |
| `.contains(text)` | Return true if contains the given substring, otherwise returns false |
| `.index_of(text)` | Returns position of input text and -1 if a substring isn't found |
| `.index_of(text, integer)` | Same as `.index_of(text)` but starting search from the given position |
| `.last_index_of(text[, start: integer])` | Returns `-1` if a substring isn't found |
| `.sub(start: integer[, end: integer])` | Get a substring (start-inclusive, end-exclusive) |
| `.repeat(n: integer)` | Returns the text repeated "n" times |
| `.replace(old: text, new: text)` | Replaces a substring with new text |
| `.reversed()` | Returns a reversed copy of the text |
| `.upper_case()` | Returns a new text with all characters converted to uppercase |
| `.lower_case()` | Returns a new text with all characters converted to lowercase |
| `.split(text)` | Strictly split by a separator (not a regular expression) |
| `.trim()` | Remove leading and trailing whitespace |
| `.matches(text)` | Returns true if it matches a regular expression |
| `.to_bytes()` | Convert to a UTF-8 encoded byte array |
| `.char_at(integer)` | Get a 16-bit code of a character |
| `.format(...)` | Formats a string. For example, `'My name is <%s>'.format('Bob')` \- returns `'My name is <Bob>'` |

Here are the options available for the `text.format()` function in Rell:

| Format specifier | Data type | Output description |
| --- | --- | --- |
| `%b` | general | Formats `boolean` values as "true" or "false". `null` is also formatted as "false". |
| `%h` | general | Format an object's hash code as a hexadecimal string. |
| `%s` | general | Represents a placeholder for string arguments. |
| `%c` | character | Produces a `Unicode` character as the result. |
| `%d` | integer | Formats an `integer` as a `decimal` number. |
| `%o` | integer | Formats an `integer` as an `octal` number. |
| `%x` | integer | Formats an `integer` as a `hexadecimal` number (lowercase or uppercase). |
| %n | line separator | Inserts the platform-specific line separator. |

You can use most of these text functions within at-expressions where they're translated to their SQL equivalents.

Special operators:

- `+`: concatenation
- `[]`: character access (returns single-character `text`)

### byte\_array [â€‹](\#byte_array "Direct link to byte_array")

Byte arrays are used to handle binary data, such as hexadecimal or Base64 representations. You can create byte arrays
from text or lists of integers, convert them to different representations, and perform operations like concatenation and
element access.

```codeBlockLines_e6Vv
val user_pubkey: byte_array = x"0373599a61cc6b3bc02a78c34313e1737ae9cfd56b9bb24360b437d469efdf3b15";
function foo() {
  print(user_pubkey.to_base64()); //A3NZmmHMazvAKnjDQxPhc3rpz9Vrm7JDYLQ31Gnv3zsV
}

```

| Field | Description |
| --- | --- |
| `byte_array(text)` | Creates a `byte_array` from a HEX string, for example, `'1234abcd'` |
| `byte_array.from_hex(text): byte_array` | Same as `byte_array(text)` |
| `byte_array.from_base64(text): byte_array` | Creates a `byte_array` from a Base64 string |
| `byte_array.from_list(list<integer>): byte_array` | Converts list to a byte array; values must be 0 - 255 |
| `.empty()` | Returns true if the `byte_array` is empty, otherwise returns false |
| `.repeat(n: integer): byte_array` | Returns the byte array repeated "n" times |
| `.reversed()` | Returns a reversed copy of the byte array |
| `.size()` | Returns the number of bytes in the byte array |
| `.sub(start: integer[, end: integer]): byte_array` | Sub-array (start-inclusive, end-exclusive) |
| `.to_hex()` | Returns a HEX representation of the byte array, for example, `'1234abcd'` |
| `.to_base64()` | Returns a `Base64` representation of the byte array |
| `.to_list()` | Returns a list of values 0 - 255 |
| `.sha256()` | Returns the SHA256 digest as a `byte_array` |

You can use most of these byte array functions within at-expressions, where they're translated to their SQL equivalents.

Special operators:

- `+`: concatenation
- `[]`: element access

### ROWID [â€‹](\#rowid "Direct link to ROWID")

The primary key of a database record, a 64-bit integer, supports only comparison operations.

When an entity row is inserted into the database using the `create` expression, it gets a new unique `rowid` value from
the same sequence which is greater than the last allocated `rowid` in the same blockchain. Deleting an entity row
doesn't affect rowids generation. For example, let's assume we have 2 entities a and b:

```codeBlockLines_e6Vv
create a () // rowid = N0
create b () // rowid N1, N1 > N0
create a () // rowid N2, N2 > N1
delete a { .rowid == N2 }
create b () // rowid N3, N3 > N2

```

`rowid` supports only comparison operations.

| Field | Description |
| --- | --- |
| `rowid(integer): rowid` | Converts an `integer` to `rowid`. The value must not be negative. |
| `rowid.to_integer(): integer` | Returns the integer value of the rowid. |

### JSON [â€‹](\#json "Direct link to JSON")

Stored in PostgreSQL as `JSON` type and gets parsed to `text`;

```codeBlockLines_e6Vv
val json_text = '{ "name": "Alice" }';
val json_value: json = json(json_text);
function foo() {
  print(json_value);
}

```

| Field | Description |
| --- | --- |
| `json(text)` | Create a `json` value from a string; fails if not a valid JSON string |
| `.to_text()` | Convert the `json` value to a string |

### Unit [â€‹](\#unit "Direct link to Unit")

No value; can't use it explicitly. Equivalent to `[unit]{.title-ref}` type in the Kotlin programming language.

### Null [â€‹](\#null "Direct link to Null")

Type of `null` expression; can't use it explicitly.

### Simple type aliases [â€‹](\#simple-type-aliases "Direct link to Simple type aliases")

- `pubkey` = `byte_array`
- `name` = `text`
- `timestamp` = `integer`
- `tuid` = `text`

- [Boolean](#boolean)
- [Integer](#integer)
- [big\_integer](#big_integer)
- [Decimal](#decimal)
- [Text](#text)
- [byte\_array](#byte_array)
- [ROWID](#rowid)
- [JSON](#json)
- [Unit](#unit)
- [Null](#null)
- [Simple type aliases](#simple-type-aliases)[Skip to main content](#__docusaurus_skipToContent_fallback)

FT4 provides a comprehensive set of tools for managing decentralized applications, with features for flexible account
management, secure authentication, asset handling, and cross-chain operations. It enables efficient data retrieval
through pagination, ensuring high performance and scalability in decentralized systems. These capabilities allow
developers to integrate and manage accounts, assets, and transactions across multiple blockchains in a secure and
efficient manner.

[FT4 allows flexible account registration strategies like open, fee, or subscription. Accounts can be linked for\\
various purposes, including staking, asset locking, and auctions. Additionally, multiple auth descriptors can be\\
associated with accounts, with one main descriptor managing access. This ensures secure and dynamic account\\
management.](/ft4/accounts) [FT4 provides a robust authentication system using auth descriptors, which define key pairs, permissions, and\\
multi-signature rules. Custom authentication handlers and resolvers offer flexibility in user authorization, and\\
multi-signature transactions require multiple approvals, enhancing security for sensitive operations.](/ft4/authentication) [FT4 facilitates asset registration, ensuring each asset has a unique identity and can be securely tracked. It\\
manages asset balances with attributes like precision, supply, and issuing blockchain. Additionally, assets can be\\
securely locked in temporary accounts for scenarios such as staking or auctions, without transferring ownership.](/ft4/assets) [FT4 enables seamless asset transfers across blockchains within the Chromia network. Operations like init\_transfer,\\
apply\_transfer, and complete\_transfer ensure secure and efficient routing of assets across chains. The registration\\
and tracking of assets across blockchains ensures secure and consistent cross-chain operations.](/ft4/cross-chain)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

The FT4 client library provides flexible tools for creating **Single-Signature ( `SingleSig`)** and **Multi-Signature**
**( `MultiSig`)** auth descriptors, along with optional rules to customize the permissions.

This document explains the implementation details and demonstrates how to create and instantiate auth descriptors for
various use cases.

### **Auth descriptor structure** [â€‹](\#auth-descriptor-structure "Direct link to auth-descriptor-structure")

An auth descriptor is represented by the following TypeScript type:

#### **`AuthDescriptor<T>`** [â€‹](\#authdescriptort "Direct link to authdescriptort")

```codeBlockLines_e6Vv
export type AuthDescriptor<T extends SingleSig | MultiSig> = {
  id: Buffer; // Unique identifier
  accountId: Buffer; // Account to which this auth descriptor belongs
  authType: AuthType; // "S" for SingleSig, "M" for MultiSig
  rules: AuthDescriptorRules | null; // Optional rules for descriptor
  created: Date; // Creation timestamp
  args: T; // Signature details (SingleSig or MultiSig)
};

```

#### **Types of signatures** [â€‹](\#types-of-signatures "Direct link to types-of-signatures")

- **`SingleSig`:** Used for single-key authentication.





```codeBlockLines_e6Vv
export type SingleSig = {
    flags: string[]; // Permissions (e.g., "A", "T")
    signer: Buffer; // Public key for the single signer
};

```

- **`MultiSig`:** Used for multi-key authentication.





```codeBlockLines_e6Vv
export type MultiSig = {
    flags: string[]; // Permissions
    signaturesRequired: number; // Number of signatures required for operation
    signers: Buffer[]; // List of public keys
};

```


### **Creating auth descriptors** [â€‹](\#creating-auth-descriptors "Direct link to creating-auth-descriptors")

The FT4 library provides two primary functions for creating auth descriptors:

1. **`createSingleSigAuthDescriptorRegistration`**
2. **`createMultiSigAuthDescriptorRegistration`**

#### **Function: `createSingleSigAuthDescriptorRegistration`** [â€‹](\#function-createsinglesigauthdescriptorregistration "Direct link to function-createsinglesigauthdescriptorregistration")

Creates a SingleSig auth descriptor with the specified permissions, public key, and optional rules.

- **Parameters:**
  - `flags: string[]` \- List of permissions (e.g., `["A"]` for account edits, `["T"]` for transfers).
  - `pubKey: Buffer` \- Public key of the signer.
  - `rules?: AuthDescriptorRules` \- Optional rules for the descriptor.
- **Example:**





```codeBlockLines_e6Vv
const authDesc = createSingleSigAuthDescriptorRegistration(["A", "T"], pubKey);

```


#### **Function: `createMultiSigAuthDescriptorRegistration`** [â€‹](\#function-createmultisigauthdescriptorregistration "Direct link to function-createmultisigauthdescriptorregistration")

Creates a MultiSig auth descriptor with the specified permissions, multiple public keys, the number of required
signatures, and optional rules.

- **Parameters:**
  - `flags: string[]` \- List of permissions.
  - `pubKeys: Buffer[]` \- List of public keys.
  - `signaturesRequired: number` \- Number of required signatures.
  - `rules?: AuthDescriptorRules` \- Optional rules for the descriptor.
- **Example:**





```codeBlockLines_e6Vv
const authDesc = createMultiSigAuthDescriptorRegistration(["T"], [pubKey1, pubKey2], 2);

```


### **Using rules in auth descriptors** [â€‹](\#using-rules-in-auth-descriptors "Direct link to using-rules-in-auth-descriptors")

Rules further refine the conditions under which auth descriptors can be used. These can be **simple** or **complex**.

#### **Simple rule** [â€‹](\#simple-rule "Direct link to simple-rule")

A simple rule specifies a condition for a single variable.

- **Structure:**





```codeBlockLines_e6Vv
export type SimpleRule<T extends string> = {
    variable: T; // Variable being constrained (e.g., opCount)
    operator: RuleOperator; // Comparison operator (e.g., lessThan)
    value: number; // Value to compare against
};

```

- **Example:** "Expire after 2 uses"





```codeBlockLines_e6Vv
const rule = { variable: "opCount", operator: "lessThan", value: 2 };

```


#### **Complex rule** [â€‹](\#complex-rule "Direct link to complex-rule")

A complex rule combines multiple simple rules using logical operators (e.g., "and").

- **Structure:**





```codeBlockLines_e6Vv
export type ComplexRule<T extends string> = {
    operator: "and";
    rules: SimpleRule<T>[];
};

```

- **Example:** "Expire after 2 uses and only allow transfers"





```codeBlockLines_e6Vv
const complexRule = {
    operator: "and",
    rules: [\
      { variable: "opCount", operator: "lessThan", value: 2 },\
      { variable: "permissions", operator: "equals", value: "T" },\
    ],
};

```


### **Examples of creating auth descriptors** [â€‹](\#examples-of-creating-auth-descriptors "Direct link to examples-of-creating-auth-descriptors")

#### **Single-sig example** [â€‹](\#single-sig-example "Direct link to single-sig-example")

"Whenever the public key signs, they can edit the account or transfer funds."

```codeBlockLines_e6Vv
const authDesc = createSingleSigAuthDescriptorRegistration(["A", "T"], pubKey);

```

#### **Multi-sig example 1** [â€‹](\#multi-sig-example-1 "Direct link to multi-sig-example-1")

"Whenever both pubKey1 and pubKey2 sign, they can transfer funds."

```codeBlockLines_e6Vv
const authDesc = createMultiSigAuthDescriptorRegistration(["T"], [pubKey1, pubKey2], 2);

```

#### **Multi-sig example 2** [â€‹](\#multi-sig-example-2 "Direct link to multi-sig-example-2")

"The first time 3 out of 5 keys sign, they can edit the account."

```codeBlockLines_e6Vv
const authDesc = createMultiSigAuthDescriptorRegistration(["A"], [pubKey1, pubKey2, pubKey3, pubKey4, pubKey5], 3, {
  variable: "opCount",
  operator: "lessThan",
  value: 2,
});

```

#### **Instantiate rules** [â€‹](\#instantiate-rules "Direct link to instantiate-rules")

Here's a few example of possible rules which can be created:

```codeBlockLines_e6Vv
// Example rules
const lessThanThreeTimes = lessThan(opCount(3));
const untilBlock100 = lessOrEqual(blockHeight(100));
const during2024 = and(
  greaterOrEqual(blockTime(1704067200000)), //Jan 1st, 2024 (millisecond timestamp)
  lessThan(blockTime(1735689600000)) //Jan 1st, 2025
);
const onceDuring2024 = and(
  greaterOrEqual(blockTime(1704067200000)), //Jan 1st, 2024
  lessThan(blockTime(1735689600000)), //Jan 1st, 2025
  lessThan(opCount(2))
);

```

### **Instantiation steps** [â€‹](\#instantiation-steps "Direct link to instantiation-steps")

1. **Generate key pairs** Create or load the public/private key pairs:





```codeBlockLines_e6Vv
const pubKey1 = Buffer.from("public_key_1_hex", "hex");
const pubKey2 = Buffer.from("public_key_2_hex", "hex");

```

2. **Define permissions** Use flags like `["A"]` for account editing or `["T"]` for transfers.

3. **Add rules (optional)** Specify simple or complex rules for additional constraints.

4. **Create the auth descriptor** Use the appropriate function for `SingleSig` or `MultiSig` auth descriptors.


* * *

### **Key points to remember** [â€‹](\#key-points-to-remember "Direct link to key-points-to-remember")

- **Flags:** Control what the auth descriptor allows (e.g., "A" for account editing, "T" for transfers).
- **Rules:** Add constraints like expiration or operational limits.
- **Signature type:** Choose `SingleSig` for single-key auth or `MultiSig` for multi-key requirements.

- [**Auth descriptor structure**](#auth-descriptor-structure)
- [**Creating auth descriptors**](#creating-auth-descriptors)
- [**Using rules in auth descriptors**](#using-rules-in-auth-descriptors)
- [**Examples of creating auth descriptors**](#examples-of-creating-auth-descriptors)
- [**Instantiation steps**](#instantiation-steps)
- [**Key points to remember**](#key-points-to-remember)- [@chromia/ft4](../index.html)
- [accounts](../modules/accounts.html)
- [createSingleSigAuthDescriptorRegistration](accounts.createSingleSigAuthDescriptorRegistration.html)

# Function createSingleSigAuthDescriptorRegistration

- createSingleSigAuthDescriptorRegistration(flags, signer, rules?): [AuthDescriptorRegistration](../types/accounts.AuthDescriptorRegistration.html) < [SingleSig](../types/accounts.SingleSig.html) > [Permalink](#createSingleSigAuthDescriptorRegistration)
- Creates a registration for a single signature auth descriptor





#### Parameters



- flags: string\[\]


the flags that this auth descriptor will have

- signer: Buffer


the signer that will sign this auth descriptor

- rules: null \| [AuthDescriptorRules](../types/accounts.AuthDescriptorRules.html) = null


any rules to be included in the registration


#### Returns [AuthDescriptorRegistration](../types/accounts.AuthDescriptorRegistration.html) < [SingleSig](../types/accounts.SingleSig.html) >

the created registration

### Settings

#### Member Visibility

- Protected
- Private
- Inherited

#### Theme

OSLightDark[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In this topic, you'll build and deploy the `Hello World` dapp with the
[Chromia Command-line Interface (Chromia CLI)](/intro/terminology#chromia-command-line-interface-chromia-cli). Read
more about the features of the Chromia CLI in the [Chromia CLI command reference](/category/command-reference)
section.

## Prerequisite [â€‹](\#prerequisite "Direct link to Prerequisite")

- Install Visual Studio Code; see [VS Code Installation Guide](https://code.visualstudio.com).
- Install PostgreSQL database; see [Set up PostgreSQL database](/intro/installation/database-setup).
- Install Java Development Kit (open JDK) and have at least Java 17; see see
[JDK Installation Guide](https://docs.oracle.com/en/java/javase/17/install/overview-jdk-installation.html#GUID-8677A77F-231A-40F7-98B9-1FD0B48C346A).
- Install Chromia CLI; see [Install and configure Chromia CLI](/intro/installation/cli-installation).

## Run dapp in Chromia CLI [â€‹](\#run-dapp-in-chromia-cli "Direct link to Run dapp in Chromia CLI")

Once you install the Chromia CLI, it's time to create a project.

1. Create the project folder in a path of your choice and use the `chr create-rell-dapp` command.

```codeBlockLines_e6Vv
mkdir My_Rell_Project
cd My_Rell_Project
chr create-rell-dapp

```

The `chr create-rell-dapp` command creates a new [Rell](/intro/terminology#rell) structured project with the
necessary files. A `main.rell` file, which includes the `Hello World` query and test files in the `src/test/` folder.
You also have a standard configuration for your project in the `chromia.yml` file. For more information, see the
[project config file](/intro/configuration/project-config).

```codeBlockLines_e6Vv
My_Project
   |--chromia.yml
   |--_src
      |--main.rell
      |--_test
         |--arithmetic_test.rell
         |--data_test.rell

```

The next step is to start a [node](/intro/terminology#node) and run your app locally. You can do it in a couple of
different ways, but the most straightforward method we recommend is the Chromia [CLI](/cli/commands/node).

2. Use the `chr node start` command to start a node. Make sure it's available in the same working directory where you
have the `chromia.yml` file.





```codeBlockLines_e6Vv
chr node start

```









The `chr node start` command starts a node with your applications running on it. All the blockchains listed in the
`blockchains` key in the `chromia.yml` file get started.


```codeBlockLines_e6Vv
blockchains:
  hello: <----- This is the blockchain that starts
    module: main <----- This is the entry point of the chain

```

note

If you are running the node on a different URL than the default `http://localhost:7740`, you can use the `--api-url` to
specify it.

Now the node should be up, where the Rell backend is running with a local blockchain. Locate the
[**Blockchain RID**](/intro/terminology#blockchain-rid-brid) in the output of the node. You need it to interact
with your dapp. The Blockchain RID is the hex value following the Blockchain RID: tag. For example, see the following
image.

![blockchain RID CLI](/img/blockchain_RID_CLI.png)

The last step is to query your dapp and test that the backend works correctly.

3. Write the following in a new terminal with your project folder as the working directory. Remember to replace the
`<BlockchainRID>` with your **Blockchain RID** from the node output.

```codeBlockLines_e6Vv
chr query --blockchain-rid <BlockchainRID> hello_world

```

Your terminal should show you the following message.

```codeBlockLines_e6Vv
"Hello World!"

```

Great job. The Rell backend is up and running and works as it should. You have now run a `Hello World` dapp in the
Chromia CLI.

## Run dapp in VS Code [â€‹](\#run-dapp-in-vs-code "Direct link to Run dapp in VS Code")

The extension enables language features for Rell, including syntax highlighting and compilation warnings. It contributes
the commands **Rell: New Template Project** and **Rell: Invalidate index caches**, which are available in the Command
Palette. Once you install the extension, it's time to create a project.

1. Open the Command Palette by going to the menu **View** \- **Command Palette**. Type **Rell: New Template Project** and
run the command.

![blockchain RID CLI](/img/command_template_project.png)

![blockchain RID CLI](/img/new_project_template.png)

The command **Rell: New Template Project** creates a new Rell structured project with the necessary files. A `main.rell`
file, which includes the `Hello World` query and test files in the `src/test/` folder. You also have a standard
configuration for your project in the `chromia.yml` file. For more information, see the
[project config file](/intro/configuration/project-config).

```codeBlockLines_e6Vv
My_Project
   |--chromia.yml
   |--_src
      |--main.rell
      |--_test
         |--arithmetic_test.rell
         |--data_test.rell

```

Make sure to set the same password and username as your database instance if you didn't choose the default one from
[Set up PostgreSQL database](/intro/installation/database-setup). You can change this under the database attributes
in the [project config file](/intro/configuration/project-config).

The next step is to start a [node](/intro/terminology#node) and run your app locally. You can do this in a couple
of different ways, but the most straightforward method we recommend is the Chromia CLI.

3. Use the `chr node start` command to start a node. Make sure it's available in the same working directory where you
have the `chromia.yml` file.

info

This command starts a node that contains your app. For more information, see
[Deploy your dapp to testnet](/intro/deployment/testnet/deploy-dapp) or [node command](/cli/commands/node).

Locate the Blockchain RID in the terminal output. You need it to interact with your dapp. The Blockchain RID is the hex
value following the Blockchain RID: tag. For example, see the following image.

![blockchain RID CLI](/img/blockchain_RID_CLI.png)

The last step is to query your dapp and test that the backend is working correctly.

4. Write the following command in a new terminal with your project folder as the working directory. Remember to replace
the `<BlockchainRID>` with your **Blockchain RID** from the node output.

```codeBlockLines_e6Vv
curl -X GET 'localhost:7740/query/<BlockchainRID>?type=hello_world'

```

The `CURL` command requires the blockchain on `localhost` and port `7740`, which are the standard settings. It also
calls the `Hello World` query in the `main.rell` file. Your terminal should show you the following message.

```codeBlockLines_e6Vv
"Hello World!"

```

info

Writing `CURL` commands to query your backend is a safe approach, but for future queries, you might want use the
[query command](/cli/commands/query) in the Chromia CLI.

Great job. The Rell backend is up and running and works as it should. You have now run a `Hello World` dapp in VS Code.

For your next steps with Rell, feel free to follow the courses on the
[Chromia learning platform](https://learn.chromia.com/).

- [Prerequisite](#prerequisite)
- [Run dapp in Chromia CLI](#run-dapp-in-chromia-cli)
- [Run dapp in VS Code](#run-dapp-in-vs-code)