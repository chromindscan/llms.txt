# Chromia Learn

- [Chat Agent Setup Test](https://learn.chromia.com/courses/chat-agent-course/test-your-setup): Test your Chromia chat agent setup by starting the node, UI, and AI agent; then interact and troubleshoot.
- [Chat Agent API Setup](https://learn.chromia.com/courses/chat-agent-course/configure-api-key): Configure your xAI, Groq, or other OpenAI-compatible API key for the chat agent.
- [Web3 Courses for Developers](https://learn.chromia.com/tags/Web3): Web3 courses for developers transitioning from Web2 to Web3 development.
- [FT4 Demo App](https://learn.chromia.com/courses/ft4-demo-app/introduction): Build a digital asset management system using Chromia's FT4 token standard.  Learn to create, manage, and transfer assets, implementing account management.
- [Solana vs Chromia](https://learn.chromia.com/courses/chromia-comparisons/solana): Solana comparison to Chromia: architecture, scalability, development, fees, revenue models, and a conclusion summarizing benefits and challenges of each platform.
- [FT4 Account Management](https://learn.chromia.com/courses/ft4-demo-app/module-blockchain/account-management): Learn to implement account management in FT4, covering account registration, permission management, and authentication strategies.
- [Chromia Chatbot Course](https://learn.chromia.com/tags/Chatbot): Learn to build and experiment with a chat agent on Chromia, focusing on AI and blockchain integration.
- [Chromia Chat Agent Course](https://learn.chromia.com/courses/chat-agent-course/introduction): Build an AI-powered chat agent on Chromia using boilerplate code, exploring memory management and AI model integrations.
- [Querying Chromia Transactions](https://learn.chromia.com/courses/book-review/blockchain-transactions/query-transaction): Learn to query Chromia blockchain transactions and dapp state using Rell, fetching all books or transaction history.
- [Book Review Entity](https://learn.chromia.com/courses/book-review/book-review-entity): Define, create, and query book review entities linked to books using ISBNs for reference.
- [Polygon vs Chromia](https://learn.chromia.com/courses/chromia-comparisons/polygon): Compare Polygon and Chromia blockchain platforms; explore architecture, scalability, development, fees, and revenue models; discover which best suits your needs.
- [React Courses](https://learn.chromia.com/tags/React): Learn to build decentralized apps using React, Rell, and Chromia.
- [Book Review Operations](https://learn.chromia.com/courses/book-review/book-review-entity/basic-operations): Learn to create and test book review operations using Rell, Chromia's query language, by adding unit tests and validating on a local node.
- [Chromia for EVM Developers](https://learn.chromia.com/courses/chromia-for-evm-developers/introduction): Learn to build dApps on Chromia using Rell, transitioning from EVM and Solidity.
- [Chromia FT4 Courses](https://learn.chromia.com/tags/FT4): Learn to build decentralized marketplaces and monetize dapps using Chromia's FT4 framework.  Includes courses and tutorials.
- [Chromia Concepts Courses](https://learn.chromia.com/tags/Concepts): Learn Chromia's core concepts through beginner-friendly courses on dapp development and Web3 transition.
- [Chromia Transaction Management](https://learn.chromia.com/courses/book-review/blockchain-transactions): Learn how Chromia manages transactions and states, validates user-signed transactions, and queries blockchain data.
- [Chat Agent: Explore & Extend](https://learn.chromia.com/courses/chat-agent-course/explore-and-extend): Explore and extend your chat agent's capabilities by experimenting with memory handling, agent behavior, and custom scenarios.  Modify prompts, objectives, and memory strategies to enhance interactions.
- [Blockchain Transaction Example](https://learn.chromia.com/courses/book-review/blockchain-transactions/example): Example of adding and updating blockchain transactions using Chromia and Rell, showing state and transaction query results.
- [MetaMask Integration Courses](https://learn.chromia.com/tags/MetaMask): Learn to integrate MetaMask with Chromia using Rell and React. Build a decentralized news feed app.
- [Chromia Asset Registration](https://learn.chromia.com/courses/ft4-demo-app/module-blockchain/asset-registration): Learn to register and mint digital assets on the Chromia blockchain, with a limit of one asset per account.
- [Chromia Book Review Course](https://learn.chromia.com/courses/book-review/introduction): Learn Rell, Chromia's blockchain language, by building a book review dapp.  Master entity creation, queries, and data validation.
- [Rell Structured Queries](https://learn.chromia.com/courses/book-review/sign-transaction/structure): Learn to filter and sort data efficiently using structured queries in Rell, a relational query language, with examples and tests.
- [Crosschain Development Courses](https://learn.chromia.com/tags/Crosschain): Learn crosschain concepts and build multi-blockchain dapps with our comprehensive courses.
- [Chromia Client & Transaction Signing](https://learn.chromia.com/courses/book-review/build-client/sign-transaction): Build a Chromia client, connect to a blockchain, and sign transactions using the postchain-client library.
- [Polkadot vs Chromia](https://learn.chromia.com/courses/chromia-comparisons/polkadot): Compare Polkadot and Chromia blockchain platforms: architecture, scalability, development, fees, and revenue models.  Explore benefits and challenges of each.
- [Rell Input Validation](https://learn.chromia.com/courses/book-review/input-verification/input-verification): Learn to implement and test input validations in Rell for your Chromia blockchain application using the require function and ensure data integrity.
- [Multichain Dapp Development](https://learn.chromia.com/tags/Multichain): Learn to build and monetize multi-chain dapps with Chromia's comprehensive courses.
- [Chromia Blockchain Comparisons](https://learn.chromia.com/courses/chromia-comparisons/overview): Compare Chromia blockchain to others like Polygon, Cosmos, & Ethereum; understand features, strengths, limitations to make informed decisions for your project.
- [Chromia CLI Setup](https://learn.chromia.com/courses/book-review/setup): Setup PostgreSQL database and install Chromia CLI on macOS, Linux, Windows, or via Docker; instructions and troubleshooting.
- [FT4 Project Setup](https://learn.chromia.com/courses/ft4-demo-app/module-blockchain/setup): Setup a Chromia blockchain project using the FT4 library for asset management, including dependency installation.
- [Chromia Book Entity Operations](https://learn.chromia.com/courses/book-review/book-entity/basic-operations): Learn to create the create_book operation in Rell, add unit tests, and execute on a local Chromia node.
- [Courses tagged with: tag](https://learn.chromia.com/tags/tag): No courses found for the specified tag. Check for typos or try a different tag.
- [Book Entity in Rell](https://learn.chromia.com/courses/book-review/book-entity): Define a book entity, create storage operations, write tests, and queries in the Rell language.
- [Chromia Dapp Courses](https://learn.chromia.com/tags/Dapp): Learn dapp development with Chromia: build your first dapp, monetize, and create multi-blockchain applications.
- [Chromia Book Review Entity](https://learn.chromia.com/courses/book-review/book-review-entity/tables): Define and implement the 'book_review' entity in Chromia, linking it to the 'book' entity using Rell, including code examples and attribute breakdowns.
- [Ethereum Compared to Chromia](https://learn.chromia.com/courses/chromia-comparisons/etherum): Ethereum vs Chromia: Compare blockchain architectures, scalability, development tools, fees, and revenue models.  Discover the benefits and challenges of each platform.
- [Chromia AI Courses](https://learn.chromia.com/tags/AI): Build AI-powered chat agents on Chromia blockchain; explore AI and blockchain integration.
- [Chromia Course: Next Steps](https://learn.chromia.com/courses/book-review/what-next): Course completion guide with suggestions for continued learning, community engagement, and feedback channels.
- [Book Review: Signing Transactions](https://learn.chromia.com/courses/book-review/sign-transaction): Learn to sign transactions, use the book_keeper function, and perform efficient data filtering and sorting with Rell queries.
- [Chromia for EVM Developers](https://learn.chromia.com/courses/chromia-for-evm-developers/summary): Summary of transitioning from EVM and Solidity to Chromia for developers, highlighting benefits like enhanced scalability and improved security.
- [Chromia Client Prerequisites](https://learn.chromia.com/courses/book-review/build-client/prerequisites): Setup your development environment to build a Chromia blockchain client by installing Node.js, required packages, and configuring TypeScript.
- [Chromia Blockchain Query](https://learn.chromia.com/courses/book-review/build-client/query-blockchain): Query the Chromia blockchain to retrieve information about transactions and dapp table state using the postchain-client.
- [Rell Input Validation](https://learn.chromia.com/courses/book-review/input-verification): Learn input validation in Rell, ensuring secure data and structured query results using the `require` function and `book_review_dto` struct.
- [Chromia Learn Courses](https://learn.chromia.com/): Learn to build decentralized apps and master Rell, Chromia's SQL-based blockchain language, through various courses for all levels.
- [Solidity vs Rell Authentication](https://learn.chromia.com/courses/chromia-for-evm-developers/compare-authentication): Compare authentication methods in Solidity and Rell, focusing on user authorization and access control within smart contracts.
- [Chromia Stack Architecture](https://learn.chromia.com/courses/chromia-for-evm-developers/chromia-stack): Chromia's architecture uses Rell, PostgreSQL, and a consensus algorithm for secure and efficient dapp development.
- [Chromia Client Tutorial](https://learn.chromia.com/courses/book-review/build-client): Build a Chromia blockchain client, connect, query, and transmit transactions using postchain-client.
- [Chromia CI/CD Tutorial](https://learn.chromia.com/courses/continuous-integration-deploy): Learn to set up continuous integration and deployment for your Chromia blockchain project using GitLab CI/Bitbucket pipelines.
- [FT4 Token Burning](https://learn.chromia.com/courses/ft4-demo-app/module-frontend-application/burn): Learn how to burn tokens using the FT4 session object's burn method in the Chromia frontend application.
- [Blockchain App Development](https://learn.chromia.com/courses/ft4-demo-app/module-blockchain): Learn blockchain application development for asset management systems; includes account management, asset registration, and testing.
- [Chromia News Feed Dapp](https://learn.chromia.com/courses/chromia-for-evm-developers/news-feed): Build a decentralized news feed dapp using Chromia and Rell; compare Solidity and Rell implementations, focusing on data modeling, operations, and efficient data fetching.
- [Chromia Transaction Signing](https://learn.chromia.com/courses/book-review/sign-transaction/sign-transaction): Learn to secure Chromia blockchain transactions by requiring administrator signatures for adding books, using module arguments and keypairs for authorization and testing.
- [Chat Agent Setup Guide](https://learn.chromia.com/courses/chat-agent-course/setup): Setup and installation guide for Chromia Chat Agent Course, including PostgreSQL database configuration and Chromia CLI installation across various systems.
- [Chromia CI/CD Pipelines](https://learn.chromia.com/courses/continuous-integration/introduction): Learn to use the Chromia CLI to create pipelines for testing and deploying Rell code on the Chromia blockchain platform.  This guide covers building, testing, and deploying.
- [Rell Project Structure](https://learn.chromia.com/courses/book-review/rell-structure): Learn to structure your Rell project effectively using dedicated files and folders for better organization and scalability in Chromia dapp development.
- [Chromia Rell Queries](https://learn.chromia.com/courses/book-review/book-review-entity/write-queries): Learn to write queries in Rell to retrieve book reviews from a Chromia database, including testing on a local node.
- [Rell Book Entity](https://learn.chromia.com/courses/book-review/book-entity/tables): Define a Book entity in Rell, similar to a database table, with isbn, title, and author attributes.
- [News Feed Follower](https://learn.chromia.com/courses/chromia-for-evm-developers/news-feed-follower): Implement user following and news feed functionality using Solidity and Rell, efficiently fetching posts from followed users with relational queries.
- [Chromia for EVM Developers](https://learn.chromia.com/courses/chromia-for-evm-developers/concepts): Learn core blockchain development concepts, transitioning from Solidity to Chromia's Rell: smart contract and dapp states, interactions, internal functions, and data querying.
- [FT4 Demo App Testing](https://learn.chromia.com/courses/ft4-demo-app/module-blockchain/test): Comprehensive testing of Chromia's asset management system, covering asset registration, multiple asset restrictions, and asset transfers.
- [Rell SQL Courses](https://learn.chromia.com/tags/SQL): Learn SQL and database interactions with Rell through our intermediate masterclass and relationship courses.
- [Chromia Client Example](https://learn.chromia.com/courses/book-review/build-client/complete-example): Complete example showcasing a fully functional Chromia client, querying for entities, and handling transactions.
- [Chromia Asset Transfer](https://learn.chromia.com/courses/chromia-for-evm-developers/asset-transfer): Build a simple English Auction dapp in Solidity and Chromia's Rell, focusing on asset transfer logic and comparing both languages.
- [Chromia Rell: Associate Function](https://learn.chromia.com/courses/associate-function/introduction): Learn to build a simple function for creating a map that collects a structure based on a specific key using Chromia's Rell ORM.
- [Fullstack Dapp Template](https://learn.chromia.com/courses/ft4-demo-app/module-init): Setup blockchain environment and create a rell dapp template using the asset-management template.
- [FT4 Demo App Tools](https://learn.chromia.com/courses/ft4-demo-app/module-frontend-application/tools): Tools and libraries for building FT4 demo applications using Chromia blockchain, React, and EVM wallets.
- [Chromia's Rell Courses](https://learn.chromia.com/tags/Rell): Learn Rell with Chromia's comprehensive courses, from beginner-friendly dapps to advanced multi-blockchain applications and AI integration.
- [Frontend Application Setup](https://learn.chromia.com/courses/ft4-demo-app/module-frontend-application/setup): Setup the frontend application by installing dependencies, configuring environment variables, and running the app locally.
- [Manual Dapp Testing](https://learn.chromia.com/courses/iccf-course/manual-testing): Manual testing of a dapp involving blockchain setup, transaction verification, and data querying.
- [FT4 Frontend Application](https://learn.chromia.com/courses/ft4-demo-app/module-frontend-application): Learn to build a frontend application for managing digital assets using the FT4 token standard.  This course covers account creation, asset registration, minting, transferring, and burning.
- [FT4 Asset Transfer](https://learn.chromia.com/courses/ft4-demo-app/module-frontend-application/transfer): Learn to transfer assets between accounts using the FT4 token standard with the useTransferTokens hook, checking account balances and handling transactions.
- [Defining Messages in Rell](https://learn.chromia.com/courses/icmf-course/defining-messages): Define messages in Rell for inter-chain communication using ICMF, modeling a product ordering system with three chains.
- [Chromia Account Registration](https://learn.chromia.com/courses/ft4-demo-app/module-frontend-application/account-regisration): Learn how to create an account using the FT4 registerAccount operation in the Chromia asset management template.
- [Frontend Application Deployment](https://learn.chromia.com/courses/ft4-demo-app/module-frontend-application/deploy-onchain): Deploy your frontend application on-chain or traditionally via any server using the provided instructions and scripts.
- [FT4 Asset Minting Guide](https://learn.chromia.com/courses/ft4-demo-app/module-frontend-application/register-and-mint): Learn to mint an asset using the FT4 token standard and the Chromia blockchain.  This guide covers using the register_and_mint_asset operation and custom hooks.
- [Subscription Chain Implementation](https://learn.chromia.com/courses/iccf-course/subscription-chain): Implement a Subscription Chain with accounts, receipts, and queries using Chromia blockchain and ReLL; includes unit tests.
- [ICCF Course Introduction](https://learn.chromia.com/courses/iccf-course/introduction): Learn how Inter-Chain Confirmation Facility (ICCF) enables cross-chain transaction proof verification; build a simple digital warehouse.
- [Chromia Marketplace Course](https://learn.chromia.com/courses/marketplace-course/introduction): Build a decentralized marketplace for game trading cards using Chromia FT4 library and NFTs.
- [Chromia Marketplace Module](https://learn.chromia.com/courses/marketplace-course/module-assets): Build a complete marketplace for buying, selling, and trading mystery cards.
- [ICMF Course Introduction](https://learn.chromia.com/courses/icmf-course/introduction): Build a three-blockchain dapp using Inter-Chain Message Facility (ICMF) for communication and learn about its architecture and implementation in Rell.
- [Chromia CLI Setup](https://learn.chromia.com/courses/ft4-demo-app/module-init/setup-application): Setup your development environment by installing PostgreSQL and the Chromia CLI using various methods including Homebrew, apt, Docker, and Scoop.
- [Decentralized App System Overview](https://learn.chromia.com/courses/iccf-course/system-overview): System overview of a decentralized application with two blockchains: Subscription Chain and Digital Warehouse Chain, detailing user payment, access, and subscription modeling.
- [Chromia Dapp Manual Testing](https://learn.chromia.com/courses/icmf-course/manual-testing): Manually test a Chromia dapp across three local blockchains by placing an order and tracing it through each chain using the Chromia CLI.
- [Mystery Card Purchase](https://learn.chromia.com/courses/marketplace-course/module-assets/buy-mystery-card): Add a dapp fee account to transfer funds when users purchase mystery cards, setting a fixed price and handling transactions.
- [Chromia Setup Guide](https://learn.chromia.com/courses/icmf-course/setup): Setup instructions for PostgreSQL database and Chromia CLI installation using various methods (Docker, package managers).
- [Chromia Factory Chain Dapp](https://learn.chromia.com/courses/icmf-course/factory-chain): Develop a Chromia factory chain dapp that reacts to production orders, manufactures products, and notifies when orders are ready for shipment.
- [Chromia CLI Setup](https://learn.chromia.com/courses/iccf-course/setup): Setup and installation guide for Chromia CLI, including prerequisites such as PostgreSQL database configuration and various installation methods for different operating systems.
- [Chromia Marketplace Test](https://learn.chromia.com/courses/marketplace-course/module-assets/test-marketplace): Step-by-step guide to testing a Chromia marketplace using the Rell test framework, including setup, transactions, and assertions.
- [Chromia's Latest Known Time](https://learn.chromia.com/courses/latest-known-time/introduction): Determine reliable time on a blockchain using latest known time or previous block time, handling initialization and different contexts.
- [Chromia Marketplace FT4 Module](https://learn.chromia.com/courses/marketplace-course/module-ft4): Learn to register payment tokens and create user accounts for Chromia's marketplace using the FT4 library.
- [Buy Listed NFT](https://learn.chromia.com/courses/marketplace-course/module-assets/buy-listed-card): Learn to buy listed NFTs using the buy_nft operation in the Chromia marketplace.  This operation handles authentication, payment transfer, and ownership changes.
- [Chromia Marketplace CLI Test](https://learn.chromia.com/courses/marketplace-course/module-assets/test-cli): Test Chromia marketplace module using CLI commands: create accounts, buy/list NFTs, verify balances.
- [Digital Warehouse Chain](https://learn.chromia.com/courses/iccf-course/digital-warehouse-chain): Digital warehouse chain tracks inventory, uses ICCF for authentication, and generates reports; includes unit tests.
- [Chromia Order Chain](https://learn.chromia.com/courses/icmf-course/order-chain): Configure and test a Chromia blockchain module for managing e-commerce orders, including database modeling, message sending, and testing.
- [Chromia Querying](https://learn.chromia.com/courses/book-review/book-entity/write-queries): Learn to write and test queries to fetch book data from a Chromia blockchain using Rell.
- [Cosmos vs Chromia](https://learn.chromia.com/courses/chromia-comparisons/cosmos): Compare Cosmos and Chromia blockchain platforms: architecture, scalability, development, fees, revenue models, and benefits of each.
- [Chromia NFT Marketplace Listing](https://learn.chromia.com/courses/marketplace-course/module-assets/list-card): Learn to list NFTs on Chromia marketplace using ReLL.  This module details adding list_nft operation and queries for fetching listed NFTs with sorting options.
- [Delivery Chain Module](https://learn.chromia.com/courses/icmf-course/delivery-chain): Implement a delivery chain module using Rell, handling ICMF messages and managing order states with tests.
- [Chromia Query Structuring](https://learn.chromia.com/courses/book-review/input-verification/structure): Structure query results in Chromia using structs for combining book information with associated reviews, improving data organization and usability.



*Note: This is llms-full.txt is not complete, please enter a Firecrawl API key to get the entire llms-full.txt at llmstxt.firecrawl.dev or you can access llms.txt via API with curl -X GET 'http://llmstxt.firecrawl.dev/https://learn.chromia.com/?FIRECRAWL_API_KEY=YOUR_API_KEY' or llms-full.txt via API with curl -X GET 'http://llmstxt.firecrawl.dev/https://learn.chromia.com//full?FIRECRAWL_API_KEY=YOUR_API_KEY'

# https://learn.chromia.com/ llms-full.txt

[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Now that you have set up your project, let's test if everything works correctly. Follow these steps:

## Start the Chromia node [​](\#start-the-chromia-node "Direct link to Start the Chromia node")

To start the Chromia node, run the following command:

```codeBlockLines_e6Vv
chr node start

```

**Optional:** If you want to start with a wiped database, run:

```codeBlockLines_e6Vv
chr node start --wipe

```

This command resets the database to its initial state, which can be useful during development.

## Start the user interface (Optional) [​](\#start-the-user-interface-optional "Direct link to Start the user interface (Optional)")

In a new terminal, start the user interface to make the chat agent accessible through a browser:

```codeBlockLines_e6Vv
npm run ui

```

You can access the UI at:

[http://localhost:1234](http://localhost:1234)

## Start the AI agent [​](\#start-the-ai-agent "Direct link to Start the AI agent")

In another terminal, run the AI agent:

```codeBlockLines_e6Vv
npm run dev

```

After the agent starts, the terminal will display a URL similar to this:

```codeBlockLines_e6Vv
http://localhost:1234/?sessionId=<session_id>

```

Replace `<session_id>` with the actual session ID displayed in the terminal output. This session ID is unique to your current instance of the chat agent.

## Interact with the chat agent [​](\#interact-with-the-chat-agent "Direct link to Interact with the chat agent")

Open the URL in your browser to interact with the chat agent. Type messages into the interface and verify the responses to ensure everything works as expected.

* * *

## Troubleshooting tips [​](\#troubleshooting-tips "Direct link to Troubleshooting tips")

- **Session ID conflicts:**

The system automatically stores the session ID in the `.env` file. If you restart the Chromia node, the stored session ID may become invalid. To fix this, open the `.env` file and delete the line containing the `SESSION_ID`. A new session ID will be generated the next time you run the AI agent.

- **Chat agent doesn't respond:**

Make sure:
  - The Chromia node is running.
  - The `.env` file is correctly configured with a valid API key.
  - You installed the dependencies correctly using `bun install`.
- **Checking logs:**

If issues persist, consult the console logs in each terminal for detailed error messages. These logs can help you identify the problem.


- [Start the Chromia node](#start-the-chromia-node)
- [Start the user interface (Optional)](#start-the-user-interface-optional)
- [Start the AI agent](#start-the-ai-agent)
- [Interact with the chat agent](#interact-with-the-chat-agent)
- [Troubleshooting tips](#troubleshooting-tips)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

To enable the chat agent, set up your API key. The project is pre-configured to use **`xAI`**, but feel free to switch to **`Groq`** or any OpenAI-compatible API.

info

If the `.env` file does not exist, create it using the `.env.sample` file and update it with your chosen API key.

## Default option: `xAI` [​](\#default-option-xai "Direct link to default-option-xai")

1. Go to [xAI API](https://x.ai/api).

2. Sign in or create an account.

3. Obtain your API key.

4. Open the `.env` file and set the following:





```codeBlockLines_e6Vv
XAI_API_KEY=your_api_key_here

```


After configuration, proceed to [Test your setup](/courses/chat-agent-course/test-your-setup).

## Alternative option: `Groq` [​](\#alternative-option-groq "Direct link to alternative-option-groq")

1. Go to [Groq console](https://console.groq.com/keys).

2. Sign in or create an account.

3. Obtain your API key.

4. Open the `.env` file and set the following:





```codeBlockLines_e6Vv
XAI_API_KEY=your_api_key_here

```

5. Update the `baseURL` in `/agent/services/openai.ts` to:





```codeBlockLines_e6Vv
baseURL: "https://api.groq.com/openai/v1",

```

6. Update the model in the following locations:


   - **`agent/config.yml`**: Replace the `model` field with your chosen model, e.g., `llama-3.1-8b-instant`.
   - **`agent/tools/memory.ts`**: Replace the `model` variable with your chosen model.

Example in `agent/config.yml`:

```codeBlockLines_e6Vv
model: "llama-3.1-8b-instant"

```

Example in `agent/tools/memory.ts`:

```codeBlockLines_e6Vv
model: string = "llama-3.1-8b-instant";

```

Check the [Groq documentation](https://console.groq.com/docs/models) for a list of available models.

After updating, proceed to [Test your setup](/courses/chat-agent-course/test-your-setup).

## Using other OpenAI-compatible APIs [​](\#using-other-openai-compatible-apis "Direct link to Using other OpenAI-compatible APIs")

1. Obtain an API key from the chosen provider.

2. Open the `.env` file and set the following:





```codeBlockLines_e6Vv
XAI_API_KEY=your_api_key_here

```

3. Update the `baseURL` in `/agent/services/openai.ts` to match the provider's endpoint.

4. Update the necessary configuration files, such as `agent/config.yml`, and modify any hardcoded values, like the `model` variable in `agent/tools/memory.ts`, to match the specific model or API requirements.


- [Default option: `xAI`](#default-option-xai)
- [Alternative option: `Groq`](#alternative-option-groq)
- [Using other OpenAI-compatible APIs](#using-other-openai-compatible-apis)[Skip to main content](#__docusaurus_skipToContent_fallback)

## Web3 Concepts Courses

#### Courses focused on transitioning from Web2 to Web3.

[Beginner **Web3 for Web2 developers** \\
Transition smoothly from Web2 to Web3 development, tailored for web developers.](/courses/web3-for-web2-devs/introduction)

[Web3](/tags/Web3) [Dapp](/tags/Dapp)

Start Course[Skip to main content](#__docusaurus_skipToContent_fallback)

In this course, we will see how to build a digital asset management system using Chromia's FT4 token standard. You'll learn how to create, manage, and transfer digital assets while implementing account management functionality.

What we will cover:

- Setting up an FT4-based project
- Creating and managing user accounts
- Registering and minting digital assets
- Implementing asset transfers between accounts
- Fatching user balance
- Conduct comprehensive testing of the asset management system.

The FT4 library provides a robust foundation for handling accounts and assets on Chromia. We'll explore its key features while building a practical asset management application.

The complete code repository for this course is available here: [FT4 Demo App Repository](https://bitbucket.org/chromawallet/dapp-templates/src/main/asset_management/).[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Let's start with a quick overview of Solana, and then we will continue with comparing Solana to Chromia and also discuss the benefits and challenges
with the two solutions.

## Solana [​](\#solana-1 "Direct link to Solana")

**Tech and architecture**

- Solana uses a single-layer blockchain architecture, meaning all transactions are processed on the main chain.
This contrasts with multi-layer architectures, such as Chromia or Polkadot, which use subchains to process transactions in parallel.
- Solana's consensus mechanism is called **Proof of History (PoH)**, a unique way to timestamp transactions and achieve consensus. It creates a verifiable record of the passage of time, which allows nodes to reach a consensus on
the order of transactions quickly. PoH is combined with **Proof of Stake (PoS)** to secure the network and incentivize participating nodes.

**Scalability**

- There are multiple factors combined that allow Solana to scale effectively. PoH consensus model is, of course one, making it quick for nodes to reach consensus, and combined
with:
  - Gulf Stream protocol, which anticipates validator actions, thus speeding up the process.
  - Sealevel, a parallel execution environment for smart contracts, allowing thousands of contracts to run simultaneously.
- These innovations collectively enable Solana to handle a large volume of transactions swiftly and securely.


**Development tools**

- Solana developers use programming languages like Rust and C/C++ to build decentralized applications (dapps) on the Solana blockchain.
- Rust is a popular choice because it is a safe and fast language.
- Solana offers a number of other tools and libraries for developers, such as the Solana CLI, Solana Anchor, and Solana Program Library.

**Fee structure**

- Solana uses a fixed fee model, which means that the cost of transactions is relatively low and predictable. This model is designed to make it cost-effective for developers and users to interact with the network.

## Comparison [​](\#comparison "Direct link to Comparison")

### Development [​](\#development "Direct link to Development")

* * *

Solana

- Rust is the most popular programming language for Solana development, but C/C++ can also be used. Rust is favored for its safety features and performance, which make it a good choice for developing dapps and smart contracts on Solana.
- There are a couple of tools and frameworks to help build on Solana. For example, Solana Anchor and SPL these are libraries and frameworks with functionality to handle token transfers, account management, etc.
There are also tools for building and deploying Solana programs.

Chromia

- Chromia uses Rell, a relational blockchain programming language. Rell can be a more user-friendly language than Go or Rust, making it easier for developers to build dapps on Chromia.
- Development on Chromia using Rell is very similar to Web2 development. For more insights on this, check out our guide [here](https://docs.chromia.com/category/rell-language).
- Chromia provides tools and libraries to simplify authentication, transaction signing, and asset management, and new features are added to support rapid dapp development.
- Chromia's development environment has support for testing using its own test framework and simple deployment using developer-friendly tools.

### Scalability [​](\#scalability "Direct link to Scalability")

* * *

Solana

- Solana's key to high transaction speed is its Proof of History (PoH) consensus mechanism, which effectively timestamps transactions, allowing for rapid validation.
Combined with Tower BFT, a version of Byzantine Fault Tolerance, Solana achieves both speed and security.

- Solana's architecture consists of several features to optimize scalability:


Sealevel, a parallel smart contracts runtime, enables the simultaneous processing of transactions.

Gulf Stream, a protocol that allows for transactions to be sent directly to validators before the current block is even completed,
reducing confirmation times and network congestion.

Solana has an advanced architecture with many components. You can read more [here](https://docs.solana.com/cluster/overview).

Chromia

- Chromia's approach is that every dapp on Chromia operates on a unique subchain. Each subchain can handle hundreds of transactions every second.
If a dapp witnesses growth, it can with ease be expanded by adding more chains.
This structure guarantees sustained high throughput and a predictable way of scaling your dapp, much like in a traditional cloud environment.

Since every subchain is isolated from other subchains, this means that they can process transactions in parallel, in essence scaling horizontally
and only your app architecture sets the limit for scalability.

Chromias sidechain architecture is built into the platform, making it a low effort for developers to utilize this approach of side chains.


### Operational Costs & Fees [​](\#operational-costs--fees "Direct link to Operational Costs & Fees")

* * *

Solana

Solana uses traditional transaction fees, meaning that each transaction sent through the network is associated with a fee.

Fees are calculated from these parts:

- Base fee is the minimum fee charged for a transaction on the Solana network. This fee is determined by the current demand for block space and the network's congestion level.
- Computational Fee is measured by the computational resources required for a transaction in "compute units." Transactions that demand more computational power (like those involving complex smart contract operations) will cost more.

Chromia

- Chromia changes the game by allowing developers to host their decentralized app (dapp) in a container for a fixed,
predictable fee. This transparency means developers know how much their operational costs are each month, and they can create their own end-user fee structures to cover these operational expenses.

So, instead of being charged gas fees for every action, there's a single, more manageable cost to work with.

- As a Chromia dapp grows in usage, the developer of the sapp can increase the resources of their container. Very similar to how
you manage resources in a Cloud environment.


### Revenue models [​](\#revenue-models "Direct link to Revenue models")

* * *

Solana

- As with other blockchains, Solana generates transaction fees when users execute transactions on the network. The dapp developer can also add an extra fee per transaction as a source of revenue.
- Since Solana has a generally low transaction fee, it opens up to more freedom in choosing your revenue model as a dapp developer.

Chromia

- Operational costs of dapps are fixed and predictable on Chromia. The dapp developer can choose which fee model they want to use for their end-users.
With Chromia, you are not locked in by transaction and gas fees.

- For your dapp, you can have a monthly subscription fee, charge for single features, or, if you want, per transaction.
This opens up a more user-friendly experience since you can even let the user start for free and then
open up for revenues later when the user has found the value of your dapp. This is a common practice in traditional web applications and should be no different for Web3.


### Conclusion and comparison summary to Chromia [​](\#conclusion-and-comparison-summary-to-chromia "Direct link to Conclusion and comparison summary to Chromia")

* * *

Solana and Chromia are both well-architectured to handle common issues with traditional blockchain platforms.
Let's summarize and discuss the benefits and challenges.

### Architecture [​](\#architecture "Direct link to Architecture")

Solana features a solid design with its PoH consensus model and protocols built for fast transaction throughput.
This architecture also opens for low transaction fees, but questions have been raised about Solana being too centralized.
This comes from Solana having much fewer nodes than Ethereum or Bitcoin.
The reason for this is that Solana’s high transaction volume necessitates significant hardware needs for validators.

In contrast, Chromia stands out for its simplicity, accessibility, and decentralization.
Chromia's consensus mechanism uses Proof of Authority, and becoming a Provider doesn't have the high hardware requirements of
Solana makes the number of providers higher on Chromia and then more decentralized.

Chromia uses Rell, a relational blockchain programming language, deliberately similar to modern programming languages like JavaScript and Kotlin.
This makes it a comfortable platform for developers, especially those transitioning from traditional web development.

This allows for a broader range of developers to create dapps without the steep learning curve
associated with more complex languages like Rust, used in Solana.

### Scalability Considerations [​](\#scalability-considerations "Direct link to Scalability Considerations")

While Solanas's scalability is achieved through Proof of History (PoH) consensus mechanisms and technologies like Gulf Stream and Sealevel, there
have been concerns that it comes at the cost of reduced security. The network's unique consensus mechanism, Proof of History, is still relatively untested compared to more established mechanisms like Proof of Authority or Proof of Stake.
Solana's architecture and technologies can be complex and difficult for new developers to understand and work with, potentially limiting developer adoption.

Chromia, on the other hand, offers a straightforward scalability solution.
Each dapp operates on its own subchain, capable of handling high transaction volumes.
Scalability can be easily managed through resource adjustments, which is very close to cloud services. Making the development and resource management effort more straightforward.
The ability to add subchains enables parallel execution of transactions, which gives the developer full control of scaling.

### Operational costs & fees [​](\#operational-costs--fees-1 "Direct link to Operational costs & fees")

Solanas's dynamic fee model, though innovative, might pose unpredictability in costs for developers and end-users.
Since every transaction sent through the network comes with a fee, although low for Solana, it still limits the way dapp developers can set their
revenue models and user experience.

Chromia, however, offers a fixed, predictable fee for hosting dapps.
This model not only simplifies budgeting for developers but also allows them to craft unique fee structures for end users,
enhancing the user experience.

### Revenue models [​](\#revenue-models-1 "Direct link to Revenue models")

Solana's revenue generation relies on traditional methods like staking and transaction fees.
These mechanisms, while proven, may not offer the flexibility modern dapp developers seek.

Chromia allows developers to choose their revenue models, from subscriptions to feature-based charges or even transaction fees.
This flexibility opens up creative revenue strategies that are more aligned with today's web apps.

### Final words [​](\#final-words "Direct link to Final words")

In summary, while Solana presents a powerful blockchain solution with a very high transaction speed and optimized scalability,
Chromia stands out with its user- and developer-friendly approach, straightforward scalability, and innovative cost and revenue models.
These features make Chromia an appealing choice, especially for those seeking a seamless transition from web2 into the web3 domain.

- [Solana](#solana-1)
- [Comparison](#comparison)
  - [Development](#development)
  - [Scalability](#scalability)
  - [Operational Costs & Fees](#operational-costs--fees)
  - [Revenue models](#revenue-models)
  - [Conclusion and comparison summary to Chromia](#conclusion-and-comparison-summary-to-chromia)
  - [Architecture](#architecture)
  - [Scalability Considerations](#scalability-considerations)
  - [Operational costs & fees](#operational-costs--fees-1)
  - [Revenue models](#revenue-models-1)
  - [Final words](#final-words)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In this lesson, we'll explore how to implement account management functionality using FT4. We'll see how to create operations for registering new accounts and managing account permissions.

## Account authentication [​](\#account-authentication "Direct link to Account authentication")

Authentication handler in main module defines what permissions are required for different operations.

The Open Strategy is used for account registration. The Open Strategy allows anyone to call the `register_account()` operation to create an account without any restrictions. To enable this, we need to import the required module in the main file `import lib.ft4.accounts.strategies.open`, this ensures the Open Strategy is properly integrated into the account registration process.

src/main.rell

```codeBlockLines_e6Vv
module;

import lib.ft4.auth;
import lib.ft4.accounts.strategies.open;
import lib.ft4.core.accounts.{ account, Account, create_account_with_auth, single_sig_auth_descriptor };

@extend(auth.auth_handler)
function () = auth.add_auth_handler(
    flags = ["T"]
);

```

Auth descriptors specify who can access an account and what they are allowed to do. The `T` flag indicates that accounts will have transfer permissions. This is essential for our asset management system. You can learn more about this here: [FT4 accounts overview](https://docs.chromia.com/ft4/accounts/overview). You can learn more about all the available strategies and their implementation methods at the following link: [Account Registration Framework - Chromia Docs](https://docs.chromia.com/ft4/accounts/ft4-register-accounts#account-registration-framework).

- [Account authentication](#account-authentication)[Skip to main content](#__docusaurus_skipToContent_fallback)

## Chatbot Courses

#### Courses that cover Chatbot concepts and implementation.

[Advanced **Create your chat agent with Chromia** \\
Learn to build and experiment with a chat agent on Chromia, focusing on AI and blockchain integration.](/courses/chat-agent-course/introduction)

[AI](/tags/AI) [Chatbot](/tags/Chatbot) [Rell](/tags/Rell)

Start Course[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

This course equips you with **boilerplate code** to build a minimalistic AI-powered chat agent on Chromia. The goal is to give you a solid foundation that you can tinker with, allowing you to experiment with different agent strategies, memory management, and AI model integrations.

# What is Chromia?

Chromia is a **Relational Blockchain** that combines the capabilities of relational databases with blockchain technology, streamlining the process of building decentralized applications (dapps). With Chromia, you can develop dapps in a familiar way, regardless of whether your background is in enterprise or gaming.

A standout feature of Chromia is **Rell**, a powerful and concise blockchain and database language. Rell simplifies dapp development by enabling you to create efficient, secure, and expressive applications with minimal code while retaining the flexibility of relational databases.

To explore Chromia and its features, check out the [Chromia overview](https://docs.chromia.com).

### About the dapp [​](\#about-the-dapp "Direct link to About the dapp")

In this course, you will start with a boilerplate chat agent powered by an AI model. This agent is designed to store and retrieve context using short-term and long-term memory, providing dynamic, context-aware conversations.

You'll have the opportunity to experiment with AI strategies, fine-tune memory management, and switch between various AI models (like Groq and OpenAI) to customize the agent's behavior.

Below is a demonstration of the chat agent in action:

### What will I learn? [​](\#what-will-i-learn "Direct link to What will I learn?")

By completing this course, you’ll gain practical experience in:

- **Setting up and running a Chromia-based dapp.**
- **Exploring memory management strategies** to enhance contextual accuracy.
- **Integrating multiple AI models** and customizing agent responses.
- **Using Rell for backend operations**, including queries and transactions.
- Adapting the chat agent to suit unique requirements or projects.

The result will be a fully functional boilerplate you can extend and modify to create a personalized, interactive chatbot dapp.

## Repository link [​](\#repository-link "Direct link to Repository link")

Find the complete code repository for this course here:
[Chat agent course repository](https://bitbucket.org/chromawallet/chat-agent-course).

- [About the dapp](#about-the-dapp)
- [What will I learn?](#what-will-i-learn)
- [Repository link](#repository-link)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Let's explore how transactions are stored and how the state is managed on Chromia. To illustrate this, let's refer back
to the diagram from Lesson 1 that showed the flow of a `create_book` transaction:

TransactionBlockchain transactionsDapp table stateRellChromia NodeUserBlockchain transactionsDapp table stateRellChromia NodeUserArgs: Title, Author, ISBNTransaction confirmed or rejectedSigns operation/transaction 'create\_book'Validates transaction to add new book dataApplies transaction "tx create\_book isbn, title, author"Calls to update the state of the operationInserts book in tableConfirms book transaction committed

- User signs transaction `create_book("ISBN1234", "1984", "George Orwell")`.
- The transaction is sent to Chromia Node, where it is validated and then sent to the blockchain.
- Inside the operation, the `create book(isbn = isbn, title = title, author = author);` is applied to the dapp table
state using Rell.
- If the transaction is confirmed, it is added to a block on the blockchain, and the dapp table state is updated.

This diagram demonstrates how a transaction is stored on the blockchain and how the state is updated from the operation
within the transaction. Let's dive into this process's details and better understand the difference between the
blockchain and the state.

We start by making a query fetching the state using the query `get_all_books`.

## Query state for all books [​](\#query-state-for-all-books "Direct link to Query state for all books")

When we execute a query like `get_all_books`, we only interact with the dapp table state. This makes sense because we
want to fetch the current state of the books. Here's the flow for this query:

Dapp table stateRellChromia NodeUserDapp table stateRellChromia NodeUserQuery 'get\_all\_books'Query RellQuery for all booksExecute queryReturn results for all booksReturn results for all books

In this sequence:

- The user queries Chromia Node for all books.
- Chromia Node forwards the query to Rell.
- Rell performs a query on the state to fetch all books.
- The state executes the query and returns the result to Rell.
- Rell provides the user with the result containing all books from the state.

Now, let's move on to querying the blockchain for all transactions.

* * *

## Query blockchain for transactions [​](\#query-blockchain-for-transactions "Direct link to Query blockchain for transactions")

The next part is to show how we can query the blockchain and fetch all transactions that have led up to the current dapp
table state.

We can do this by defining the necessary data structures and queries.

### Define Data Structures [​](\#define-data-structures "Direct link to Define Data Structures")

Add the following model to your `src/main/entities.rell` file. These are predefined Rell data structures for
transactions on Chromia:

src/main/entities.rell

```codeBlockLines_e6Vv
struct tx_op {
  op_name: text;
  op_args: list<gtv>;
}

struct tx_body {
  tx_rid: byte_array;
  ops: list<tx_op>;
  signers: list<byte_array>;
}

struct tx {
  tx_body;
  signatures: list<byte_array>;
}

```

### Add Query [​](\#add-query "Direct link to Add Query")

With these models defined, add the following query to your `src/main/queries.rell` file. This query will fetch all
transactions from the blockchain:

src/main/queries.rell

```codeBlockLines_e6Vv
query get_transactions() {
  val txs = transaction @* { } ( gtv.from_bytes(.tx_data) );
  return list<tx>.from_gtv(txs.to_gtv());
}

```

This concludes our definitions for querying transactions. In the next lesson, we will look at how to use these queries
in practice.

- [Query state for all books](#query-state-for-all-books)
- [Query blockchain for transactions](#query-blockchain-for-transactions)
  - [Define Data Structures](#define-data-structures)
  - [Add Query](#add-query)[Skip to main content](#__docusaurus_skipToContent_fallback)

In this lesson, you'll define the `book_review` entity, allowing you to record and connect book reviews to the book entity.

In the next section, you'll add an operation to create new book reviews. This operation will use the ISBN to link each review to a specific book.

Finally, you'll learn how to write a query to retrieve all reviews associated with a particular book, using the ISBN as a reference.

## Sections

[Define the book review entity](/courses/book-review/book-review-entity/tables)

[Add operation to create a book review](/courses/book-review/book-review-entity/basic-operations)

[Write a query to retrieve all reviews of a book](/courses/book-review/book-review-entity/write-queries)

[Start lesson »](/courses/book-review/book-review-entity/tables)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Let's start with a quick overview of Polygon, and then we will continue with comparing Polygon to Chromia and also discuss the benefits and challenges
with the two solutions.

## Polygon [​](\#polygon-1 "Direct link to Polygon")

**Tech and Architecture**

- Polygon, formerly known as Matic Network, is a platform that provides a suite of solutions for scaling Ethereum. It aims to address the challenges of Ethereum, such as its high transaction fees and low throughput, by providing various scaling options. Polygon's core component is Polygon SDK, a modular, flexible framework that supports building multiple types of applications.
- Polygon's architecture consists of three main layers:
  - The Ethereum Layer: This layer is the foundation of Polygon and is responsible for securing transactions and maintaining the state of the network.
  - The Bor Layer: This layer processes transactions and produces blocks.
  - The Heimdall Layer: Handles consensus and validator coordination, overseeing block production in the Bor layer and managing checkpointing to the Ethereum main chain.

**Scalability**

- Polygon employs a hybrid scaling approach, combining sidechains, ZK-Rollups, and optimistic rollups to achieve exceptional scalability.
- Sidechains offload transactions, ZK-Rollups compress data, and optimistic rollups provide flexibility.
- These techniques enables Polygon to handle massive transactions while maintaining cost-effectiveness and security.

**Development tools**

- Developers on Polygon have the flexibility to use various programming languages, including Solidity, the primary language for Ethereum smart contracts. This compatibility allows Ethereum developers to port their applications to Polygon easily.
- Polygon provides various development tools, including its software development kit (SDK), to make the creation of decentralized applications (dapps) simpler.
- With a focus on Ethereum compatibility, developers can leverage existing Ethereum tools and libraries when building on Polygon.
- Polygon offers libraries like Web3.js, Ethers.js, Alchemy, and InfStones, as well as extensive documentation, tutorials, and community forums to support developers.

**Fee structure**

- Polygon dynamically adjusts transaction fees based on network congestion, ensuring affordability during low activity and discouraging excessive volume during peaks. This approach balances cost-effectiveness with network efficiency.

## Comparison [​](\#comparison "Direct link to Comparison")

### Development [​](\#development "Direct link to Development")

Polygon

- Solidity is the primary programming language for Polygon development, as it is the native language of the Ethereum Virtual Machine (EVM). Solidity's familiarity and compatibility with Ethereum tools and resources make it a popular choice for Polygon developers.
- Polygon offers a comprehensive suite of development tools and frameworks, including:
  - Polygon Chain Development Kit (CDK), a framework for building Ethereum Layer 2s using ZK technology.
  - Polygon Edge, a framework for developing private and permissioned blockchains.
  - Polygon ID, a decentralized identity solution.

Chromia

- Chromia uses Rell, a relational blockchain programming language. Rell can be a more user-friendly language than Go or Rust, making it easier for developers to build dapps on Chromia.
- Development on Chromia using Rell is very similar to Web2 development. For more insights on this, check out our guide [here](https://docs.chromia.com/category/rell-language).
- Chromia provides tools and libraries to simplify authentication, transaction signing, and asset management, and new features are added to support rapid dapp development.
- Chromia's development environment has support for testing using its own test framework and simple deployment using developer-friendly tools.

### Scalability [​](\#scalability "Direct link to Scalability")

Polygon

- Polygon tackles Ethereum's scalability issues with a multi-layered architecture, combining sidechains, ZK-Rollups, and optimistic rollups. Each technology plays a specific role in boosting transaction
throughput and reducing network congestion, enabling Polygon to support to a wide range of use cases and transaction volumes.
- Sidechains are parallel blockchains linked to the Ethereum mainnet, offloading transactions and easing congestion.
- ZK-Rollups use special cryptographic methods to combine many transactions into one compact proof. This cryptographic compression allows for the efficient submission of transactions to the Ethereum mainnet.
- Polygon has an advanced architecture with many components. You can read more [here](https://wiki.polygon.technology/docs/pos/polygon-architecture/).

Chromia

- Chromia's approach is that every dapp on Chromia operates on a unique subchain. Each subchain can handle hundreds of transactions every second.
If a dapp witnesses growth, it can with ease be expanded by adding more chains.
This structure guarantees sustained high throughput and a predictable way of scaling your dapp, much like in a traditional cloud environment.

Since every subchain is isolated from other subchains, this means that they can process transactions in parallel, in essence scaling horizontally
and only your app architecture sets the limit for scalability.

Chromias sidechain architecture is built into the platform, making it a low effort for developers to utilize this approach of side chains.


### Operational Costs & Fees [​](\#operational-costs--fees "Direct link to Operational Costs & Fees")

Polygon

- Polygon has a flexible fee model that changes transaction costs depending on how busy the network is. This makes transactions affordable when the network is not busy and helps avoid too much traffic when it's busy. The fees are made up of:
  - Base Fee: This fee changes with network traffic. It goes up when the network is congested and down when it's not very busy.
  - Priority Fee (Tip): Users can pay an extra fee to get their transactions processed faster.
  - Transaction Complexity: Transactions that are more complex and use more computer power, like those with smart contracts, cost more.
  - Market Conditions: The price of MATIC also affects fees. Higher demand for MATIC can lead to higher fees.

Chromia

- Chromia changes the game by allowing developers to host their decentralized app (dapp) in a container for a fixed, predictable fee.
- This transparency means developers know how much their operational costs are each month, and they can create their end-user fee structures to cover these operating expenses. So, instead of being charged gas fees for every action, there's a single, more manageable cost to work with.
- As a Chromia dapp grows in usage, the developer of the dapp can increase the resources of their container. It is very similar to how you manage resources in a Cloud environment.

### Revenue models [​](\#revenue-models "Direct link to Revenue models")

Polygon

- On Polygon revenues are generated through transaction fees. These fees are paid by users when they execute transactions on the network.
- Polygon offers other revenue-generating opportunities for developers, such as subscription fees, advertising, in-app purchases, and tokenization. These can be built into the dapp, but the end-user will always have to pay
a transaction fee on top of the revenue-model choosen.

Chromia

- Operational costs of dapps are fixed and predictable on Chromia; The dapp developer can choose which fee model they want to use for their end-users.
- With Chromia, you are not locked in by transactions and gas fees. For your dapp, you can have a monthly subscription fee, charge for single features, or, if you want, per transaction. This opens up a more user-friendly experience since you can even let the user start for free and then open up for revenues later when the user has found the value of your dapp. This is a common practice in traditional web applications, and it should be no different for Web3.

### Conclusion and comparison summary to Chromia [​](\#conclusion-and-comparison-summary-to-chromia "Direct link to Conclusion and comparison summary to Chromia")

Polygon and Chromia are well-architectured to handle common issues with traditional blockchain platforms.

Let's summarize and discuss the benefits and challenges.

### Architecture [​](\#architecture "Direct link to Architecture")

Polygon features a multi-layered architecture with sidechains, ZK-Rollups, and optimistic rollups. This approach enables Polygon to achieve exceptional scalability, surpassing the limitations of Ethereum and positioning it as a viable solution for large-scale blockchain applications. However, the complexity of this architecture may pose challenges for new developers.

In contrast, Chromia stands out for its simplicity, accessibility, and decentralization. Chromia's consensus mechanism uses Proof of Authority, and becoming a Provider doesn't have Polygon's high hardware requirements, making the number of Providers higher on Chromia and more decentralized.

Chromia uses Rell, a relational blockchain programming language, deliberately similar to modern programming languages like JavaScript and Kotlin.
This makes it a comfortable platform for developers and allows a broader range of developers to create dapps without the steep learning curve associated with more complex languages like Solidity, which is used in Polygon.

### Scalability Considerations [​](\#scalability-considerations "Direct link to Scalability Considerations")

Polygon overcomes Ethereum's scalability limitations through a multi-layered architecture that combines sidechains, ZK-Rollups, and optimistic rollups. This approach enables Polygon to process massive transactions efficiently while maintaining low fees and fast confirmation times.

Sidechains are parallel blockchains connected to the Ethereum mainnet, offloading transactions and reducing congestion. ZK-Rollups compress multiple transactions into a single proof for efficient submission to the Ethereum mainnet. Optimistic rollups provide flexibility and reduce computational overhead.

Polygon's multi-layered architecture and integration of multiple scaling technologies can be complex for new developers to understand and implement. This complexity may hinder the adoption of Polygon by a broader range of developers.

Chromia, on the other hand, offers a straightforward scalability solution. Each dapp operates on its own subchain, capable of handling high transaction volumes.

Scalability can be easily managed through resource adjustments, which is very close to cloud services—making the development and resource management effort more straightforward. The ability to add subchains enables parallel execution of transactions, which gives the developer complete control of scaling.

### Operational costs & fees [​](\#operational-costs--fees-1 "Direct link to Operational costs & fees")

Polygon's dynamic fee model can lead to unpredictable developer and end-user costs. During periods of high network congestion, transaction fees can surge, making it difficult for developers to budget and for end-users to estimate transaction costs accurately. This unpredictability can make it challenging for developers to plan their revenue models and can create friction for end-users.

High fees during periods of network congestion can lead to user frustration and discourage usage. While Polygon's dynamic fee model aims to balance affordability and efficiency, it may only sometimes provide the ideal user experience, especially for price-sensitive users. Developers may hesitate to build on Polygon if they cannot accurately predict operational costs or if their fee models create friction for users.

Chromia, however, offers a fixed, predictable fee for hosting dapps. This model not only simplifies budgeting for developers but also allows them to craft unique fee structures for end-users, enhancing the user experience.

### Revenue models [​](\#revenue-models-1 "Direct link to Revenue models")

Developers relying on transaction fees as their primary revenue stream may face volatility due to the dynamic nature of Polygon's fee model. Fluctuating fees can make it difficult to predict revenue and plan for the future, potentially affecting the long-term sustainability of dapps.

Chromia allows developers to choose revenue models, from subscriptions to feature-based charges or transaction fees. This flexibility makes creative revenue strategies more aligned with today's web apps.

### Final words [​](\#final-words "Direct link to Final words")

In summary, while Polygon enhances Ethereum's scalability and compatibility with Ethereum developers, Chromia stands out with its user- and developer-friendly approach, straightforward scalability, and innovative cost and revenue models.

These features make Chromia appealing, especially for those seeking a seamless transition from web2 into the web3 domain.

- [Polygon](#polygon-1)
- [Comparison](#comparison)
  - [Development](#development)
  - [Scalability](#scalability)
  - [Operational Costs & Fees](#operational-costs--fees)
  - [Revenue models](#revenue-models)
  - [Conclusion and comparison summary to Chromia](#conclusion-and-comparison-summary-to-chromia)
  - [Architecture](#architecture)
  - [Scalability Considerations](#scalability-considerations)
  - [Operational costs & fees](#operational-costs--fees-1)
  - [Revenue models](#revenue-models-1)
  - [Final words](#final-words)[Skip to main content](#__docusaurus_skipToContent_fallback)

## React Courses

#### Courses that cover React concepts and implementations.

[Intermediate **Create a simple app on Chromia using Rell and React** \\
Build a decentralized news feed app and learn about database design and MetaMask integration.](/courses/my-news-feed/introduction)

[Rell](/tags/Rell) [React](/tags/React) [MetaMask](/tags/MetaMask) [FT4](/tags/FT4)

Start Course[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Now that we have two entities in our model, we need to add a mechanism for creating a new entry for a book review. To
achieve this, we will define an operation to create a new book review.

Open the file `src/main/operations.rell` and add the following Rell code:

src/main/operations.rell

```codeBlockLines_e6Vv
operation create_book_review(isbn: text, reviewer_name: text, review: text, rating: integer) {
  val book = book @ { .isbn ==  isbn };
  create book_review (
    book,
    reviewer_name,
    review,
    rating
  );
}

```

This operation is similar to the `create_book` operation, but for this operation, we need to establish a connection
between the review and the book. In our example, the key for a book is the `isbn`, so we will use this to associate the
review with a specific book.

### Inside the operation [​](\#inside-the-operation "Direct link to Inside the operation")

We're sending the operation to create a book review to a Chromia node, which will generate a new transaction and persist
the data in the dapp table state, as illustrated below.

signs transaction

Update

Update

User

create\_book\_review: isbn, reviewer\_name, review, rating

Chromia Node

Blockchain

tx create\_book\_review ISBN1234, Alice, It was a good book, 5

dapp table state

\\nBook table: isbn = 1234, title = 1984, author = George Orwell\\n\\n\\nBook\_review table: book: isbn = ISBN1234, Alice, It was a good book, 5\\n\\n

- A user signs the transaction `create_book_review("ISBN1234", "Alice", "It was a great book!", 5)`.
- The transaction is sent to the Chromia Node, where it undergoes validation and is subsequently forwarded to the
blockchain.
- Inside the operation:

```codeBlockLines_e6Vv
  val book = book @ { .isbn ==  isbn };
  create book_review (
    book,
    reviewer_name,
    review,
    rating
  );

```

The book is queried from the dapp table state, and then a new row is created for the `book_review` with a relationship
to the book.

- If the transaction is confirmed, it is added to a block on the blockchain, and the dapp table state is updated
accordingly.

TransactionBlockchain transactionsDapp table stateRellChromia NodeUserBlockchain transactionsDapp table stateRellChromia NodeUserArgs: ISBN, Reviewer Name, Review, RatingTransaction added to blockchain & Book review data in Table/StateSigns operation/transaction 'create\_book\_review'Validates transaction to add new book review dataAttempt to apply transaction "tx create\_book\_review isbn, reviewer\_name..."Call to update state from operationQuery for book @ { isbn = isbn }Result from book queryConnect book to book\_reviewinsert book\_review in tableConfirm book review transaction committed

## Add unit tests [​](\#add-unit-tests "Direct link to Add unit tests")

Let's incorporate another test to ensure our book review operations function as expected. In Rell, we can use test
modules to create our tests, which is relatively straightforward.

Open the `src/test/book_review_test.rell` file and update the imports to include `book_review` and `create_book_review`:

src/test/book\_review\_test.rell

```codeBlockLines_e6Vv
import main.{ book, create_book, get_all_books, book_review, create_book_review };

```

After updating the imports, add the following test code to the same file:

src/test/book\_review\_test.rell

```codeBlockLines_e6Vv
function test_add_book_review() {
    rell.test.tx()
        .op(create_book("123", "Book1", "Author1"))
        .op(create_book_review("123", "Reviewer1", "ReviewText1", 5))
        .op(create_book_review("123", "Reviewer2", "ReviewText2", 3))
        .run();

    val reviews = book_review @* { };
    val book = book @ { .isbn == "123" };

    assert_equals(reviews.size(), 2);
    assert_equals(book, reviews[0].book);
    assert_equals(reviews[0].reviewer_name, "Reviewer1");
    assert_equals(reviews[0].review, "ReviewText1");
    assert_equals(reviews[0].rating, 5);
}

```

This code executes a transaction with three operations. First, we create a book, then two reviews, and connect them to
the book we created.

- `assert_equals(reviews.size(), 2);` checks that we have two entries.
- `assert_equals(book, reviews[0].book);` ensures that the correct book is connected to the review.
- `assert_equals(reviews[0].reviewer_name, "Reviewer1")` confirms the reviewer's name.
- `assert_equals(reviews[0].review, "ReviewText1")` checks the review text.
- `assert_equals(reviews[0].rating, 5)` verifies the rating.

After setting up the tests, we can run them:

```codeBlockLines_e6Vv
chr test

```

After running the test, you should see the test results indicating that all tests have passed:

```codeBlockLines_e6Vv
TEST RESULTS:

OK test.book_review_test:test_add_book
OK test.book_review_test:test_get_books
OK test.book_review_test:test_add_book_review

SUMMARY: 0 FAILED / 3 PASSED / 3 TOTAL

***** OK *****

```

## Test it with a local Chromia node [​](\#test-it-with-a-local-chromia-node "Direct link to Test it with a local Chromia node")

To validate our newly created operation on a local Chromia node, follow these steps:

1. **Update or start the local Chromia node:**


   - **If the node is already running**, use the following command to update it:





     ```codeBlockLines_e6Vv
     chr node update

     ```

   - **If the node is not already running**, start it with:





     ```codeBlockLines_e6Vv
     chr node start

     ```


**Note:** After running `chr node update`, it might take a moment for the update to be reflected. You may need to
wait for the next block to be processed before the query becomes available.

2. **Create a transaction to add a book review:**





```codeBlockLines_e6Vv
chr tx --await create_book_review "ISBN1234" "Alice" "It was a great book" 5

```









The expected result should be:





```codeBlockLines_e6Vv
transaction with rid TxRid(rid=<RID>) was posted CONFIRMED

```


This confirms that the transaction was added to the blockchain, and the state now contains a row with the book review
data.

- [Inside the operation](#inside-the-operation)
- [Add unit tests](#add-unit-tests)
- [Test it with a local Chromia node](#test-it-with-a-local-chromia-node)[Skip to main content](#__docusaurus_skipToContent_fallback)

This guide explores the transition from developing on EVM-based blockchains with Solidity to building decentralized
applications (dapps) on the Chromia blockchain using its language, Rell. We will delve into the architecture of the
Chromia platform and examine code examples to understand how familiar concepts from Solidity development translate to
dapp development on Chromia.

You will learn about the key features and advantages of Chromia, such as its relational blockchain model and how it
differs from traditional EVM-based chains. Additionally, we will provide practical insights into setting up your
development environment, deploying contracts, and integrating with existing Chromia tools and services.

This course assumes you have experience with EVM blockchain development and Solidity, and will focus on the transition
to Chromia. By the end of this guide, you should have a solid understanding of how to leverage Rell for your next dapp
project on Chromia.[Skip to main content](#__docusaurus_skipToContent_fallback)

## FT4 Courses

#### Courses that cover FT4 concepts and implementation.

[Advanced **Build a decentralized marketplace using FT4** \\
Learn to create a marketplace dapp with NFT and token transfers.](/courses/marketplace-course/introduction)

[FT4](/tags/FT4) [Token](/tags/Token) [NFT](/tags/NFT) [Rell](/tags/Rell)

Start Course [Advanced **Monetize your dapp** \\
Explore strategies for monetizing your dapp.](/courses/monetize-dapp/introduction)

[Rell](/tags/Rell) [Multichain](/tags/Multichain) [Dapp](/tags/Dapp) [FT4](/tags/FT4)

Start Course[Skip to main content](#__docusaurus_skipToContent_fallback)

## Chromia Concepts Courses

#### Explore courses that cover key concepts of Chromia.

[Beginner **Write your first dapp on Chromia** \\
Develop a simple book review dapp while learning Chromia's core concepts and Rell.](/courses/book-review/introduction)

[Concepts](/tags/Concepts) [Rell](/tags/Rell)

Start Course [Beginner **Web3 for Web2 developers** \\
Transition smoothly from Web2 to Web3 development, tailored for web developers.](/courses/web3-for-web2-devs/introduction)

[Concepts](/tags/Concepts) [Web3](/tags/Web3)

Start Course [Beginner **Chromia for EVM developers** \\
A guide for EVM developers to explore Chromia with hands-on examples.](/courses/chromia-for-evm-developers/introduction)

[Concepts](/tags/Concepts) [Rell](/tags/Rell) [Dapp](/tags/Dapp)

Start Course[Skip to main content](#__docusaurus_skipToContent_fallback)

In this lesson, you'll learn how Chromia manages transactions and states. You'll explore how user-signed transactions are validated, applied to the dapp table state, and committed to the blockchain.

You'll also learn how to query the current state of your dapp and how to query the blockchain for all transactions to see the relationship between blockchain transactions and the dapp table state.

Finally, you'll see an example of updating a book's title and how these changes affect both the blockchain and the state.

## Sections

[Understanding blockchain state and transactions](/courses/book-review/blockchain-transactions/query-transaction)

[Let's look at an example](/courses/book-review/blockchain-transactions/example)

[Start lesson »](/courses/book-review/blockchain-transactions/query-transaction)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Congratulations on completing the setup and testing your chat agent! It’s time to dive deeper into the code and experiment with its features. This course provides a functional boilerplate to explore memory handling and strategies for enhancing chat interactions.

## Explore the codebase [​](\#explore-the-codebase "Direct link to Explore the codebase")

The project is structured to give you a solid foundation for experimenting with Chromia-based memory storage and retrieval. Here are some starting points:

### Memory strategies [​](\#memory-strategies "Direct link to Memory strategies")

- **Short-term memory**: Examine how recent interactions store and retrieve data. Consider scenarios where you might need to adjust the amount of information in short-term memory.
- **Long-term memory**: Discover how the system preserves significant memories over sessions. Experiment with the criteria for transferring short-term memories to long-term memory.

### Agent behavior [​](\#agent-behavior "Direct link to Agent behavior")

- Investigate how the agent generates responses using stored memories. Tweak the way the agent utilizes these memories to enhance context-rich responses.

### Try custom scenarios [​](\#try-custom-scenarios "Direct link to Try custom scenarios")

- Modify the prompts or objectives associated with the agent to observe how it affects its behaviour.
- Introduce additional memory fields or logs to capture specific interactions or metadata.

## Suggested experiments [​](\#suggested-experiments "Direct link to Suggested experiments")

Here are a few ideas to kickstart your experimentation:

1. **Customize memory limits**

Please adjust the number of short-term memories stored and see how it impacts the interaction flow. For instance, consider changing the logic to retain only the last five interactions instead of ten.

2. **Change memory utilization**

Experiment with how long-term memories summarize and update. Explore what happens if you increase the update frequency or alter the stored content.

3. **Analyze agent logs**

Dive into the `LLM_LOG` table to evaluate how requests and responses log. Analyze the data to gain insights into optimizing memory retrieval and response generation.


## Take it further [​](\#take-it-further "Direct link to Take it further")

Feel free to experiment beyond the initial setup:

- **Modify the backend**: Adjust the database schema or Rell operations to meet specific project needs.
- **Integrate new features**: Enhance the agent’s capabilities by integrating new APIs or adding tools.
- **Refactor memory strategies**: Implement advanced memory cleanup, prioritization, or tagging strategies to improve performance.

## Need an overview? [​](\#need-an-overview "Direct link to Need an overview?")

If you need a refresher on how the project works, check out the [README in the repository](https://bitbucket.org/chromawallet/chat-agent-course/src/main/) for diagrams and a high-level explanation.

This is your playground—experiment, break things, and rebuild! The possibilities are endless when you work with Chromia’s relational blockchain and memory-centric chat agents.

- [Explore the codebase](#explore-the-codebase)
  - [Memory strategies](#memory-strategies)
  - [Agent behavior](#agent-behavior)
  - [Try custom scenarios](#try-custom-scenarios)
- [Suggested experiments](#suggested-experiments)
- [Take it further](#take-it-further)
- [Need an overview?](#need-an-overview)[Skip to main content](#__docusaurus_skipToContent_fallback)

Now that we're all set up let's add a couple of transactions and then query both the state and transactions to see how
they interact.

First, let's clear all data from our node to start with a fresh slate. Before running the command, if the Chromia Node
is running, stop it with `Ctrl+C`. Then, you can clear the data by running the following command:

```codeBlockLines_e6Vv
chr node start --wipe

```

This command will clear all transactions from the blockchain and reset the current table/state. You can verify this by
running:

```codeBlockLines_e6Vv
chr query get_all_books

```

This should return an empty array, indicating no books in the current state.

Now, let's add a new transaction to create a book, intentionally misspelling "Chromia" to later correct this with an
update:

```codeBlockLines_e6Vv
chr tx create_book --secret .chromia/config "ISBN001" "Crhomia 101" "Alice" --await

```

The output should look like this:

```codeBlockLines_e6Vv
transaction with rid DF94A07EACBA673CC4ECA4A43D70CDA4FD30E4335E124B7153FB12A78FDD8CE9 was posted CONFIRMED

```

After running this transaction, you can query for all books using the `get_all_books` query:

```codeBlockLines_e6Vv
chr query get_all_books

```

The result should look like this:

```codeBlockLines_e6Vv
[\
  {\
    "author": "Alice",\
    "isbn": "ISBN001",\
    "title": "Crhomia 101"\
  }\
]

```

This confirms that the state/table has been correctly updated with the new book information. Now, let's query the
blockchain transactions:

```codeBlockLines_e6Vv
chr query get_transactions

```

which will give us the following result:

```codeBlockLines_e6Vv
[\
  {\
    "signatures": [x"DB12DCDC62F8FB231C3CC7545AB5738C02E0CE29D912D07AAB865565B94324311D24BC1855FDB82446DCE92B9BC9F457DB2B471EDD71EBB2BE3A4A611C3E77EC"],\
    "tx_body": {\
      "ops": [\
        {\
          "op_args": ["ISBN001", "Crhomia 101", "Alice"],\
          "op_name": "create_book"\
        }\
      ],\
      "signers": [x"02465E21B4297E2F665E39E44F5575DFDF03F542CE9252E22972CFF957E7ACFC1C"],\
      "tx_rid": x"B9BC06E8B8AAA65BDC4EE0A42EC01BAF92937E1FA8AF43C81031F3FCDFA8DF4B"\
    }\
  }\
]

```

This indicates that the transaction has been successfully added to the blockchain, and the state has been updated
accordingly.

This diagram illustrates what happens when we run `query get_transactions`:

BlockchainChromia NodeUserBlockchainChromia NodeUserQuery 'get\_transactions'Query all transactionsExecute queryReturn all transactionsReturn all transactions

Let's continue with the next step by adding a new operation to update a book's title. This will allow us to correct the
misspelt title for our book. We first need to make the title mutable so that it can be updated. This is simple; we just
change the attribute of the title to mutable in our book entity:

src/main/entities.rell

```codeBlockLines_e6Vv
entity book {
  key isbn: text;
  mutable title: text;
  author: text;
}

```

Then we can add the update operation:

src/main/operations.rell

```codeBlockLines_e6Vv
operation update_book(isbn: text, title: text){
  val adminPubkey = chain_context.args.admin_pubkey;
  require(op_context.is_signer(adminPubkey), "Only admin can update books");

  update book @ { .isbn == isbn }( .title = title );
}

```

Before testing this new operation, update the Chromia Node to make sure it includes the new operation. Run the following
command and wait for the next block to ensure the operation is available:

```codeBlockLines_e6Vv
chr node update

```

After updating, let's test the new operation with a transaction where we update a book's title:

```codeBlockLines_e6Vv
chr tx update_book --secret .chromia/config "ISBN001" "Chromia 101" --await

```

After this transaction, we can query both the blockchain transactions and the state again:

```codeBlockLines_e6Vv
chr query get_all_books

```

The result will now show the updated title:

```codeBlockLines_e6Vv
[\
  {\
    "author": "Alice",\
    "isbn": "ISBN001",\
    "title": "Chromia 101"\
  }\
]

```

Similarly, when querying the blockchain transactions:

```codeBlockLines_e6Vv
chr query get_transactions

```

The result will be as follows:

```codeBlockLines_e6Vv
[\
  {\
    "signatures": [x"DB12DCDC62F8FB231C3CC7545AB5738C02E0CE29D912D07AAB865565B94324311D24BC1855FDB82446DCE92B9BC9F457DB2B471EDD71EBB2BE3A4A611C3E77EC"],\
    "tx_body": {\
      "ops": [\
        {\
          "op_args": ["ISBN001", "Crhomia 101", "Alice"],\
          "op_name": "create_book"\
        }\
      ],\
      "signers": [x"02465E21B4297E2F665E39E44F5575DFDF03F542CE9252E22972CFF957E7ACFC1C"],\
      "tx_rid": x"B9BC06E8B8AAA65BDC4EE0A42EC01BAF92937E1FA8AF43C81031F3FCDFA8DF4B"\
    }\
  },\
  {\
    "signatures": [x"16EE4BA637E5D49FAAF1E3B6A78FA8AF63793AC92784914FC1890A54FC3365294F3FD5EC73AB9159EA61F9F8F1AE2650E0326C3B7A94739CDC0362212B731909"],\
    "tx_body": {\
      "ops": [\
        {\
          "op_args": ["ISBN001", "Chromia 101"],\
          "op_name": "update_book"\
        }\
      ],\
      "signers": [x"02465E21B4297E2F665E39E44F5575DFDF03F542CE9252E22972CFF957E7ACFC1C"],\
      "tx_rid": x"B9BC06E8B8AAA65BDC4EE0A42EC01BAF92937E1FA8AF43C81031F3FCDFA8DF4B"\
        }\
  }\
]

```

You'll see that there are two transactions on the blockchain — one to create the book and another to update its title.

If we look at the state, it now represents the two transactions aggregated. So, this state is all the transactions for
this book combined, meaning that we can always go back in history and track exactly how the current state was built.

Understanding this interaction between Rell, Chromia, the blockchain, and the state is crucial for effectively building
and managing decentralized applications.[Skip to main content](#__docusaurus_skipToContent_fallback)

## MetaMask Courses

#### Courses that cover integration with MetaMask.

[Intermediate **Create a simple app on Chromia using Rell and React** \\
Build a decentralized news feed app and learn about MetaMask integration.](/courses/my-news-feed/introduction)

[Rell](/tags/Rell) [React](/tags/React) [MetaMask](/tags/MetaMask) [FT4](/tags/FT4)

Start Course[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In this lesson, we'll explore asset registration and minting functionality. Our system allows each account to register one digital asset and mint an initial supply.

## Asset Registration Operation [​](\#asset-registration-operation "Direct link to Asset Registration Operation")

Here's our operation for registering and minting new assets:

src/main.rell

```codeBlockLines_e6Vv
import lib.ft4.external.assets.{ get_asset_balances };
import lib.ft4.assets.{ asset, Unsafe, balance };

operation register_and_mint_asset(
    asset_name: text,
    symbol: text,
    decimals: integer,
    amount: big_integer,
    icon_url: text
) {
    val owner_account = auth.authenticate();
    require(get_asset_balances(owner_account.id, 10, null).data.empty(), "One asset allowed");
    functions.register_and_mint_asset(owner_account, asset_name, symbol, decimals, amount, icon_url);
}

```

The key features of this operation:

- Authenticates the account owner
- Ensures one asset per account limit
- Registers the asset and mints initial supply

The actual registration and minting logic is handled in the functions [namespace](https://docs.chromia.com/rell/language-features/modules/namespace):

src/main.rell

```codeBlockLines_e6Vv
namespace functions {
    function register_and_mint_asset(
        owner_account: account,
        asset_name: name,
        symbol: text,
        decimals: integer,
        amount: big_integer,
        icon_url: text
    ) {
        // Derive asset ID
        val asset_id = (asset_name, chain_context.blockchain_rid).hash();

        // Check if asset exists
        val asset = asset @ ? { .id == asset_id };
        if (not empty(asset)) return;

        // Register and mint
        val asset_created = Unsafe.register_asset(asset_name, symbol, decimals, chain_context.blockchain_rid, icon_url);
        Unsafe.mint(owner_account, asset_created, amount);
    }
}

```

This implementation:

1. Generates a unique asset ID
2. Checks for existing assets
3. Registers the new asset
4. Mints the initial supply to the owner's account

- [Asset Registration Operation](#asset-registration-operation)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

This course, tailored for both Web2 and Web3 developers, introduces the fundamentals of entity creation, operations, and
queries in Rell. This course aims to help you get started with Chromia and develop the dapp BookView, a book review app allowing users to post book reviews effortlessly.

# What's Chromia?

Chromia is a Relational Blockchain fusing a relational database with blockchain capabilities. With Chromia, dapps can be
crafted in a manner familiar to developers across various backgrounds, from enterprise applications to games and smaller
projects.

A distinctive feature of Chromia is Rell, a specialized blockchain and database language. Rell provides static typing,
increased expressiveness, enhanced database security, and requires up to 10x fewer lines of code than other blockchains.

To delve deeper into Chromia and its architecture, click on
[Chromia overview](https://docs.chromia.com).

## About the dapp [​](\#about-the-dapp "Direct link to About the dapp")

We will build a book review app where users can create books and book reviews and add ratings. This course will also explore various methods for refining and filtering reviews based on specific criteria.

## What will I learn? [​](\#what-will-i-learn "Direct link to What will I learn?")

By the conclusion of this course, you will have acquired the following skills:

- Define entities and establish their relationships.
- Retrieving data using queries while skillfully applying filters.
- Gain the knowledge of basic validation to secure your app.
- Learn to sign and commit transactions using cryptographic signatures.

The outcome will be a fully operational dapp where users can add books, compose reviews, and fetch reviews based on
personalized filters – all powered by Rell and the Chromia blockchain.

## Repository link [​](\#repository-link "Direct link to Repository link")

The complete code repository for this course is available here:
[Book review course repository](https://bitbucket.org/chromawallet/book-course).

- [About the dapp](#about-the-dapp)
- [What will I learn?](#what-will-i-learn)
- [Repository link](#repository-link)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In this tutorial section, we'll explore how to create structured queries in Rell to filter and sort data efficiently,
enhancing the user experience. Rell's relational expressions follow a consistent pattern, making data retrieval
straightforward and coherent.

A structured query in Rell consists of five key elements:

1. **FROM**: Specifies the data source, potentially joined and filtered.
2. **CARDINALITY**: Determines the result cardinality, using operators like @, @\*, @+, or @?.
3. **WHERE**: Filters data based on conditions and joins.
4. **WHAT**: Defines the projection, aggregation, and sorting.
5. **LIMIT**: Restricts the number of returned elements.

Rell processes queries logically in this sequence, maintaining a clear order of execution.

## Filter reviews by rating [​](\#filter-reviews-by-rating "Direct link to Filter reviews by rating")

Let's begin by creating a new query, `get_reviews_by_rating`, to fetch reviews by rating. We then add a filter to our
`get_reviews_by_rating` query to retrieve reviews based on a specific rating. Here's the full query, followed by an
explanation:

src/main/queries.rell

```codeBlockLines_e6Vv
query get_reviews_by_rating(rating: integer) {
  return book_review @* { .rating == rating } (
    .book.to_struct(),
    .reviewer_name,
    .review,
    .rating
  );
}

```

In this query:

- **FROM**: `book_review`
- **CARDINALITY**: `@*`
- **WHERE**: `{ .rating == rating }`
- **WHAT**: `( .book.to_struct(), .reviewer_name, .review, .rating )`

## Testing filtered reviews [​](\#testing-filtered-reviews "Direct link to Testing filtered reviews")

To ensure our new query correctly filters reviews by rating, let's create a test in our test module.

### Update Imports [​](\#update-imports "Direct link to Update Imports")

First, update the imports in your test file to include the new query:

src/test/book\_review\_test.rell

```codeBlockLines_e6Vv
import main.{ book, create_book, get_all_books, book_review, create_book_review, get_reviews_by_rating };

```

### Add Test Function [​](\#add-test-function "Direct link to Add Test Function")

Then, add the following test function to verify that our query works as expected:

src/test/book\_review\_test.rell

```codeBlockLines_e6Vv
function test_get_reviews_by_rating() {
    rell.test.tx()
        .op(create_book("123", "Book1", "Author1"))
        .op(create_book_review("123", "Reviewer1", "ReviewText1", 4))
        .op(create_book_review("123", "Reviewer2", "ReviewText2", 5))
        .op(create_book_review("123", "Reviewer3", "ReviewText3", 4))
        .op(create_book_review("123", "Reviewer4", "ReviewText4", 1))
        .sign(book_keeper)
        .run();
    val reviews = get_reviews_by_rating(4);
    assert_equals(reviews.size(), 2);
}

```

In this test, we create a book and add four reviews with different ratings. We then query for reviews with a rating of 4
and assert that there are two such reviews.

## Sort reviews by rating [​](\#sort-reviews-by-rating "Direct link to Sort reviews by rating")

Let's explore sorting reviews by rating. We will update an existing query, `get_all_reviews_for_book`, to include
sorting by rating. This example sorts reviews by rating in ascending order. To sort in descending order, you can use
`@sort_desc`:

src/main/queries.rell

```codeBlockLines_e6Vv
query get_all_reviews_for_book(isbn: text) {
  require(book @? { .isbn == isbn }, "Book with isbn %s not found".format(isbn));
  val reviews = book_review @* { .book.isbn == isbn } (
    @omit @sort_desc .rating, // Sort on rating, but omit this field in the result.
    book_review_dto(
      book = .book.to_struct(),
      .reviewer_name,
      .review,
      .rating
    )
  );
  return reviews;
}

```

### Update Imports [​](\#update-imports-1 "Direct link to Update Imports")

Update the imports in your test file to include the query:

src/test/book\_review\_test.rell

```codeBlockLines_e6Vv
import main.{ book, create_book, get_all_books, book_review, create_book_review, get_reviews_by_rating, get_all_reviews_for_book };

```

### Add Test Function [​](\#add-test-function-1 "Direct link to Add Test Function")

Then, add the following test function to verify that the reviews are correctly sorted:

src/test/book\_review\_test.rell

```codeBlockLines_e6Vv
function test_get_sorted_reviews_by_rating() {
    rell.test.tx()
        .op(create_book("123", "Book1", "Author1"))
        .op(create_book_review("123", "Reviewer1", "ReviewText1", 5))
        .op(create_book_review("123", "Reviewer2", "ReviewText2", 2))
        .op(create_book_review("123", "Reviewer3", "ReviewText3", 4))
        .sign(book_keeper)
        .run();
    val reviews = get_all_reviews_for_book("123");
    assert_equals(reviews.size(), 3);
    assert_equals(reviews[0].rating, 5);
    assert_equals(reviews[1].rating, 4);
    assert_equals(reviews[2].rating, 2);
}

```

In this test, we create a book and three reviews with different ratings. We then query for reviews sorted by rating in
ascending order and assert that the results are correctly sorted.

## Running the Tests [​](\#running-the-tests "Direct link to Running the Tests")

To execute your tests and verify the correctness of your queries, run the following command:

```codeBlockLines_e6Vv
chr test

```

With these filtering and sorting capabilities, our app now allows an administrator to add books and any user to post
reviews for those books. We can effectively query for reviews and books and apply filtering and sorting to the results.

- [Filter reviews by rating](#filter-reviews-by-rating)
- [Testing filtered reviews](#testing-filtered-reviews)
  - [Update Imports](#update-imports)
  - [Add Test Function](#add-test-function)
- [Sort reviews by rating](#sort-reviews-by-rating)
  - [Update Imports](#update-imports-1)
  - [Add Test Function](#add-test-function-1)
- [Running the Tests](#running-the-tests)[Skip to main content](#__docusaurus_skipToContent_fallback)

## Crosschain Courses

#### Courses that cover ICCF and ICMF concepts and implementation.

[Intermediate **Confirm events across blockchains** \\
Use cross-chain events for secure user access control.](/courses/iccf-course/introduction)

[Rell](/tags/Rell) [Crosschain](/tags/Crosschain) [Multichain](/tags/Multichain)

Start Course [Advanced **Build an event-driven multi-blockchain dapp** \\
Create a multi-blockchain dapp with event-driven communication.](/courses/icmf-course/introduction)

[Rell](/tags/Rell) [Crosschain](/tags/Crosschain) [Multichain](/tags/Multichain)

Start Course[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In this section, we'll guide you through connecting to the blockchain using a client. We will together build an example
client and we start by adding all required imports at the top of our file `book_review.ts`.

```codeBlockLines_e6Vv
import { encryption, createClient, newSignatureProvider, IClient } from "postchain-client";
import * as readline from "readline";

```

Then, we create a main function and add a helper function to receive input:

```codeBlockLines_e6Vv
async function main() {}

```

## The `createClient` method [​](\#the-createclient-method "Direct link to the-createclient-method")

The `createClient` returns a client instance that enables us to query the blockchain and send transactions. Let's add it
and break down how it works:

```codeBlockLines_e6Vv
let client: IClient;
const blockchainRID = "<Blockchain RID>";

async function main() {
  client = await createClient({
    nodeUrlPool: "http://localhost:7740",
    blockchainRid: blockchainRID,
  });
}

```

### Parameters: [​](\#parameters "Direct link to Parameters:")

- `nodeUrlPool`: This is the URL of the node you want to connect to. In most development scenarios, Chromia nodes run
locally, often as `http://localhost:7740`. However, in a production or testnet scenario, you'd use the address of a
remote node.

- `blockchainRid`: Every Chromia blockchain has a unique Referential Identifier (RID). It's a hexadecimal string that
distinguishes different blockchains.


In the code snippet above, we connect to a local Chromia node and specify the blockchain of interest using its RID.

**Why is this important?**

- **Specificity**: A single Chromia node might be aware of multiple blockchains, the RID ensures you interact with the
correct one.

- **Flexibility**: By parameterizing the node URL and blockchain RID, you can easily switch between different
environments (e.g., development, staging, production) or blockchains without changing your app's core logic.


**How to get the Blockchain RID** When you have a node running you can always query the node for the Blockchain RID
using:

```codeBlockLines_e6Vv
curl http://localhost:7740/brid/iid_0

```

## Sign a transaction with `postchain-client` [​](\#sign-a-transaction-with-postchain-client "Direct link to sign-a-transaction-with-postchain-client")

The `postchain-client` library simplifies transaction signing for Chromia. Let's break down this process step by step:

### Generate a keypair [​](\#generate-a-keypair "Direct link to Generate a keypair")

Before signing any transaction, you need to generate a cryptographic keypair consisting of a public and private key. We
add the following to our `book_review.ts` file. Add the private key for our admin book keeper found in chromia.yaml.

```codeBlockLines_e6Vv
const privKey = Buffer.from("<private key>", "hex");
const bookKeeperKeyPair = encryption.makeKeyPair(privKey);

```

The `makeKeyPair` function from the `encryption` module generates a keypair using the provided private key ( `privKey`).
The resulting `bookKeeperKeyPair` contains both the private key (used for signing) and the associated public key (used
for verification).

### Secure storage and retrieval of keys [​](\#secure-storage-and-retrieval-of-keys "Direct link to Secure storage and retrieval of keys")

When working with cryptographic keys, it's crucial to store them securely to prevent unauthorized access. To learn about best practices for securely generating, storing, and managing your keys, please refer to the [Chromia documentation on key generation](https://docs.chromia.com/cli/keygen). This documentation provides guidance on file placement and other important security practices.

Warning: Security Risk

In this code example, `privKey` is assigned directly for the sake of simplicity. It is critically important to manage
private keys securely in a production environment. Never store private keys in plain text or expose them in client-side
code, as it poses a significant security risk.

### Set up the signature provider [​](\#set-up-the-signature-provider "Direct link to Set up the signature provider")

Once you have your keypair, you need a mechanism to use it for signing transactions, so let's create the
SignatureProvider and add it to `book_review.ts`.

```codeBlockLines_e6Vv
const bookKeeperSignatureProvider = newSignatureProvider(bookKeeperKeyPair);

```

The `newSignatureProvider` function creates a signature provider using the provided keypair ( `bookKeeperKeyPair`). This
signature provider is responsible for signing any transaction before it's sent to the blockchain.

### Using the `signAndSendUniqueTransaction` method [​](\#using-the-signandsenduniquetransaction-method "Direct link to using-the-signandsenduniquetransaction-method")

So we can now add our first transaction to the main function in `book_review.ts`:

```codeBlockLines_e6Vv
console.log("Creating a new book transactions");
await client.signAndSendUniqueTransaction(
  { name: "create_book", args: ["ISBN1", "Chromia 101", "John Doe"] },
  bookKeeperSignatureProvider
);

```

The `signAndSendUniqueTransaction` method from the `postchain-client` library combines two primary tasks:

- **Signing**: Before a transaction is dispatched to the blockchain, it's signed using the provided signature provider.
When verified by the blockchain network, this signature proves that the transaction hasn't been tampered with after
being signed and confirms the sender's identity.

- **Sending**: Once the transaction is signed, it's dispatched to the Chromia blockchain for processing.


#### Parameters explained: [​](\#parameters-explained "Direct link to Parameters explained:")

This method takes two arguments:

1. **Transaction object**:
   - `name`: Represents the operation you intend to run on the blockchain. For example, "create\_book" corresponds to a
     Rell function that creates a new book entity on the blockchain.

   - `args`: An array containing the arguments for the operation.
2. **Signature provider**: This will sign the transaction using the previously discussed keypair. In the code snippet
provided, the `bookKeeperSignatureProvider` is being used.


#### How it fits in the overall flow: [​](\#how-it-fits-in-the-overall-flow "Direct link to How it fits in the overall flow:")

When you invoke `signAndSendUniqueTransaction`, you're essentially instructing the client to:

- Create a transaction to call the `create_book` function on the blockchain with the provided arguments.

- Sign this transaction using the `bookKeeperSignatureProvider`.

- Send the now-signed transaction to the Chromia blockchain.


#### Test run our code [​](\#test-run-our-code "Direct link to Test run our code")

Lastly, at the end of our file, we add a function call to run the \`main ' function like this.

```codeBlockLines_e6Vv
main();

```

Now, we can test running our first example.

```codeBlockLines_e6Vv
   npx tsc book_review.ts
   node book_review.js

```

Next, we will look at adding a query to fetch books and reviews.

- [The `createClient` method](#the-createclient-method)
  - [Parameters:](#parameters)
- [Sign a transaction with `postchain-client`](#sign-a-transaction-with-postchain-client)
  - [Generate a keypair](#generate-a-keypair)
  - [Secure storage and retrieval of keys](#secure-storage-and-retrieval-of-keys)
  - [Set up the signature provider](#set-up-the-signature-provider)
  - [Using the `signAndSendUniqueTransaction` method](#using-the-signandsenduniquetransaction-method)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Let's start with a quick overview of Polkadot, and then we will continue with comparing Polkadot to Chromia and also discuss the benefits and challenges
with the two solutions.

## Polkadot [​](\#polkadot-1 "Direct link to Polkadot")

**Tech and Architecture**

- Consists of a **Relay Chain** (the main chain), **Parachains** (parallel blockchains),
and **Bridges** (connections to other blockchains like Ethereum).
- Uses a **Nominated Proof-of-Stake (NPoS)** consensus mechanism.
In NPoS, validators are selected by the community to secure the network. Validators validate transactions and propose new blocks to the Relay Chain.
- Features like **Cross-chain Message Passing (XCMP)** for communication between chains. XCMP allows parachains to send messages to
each other and the Relay Chain. This enables applications to span multiple blockchains and leverage the strengths of each one.

**Scalability**

- Polkadot achieves scalability through parachains, which allow for parallel transaction processing,
and the Relay Chain, which coordinates consensus and ensures security.
- By distributing transactions across multiple parachains, Polkadot can handle a much higher volume of transactions than a
single-chain blockchain.

**Development tools**

- Polkadot provides the **Substrate** framework for building blockchains.
Substrate is a modular framework that allows developers to select or modify components as needed.

- For Substrate development you can use Rust, but Polkadot supports other programming languages,
such as Golang, C++, and Solidity through WebAssembly (Wasm).


**Fee structure**

- Polkadot uses a **dynamic fee model**, calculating fees based on
transaction complexity and network congestion.

## Comparison [​](\#comparison "Direct link to Comparison")

### Development [​](\#development "Direct link to Development")

* * *

Polkadot

- Polkadot uses Rust as its primary programming language for smart contract development.
But it supports other languages like Golang, C++, and Solidity through WebAssembly (Wasm)

WebAssembly enables developers to use their preferred language within the Polkadot ecosystem.

- Substrate framework: This is a framework that breaks down a blockchain's development process by providing complete building blocks of functionality,
removing the need for re-engineering complex mechanisms that are usually involved when developing a blockchain.


Chromia

- Chromia uses Rell, a relational blockchain programming language. Rell can be a more user-friendly language than Go or Rust, making it easier for developers to build dapps on Chromia.
- Development on Chromia using Rell is very similar to Web2 development. For more insights on this, check out our guide [here](https://docs.chromia.com/category/rell-language).
- Chromia provides tools and libraries to simplify authentication, transaction signing, and asset management, and new features are added to support rapid dapp development.
- Chromia's development environment has support for testing using its own test framework and simple deployment using developer-friendly tools.

### Scalability [​](\#scalability "Direct link to Scalability")

* * *

Polkadot

- Polkadot's approach to scalability works around a Relay Chain and the use of Parachains.
The Relay Chain, serving as the core of the network, focuses on security and consensus while offloading
transaction processing to the Parachains.
These Parachains are independent blockchains that operate in parallel within Polkadot,
each optimized for specific functions such as high-speed transactions or decentralized storage.

This architecture enables concurrent transaction processing, increasing the network’s capacity
compared to traditional blockchains that process transactions sequentially.

However, creating a parachain requires significant technical expertise and resources.


Chromia

- Chromia's approach is that every dapp on Chromia operates on a unique subchain. Each subchain can handle hundreds of transactions every second.
If a dapp witnesses growth, it can with ease be expanded by adding more chains.
This structure guarantees sustained high throughput and a predictable way of scaling your dapp, much like in a traditional cloud environment.

Since every subchain is isolated from other subchains, this means that they can process transactions in parallel, in essence scaling horizontally
and only your app architecture sets the limit for scalability.

Chromias sidechain architecture is built into the platform, making it a low effort for developers to utilize this approach of side chains.


### Operational Costs & Fees [​](\#operational-costs--fees "Direct link to Operational Costs & Fees")

* * *

Polkadot

- Deploying and executing smart contracts on Polkadot is associated with transaction fees.
These fees cover both the deployment and ongoing transactions needed for the dapp when the contracts are executed by the end-users.
This works like traditional gas fees, although Polkadot has a weight-based fee model with the goal of achieving predictable fees.

Transaction fees compensate validators and nominators for maintaining network security and operations.

- For dapps needing a dedicated blockchain, a parachain slot is necessary.
This slot is acquired through periodic auctions, and there is a cost for both acquisition and maintenance.


Chromia

- Chromia changes the game by allowing developers to host their decentralized app (dapp) in a container for a fixed,
predictable fee. This transparency means developers know how much their operational costs are each month, and they can create their own end-user fee structures to cover these operational expenses.

So, instead of being charged gas fees for every action, there's a single, more manageable cost to work with.

- As a Chromia dapp grows in usage, the developer of the dapp can increase the resources of their container. Very similar to how
you manage resources in a Cloud environment.


### Revenue models [​](\#revenue-models "Direct link to Revenue models")

* * *

Polkadot

- Users can participate in the network security by staking their tokens. Staking involves locking up DOT tokens for a specified period earning rewards in the form of newly minted DOT tokens. This staking mechanism incentivizes DOT holders to participate actively in network maintenance and security, ensuring stability and resilience.

- Like other blockchain networks, Polkadot generates transaction fees when users execute transactions on the network. The transaction fee structure is designed to be dynamic and responsive to network conditions, adjusting based on congestion and transaction complexity


Chromia

- Since the operational costs of the dapp are fixed and predictable, the dapp developer can choose which fee model they want to use for their end-users.
With Chromia, you are not locked in by transactions and gas fees.

- For your dapp, you can have a monthly subscription fee, charge for single features, or, if you want, per transaction.
This opens up a more user-friendly experience since you can even let the user start for free and then
open up for revenues later when the user has found the value of your dapp. This is a common practice in traditional web applications and should be no different for Web3.


### Conclusion and comparison summary to Chromia [​](\#conclusion-and-comparison-summary-to-chromia "Direct link to Conclusion and comparison summary to Chromia")

* * *

In the web3 space, Polkadot and Chromia are two notable platforms, each with its own features.
Let's summarize and discuss the benefits and challenges.

### Architecture [​](\#architecture "Direct link to Architecture")

Polkadot features a good design with its Relay Chain and Parachains.
This architecture, while robust, requires a deep understanding of its complex
layers demanding considerable technical expertise
from its developers.

In contrast, Chromia stands out for its simplicity and accessibility.
Chromia uses Rell, a relational blockchain programming language, deliberately similar to modern programming languages like JavaScript and Kotlin.
This makes it a comfortable platform for developers,
especially those transitioning from traditional web development.

This allows for a broader range of developers to create dapps without the steep learning curve
associated with more complex languages like Rust, used in Polkadot.

### Scalability Considerations [​](\#scalability-considerations "Direct link to Scalability Considerations")

While Polkadot's scalability is achieved through its Relay Chain and Parachains,
enabling parallel transaction processing and high throughput, this again requires a deep technical knowledge and development effort.

Chromia, on the other hand, offers a similar straightforward scalability solution.
Each dapp operates on its own subchain, capable of handling high transaction volumes.
Scalability can be easily managed through resource adjustments, which is very close to cloud services. Making the development and resource management effort more straightforward.

### Operational costs & fees [​](\#operational-costs--fees-1 "Direct link to Operational costs & fees")

Polkadot's dynamic fee model, though innovative, might pose unpredictability in costs for developers.
Additionally, the requirement of a parachain slot for dedicated blockchain applications adds another layer of expense.

Chromia, however offers a fixed, predictable fee for hosting dapps.
This model not only simplifies budgeting for developers but also allows them to craft unique fee structures for end-users,
enhancing the user experience.

### Revenue models [​](\#revenue-models-1 "Direct link to Revenue models")

Polkadot's revenue generation relies on traditional methods like staking and transaction fees.
These mechanisms, while proven, may not offer the flexibility modern dapp developers seek.

Chromia allows developers to choose their revenue models, from subscriptions to feature-based charges or even transaction fees.
This flexibility opens up creative revenue strategies that are more aligned with today's web apps.

### Final words [​](\#final-words "Direct link to Final words")

In summary, while Polkadot presents a powerful blockchain solution,
Chromia stands out with its user-friendly approach, straightforward scalability, and innovative cost and revenue models.
These features make Chromia an appealing choice, especially for those seeking a seamless transition from web2 into the web3 domain.

- [Polkadot](#polkadot-1)
- [Comparison](#comparison)
  - [Development](#development)
  - [Scalability](#scalability)
  - [Operational Costs & Fees](#operational-costs--fees)
  - [Revenue models](#revenue-models)
  - [Conclusion and comparison summary to Chromia](#conclusion-and-comparison-summary-to-chromia)
  - [Architecture](#architecture)
  - [Scalability Considerations](#scalability-considerations)
  - [Operational costs & fees](#operational-costs--fees-1)
  - [Revenue models](#revenue-models-1)
  - [Final words](#final-words)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In this section, we'll add validations to ensure that we only allow valid data. To achieve this, we will leverage the
[require function](https://docs.chromia.com/rell/language-features/systemlib/require-function).

## Input validation [​](\#input-validation "Direct link to Input validation")

We must update the `create_book_review` operation to incorporate input validation using the `require` function. Make the
following changes to the `src/main/operations.rell` file:

src/main/operations.rell

```codeBlockLines_e6Vv
operation create_book_review(isbn: text, reviewer_name: text, review: text, rating: integer) {
  val book = require(book @? { .isbn == isbn }, "Book with isbn %s not found".format(isbn));
  create book_review (
    book,
    reviewer_name,
    review,
    rating
  );
}

```

In this updated function:

- `book @? { .isbn == isbn }` attempts to fetch a book with a matching `isbn`. The `@?` operator returns null if no
matching book is found.
- The `require()` function checks for a null value and throws an error if the book does not exist (i.e., is null).

This simple yet powerful validation mechanism is seamlessly integrated into Rell, allowing you to maintain your app's
security and stability easily.

We will dive deeper into validation in upcoming courses and tutorials, particularly when we explore signing transactions
and handling user accounts.

## Test validations [​](\#test-validations "Direct link to Test validations")

Now, let's ensure that our new validation for `create_book_review` is tested thoroughly. We already have a test to add a
book review, which should pass the validation since it uses an existing book:

src/test/book\_review\_test.rell

```codeBlockLines_e6Vv
rell.test.tx()
    .op(create_book("123", "Book1", "Author1"))
    .op(create_book_review("123", "Reviewer1", "ReviewText1", 5))
    .run();

```

However, we must also add a new test for a non-existing book, which should fail the `create_book_review` operation. Add
the following test function to the `src/test/book_review_test.rell` file:

src/test/book\_review\_test.rell

```codeBlockLines_e6Vv
function test_add_book_review_for_missing_book() {
    rell.test.tx()
        .op(create_book_review("N/A", "Reviewer2", "ReviewText2", 3))
        .run_must_fail("Book with isbn N/A not found");
}

```

In this test, we use `isbn = "N/A"`, which will result in a failed requirement and, consequently, a passed test. This
comprehensive testing ensures that our input validation is robust and functions as intended.

## Run the tests [​](\#run-the-tests "Direct link to Run the tests")

To verify that everything is functioning as expected after updating your code, execute the following command:

```codeBlockLines_e6Vv
chr test

```

- [Input validation](#input-validation)
- [Test validations](#test-validations)
- [Run the tests](#run-the-tests)[Skip to main content](#__docusaurus_skipToContent_fallback)

## Multichain Courses

#### Courses that cover multichain concepts and implementations.

[Intermediate **Confirm events across blockchains** \\
Use cross-chain events for secure user access control.](/courses/iccf-course/introduction)

[Rell](/tags/Rell) [Crosschain](/tags/Crosschain) [Multichain](/tags/Multichain)

Start Course [Intermediate **Monetize your dapp** \\
Explore strategies for monetizing your dapp.](/courses/monetize-dapp/introduction)

[Rell](/tags/Rell) [Multichain](/tags/Multichain) [Dapp](/tags/Dapp) [FT4](/tags/FT4)

Start Course [Advanced **Build an event-driven multi-blockchain dapp** \\
Create a multi-blockchain dapp with event-driven communication.](/courses/icmf-course/introduction)

[Rell](/tags/Rell) [Crosschain](/tags/Crosschain) [Multichain](/tags/Multichain)

Start Course[Skip to main content](#__docusaurus_skipToContent_fallback)

# How Chromia Compares to Other Blockchain platforms

This guide aims to help developers and project stakeholders in the decision of blockchain platform to choose for development. We believe that Chromia stands out compared to the competition but choosing the right blockchain platform for your project is a crucial decision that can significantly impact its success and scalability.

This guide presents a detailed comparison between Chromia and other blockchain platforms like Polygon, Cosmos, Ethereum, and more. We aim to provide a comprehensive and objective overview highlighting each platform's unique features, strengths, and limitations.

Understanding the differences of these platforms is important and the options are many in the blockchain landscape and each platform offers distinct advantages and challenges. This guide is designed to help you make an informed decision that fits your needs and the goals of your project.

We will present a detailed comparison between Chromia and other blockchain platforms like Polygon, Cosmos, Ethereum, and more.
Our aim is to provide a comprehensive and objective overview that highlights the unique features, strengths, and limitations of each platform.

Understanding the differences between these platforms is important, and there are many options in the blockchain landscape. Each platform offers distinct advantages and challenges. This guide is designed to help you make an informed decision that fits your needs and the goals of your project.[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Before we start, please make sure you have the following prerequisites in place:

Set up PostgreSQL database

Rell requires PostgreSQL 16.3. The IDE can work without it but can't run a node. A console or a remote postchain app can
run without a database.

The default database configuration for Rell is:

- database: `postchain`
- user: `postchain`
- password: `postchain`

## Install [​](\#install "Direct link to Install")

- Mac
- Linux
- Docker
- Windows

1. Install Homebrew: [Homebrew installation guide](https://brew.sh/)

2. Install PostgreSQL:





```codeBlockLines_e6Vv
brew install postgresql@16
brew services start postgresql@16
createuser -s postgres

```

3. Prepare the PostgreSQL database:





```codeBlockLines_e6Vv
psql -U postgres -c "CREATE DATABASE postchain WITH TEMPLATE = template0 LC_COLLATE = 'C.UTF-8' LC_CTYPE = 'C.UTF-8' ENCODING 'UTF-8';" -c "CREATE ROLE postchain LOGIN ENCRYPTED PASSWORD 'postchain'; GRANT ALL ON DATABASE postchain TO postchain;"

```











note





If you get an error saying peer authentication failed, you must change the authentication method from `peer` to
`md5`. You can change it in the `pg_hba.conf` file of your `psql` database.


1. Install PostgreSQL:





```codeBlockLines_e6Vv
sudo apt install postgresql-16

```

2. Prepare the PostgreSQL database:





```codeBlockLines_e6Vv
sudo -u postgres psql -c "CREATE DATABASE postchain WITH TEMPLATE = template0 LC_COLLATE = 'C.UTF-8' LC_CTYPE = 'C.UTF-8' ENCODING 'UTF-8';" -c "CREATE ROLE postchain LOGIN ENCRYPTED PASSWORD 'postchain'; GRANT ALL ON DATABASE postchain TO postchain;"

```


1. Install Docker: [Docker installation guide](https://docs.docker.com/engine/install/)

2. Prepare the PostgreSQL database:





```codeBlockLines_e6Vv
docker run --name postgres -e POSTGRES_USER=postchain -e POSTGRES_PASSWORD=postchain -p 5432:5432 -d postgres:16.3-alpine3.20

```











note





We use the Alpine version of PostgreSQL because it provides the correct collation settings by default. This can be
explicitly set using the environment variable:







```codeBlockLines_e6Vv
POSTGRES_INITDB_ARGS="--lc-collate=C.UTF-8 --lc-ctype=C.UTF-8 --encoding=UTF-8"

```


1. Download the PostgreSQL installer from the [official website](https://www.postgresql.org/download/windows/).

2. Install the executable and add the PostgreSQL folder containing the binaries to your environment variables. Open the
Command Prompt (CMD) and run the following command, ensuring that you set the path to your binaries correctly and
replace the `<version>` placeholder with the actual version number:





```codeBlockLines_e6Vv
setx POSTGRESQL "C:\Program Files\PostgreSQL\<version>\bin"

```

3. Reopen the Command Prompt (CMD) to update the environment variables. Prepare the PostgreSQL database by running the
following two commands sequentially:





```codeBlockLines_e6Vv
psql -U postgres -c "CREATE DATABASE postchain WITH TEMPLATE = template0 LC_COLLATE = 'en_US.UTF-8' LC_CTYPE = 'en_US.UTF-8' ENCODING 'UTF-8';"
psql -U postgres -c "CREATE ROLE postchain LOGIN ENCRYPTED PASSWORD 'postchain'; GRANT ALL ON DATABASE postchain TO postchain;"

```











note





Depending on your Windows version, you may encounter various errors related to permissions or incorrect PostgreSQL
installations. If this happens, we recommend installing Docker and deploying the PostgreSQL container.


Install Chromia CLI

This topic contains instructions to install and update the
[Chromia CLI](https://gitlab.com/chromaway/core-tools/chromia-cli).

## Prerequisite [​](\#prerequisite "Direct link to Prerequisite")

Before proceeding, make sure the following prerequisites are met:

- **PostgreSQL database**: See [Set up PostgreSQL database](/docs/install/database-setup).
- **RELL\_JAVA environment**: Chromia CLI do requries a java runtime (version 21 or later) to execute. Through the
different package managers this has been abstracted away for you so you don't need to set this up. If you want to
control which java runtime you use to execute Chromia CLI with it is recomended to set RELL\_JAVA variable in your
environment to point to a valid Java installation

## Installation [​](\#installation "Direct link to Installation")

You can install Chromia CLI using a package manager or by downloading it directly from
[Chromia CLI Packages](https://gitlab.com/chromaway/core-tools/chromia-cli/-/packages).

- macOS
- Linux/WSL
- Windows

To install Chromia CLI ( `chr`) on macOS, follow these steps:

1. If Homebrew is not installed, install it by running:





```codeBlockLines_e6Vv
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

```

2. Add the Chromia repository to Homebrew by running the following command:





```codeBlockLines_e6Vv
brew tap chromia/core https://gitlab.com/chromaway/core-tools/homebrew-chromia.git

```

3. Install Chromia CLI with:





```codeBlockLines_e6Vv
brew install chromia/core/chr

```











info





To install a specific version of Chromia CLI, use the following commands:







```codeBlockLines_e6Vv
brew install chromia/core/chr@<version>
brew unlink chr
brew link chr@<version>

```











You can list available versions using: `brew search chr`.

4. To verify the installation, check the version by running:





```codeBlockLines_e6Vv
chr --version

```


To install Chromia CLI ( `chr`) on Linux or WSL (Windows Subsystem for Linux), follow these steps:

1. Download and add Chromia's `apt-repo` public key to your system’s trusted keyrings:





```codeBlockLines_e6Vv
curl -fsSL https://apt.chromia.com/chromia.gpg | sudo tee /usr/share/keyrings/chromia.gpg

```

2. Add the Chromia repository to your list of package sources:





```codeBlockLines_e6Vv
echo "deb [arch=amd64 signed-by=/usr/share/keyrings/chromia.gpg] https://apt.chromia.com stable main" | sudo tee /etc/apt/sources.list.d/chromia.list

```

3. Run the following command to update your package sources:





```codeBlockLines_e6Vv
sudo apt-get update

```











info





If you added `apt.chromia.com` before Chromia CLI version `0.16.0`, run the following command to allow the repository
update:







```codeBlockLines_e6Vv
sudo apt-get --allow-releaseinfo-change update

```

4. Once the repository is updated, install Chromia CLI by running:





```codeBlockLines_e6Vv
sudo apt-get install chr

```

5. To verify that Chromia CLI is installed successfully, check the version:





```codeBlockLines_e6Vv
chr --version

```


To install Chromia CLI ( `chr`) on Windows using [Scoop](https://scoop.sh/), follow these steps:

1. If Scoop is not installed, install it by running the following command in PowerShell (run as Administrator):





```codeBlockLines_e6Vv
iwr -useb get.scoop.sh | iex

```

2. Add the Chromia repository (bucket) to Scoop by running:





```codeBlockLines_e6Vv
scoop bucket add chromia https://gitlab.com/chromaway/core-tools/scoop-chromia/

```

3. Add the Java bucket to Scoop by running:





```codeBlockLines_e6Vv
scoop bucket add java

```









This will enable scoop to download the openjdk21 which chromia-cli depends on when installing

4. Install Chromia CLI by running:





```codeBlockLines_e6Vv
scoop install chr

```

5. To verify that Chromia CLI is installed successfully, check the version:





```codeBlockLines_e6Vv
chr --version

```


## Updating Chromia CLI [​](\#updating-chromia-cli "Direct link to Updating Chromia CLI")

You can download and install the latest Chromia CLI from
[here](https://gitlab.com/chromaway/core-tools/chromia-cli/-/packages), or if you have installed the Chromia CLI via a
package manager, you can update it with the following:

- macOS
- Linux
- Windows

```codeBlockLines_e6Vv
brew update
brew upgrade chr

```

```codeBlockLines_e6Vv
sudo apt-get update
sudo apt-get install chr

```

```codeBlockLines_e6Vv
scoop update
scoop update chr

```

## Docker [​](\#docker "Direct link to Docker")

Docker can run a standalone Linux container with the Chromia CLI pre-installed. Make sure that you have set up the
[PostgreSQL database](/docs/install/database-setup).

To use the published Docker images, you must first have Docker installed and configured on your host machine. Please
refer to the Docker documentation on how to [install Docker](https://docs.docker.com/get-docker/) on Windows, Mac, and
Linux.

### Start the Docker container with Chromia CLI pre-installed [​](\#start-the-docker-container-with-chromia-cli-pre-installed "Direct link to Start the Docker container with Chromia CLI pre-installed")

To run the latest version of the Chromia CLI, use the `docker run` command and specify the CLI Docker image name and
`chr`.

```codeBlockLines_e6Vv
docker run --rm -v $(pwd):/usr/app registry.gitlab.com/chromaway/core-tools/chromia-cli/chr:<latest version> chr

```

note

Make sure to configure your `chromia.yml` file correctly:

- **Mac**: Use `host.docker.internal` for `database:host`.
- **Windows**: Set `database:host` to `172.17.0.1`.
- **Linux**: Use the `--network=host` argument in Docker commands.

These configurations are crucial to ensure connectivity between Chromia CLI and the PostgreSQL instance.

See the [Docker command line reference](https://docs.docker.com/engine/reference/commandline/docker/) for more
information on updating or uninstalling the Docker image.

```codeBlockLines_e6Vv
#!/bin/bash

# Allocate a pseudo-TTY one when run in interactive mode
if [ -t 0 ] && [ -t 1 ] ; then TTY="--tty"; else TTY=""; fi

docker run \
  # Sets the network to host to not need to change the database hostname (linux only)
  --network=host \
  # Set timezone based on system settings (linux only)
  -e TZ=$(cat /etc/timezone) \
  # Sets process ownership to current user
  --user $(id -u):$(id -g) \
  --mount type=bind,source="/etc/passwd",target=/etc/passwd,readonly \
  --mount type=bind,source="/etc/group",target=/etc/group,readonly \
  # Configures ssh-agent (only needed if chr install is called on non-public repositores)
  -e SSH_AUTH_SOCK=$SSH_AUTH_SOCK \
  --volume "$SSH_AUTH_SOCK:$SSH_AUTH_SOCK" \
  --mount type=bind,source="${HOME}/.ssh",target=${HOME}/.ssh,readonly \
  --mount type=bind,source="${HOME}/.config/jgit",target=${HOME}/.config/jgit \
  # Mounts current folder into the container (Use `Get-Location` on PowerShell)
  --mount type=bind,source="$(pwd)",target=/usr/app \
  --interactive ${TTY} \
  --rm \
  registry.gitlab.com/chromaway/core-tools/chromia-cli/chr:${CHR_VERSION:-latest} chr "$@"

```

Let's kick things off by setting up your blockchain app project using the Chromia CLI.

```codeBlockLines_e6Vv
chr create-rell-dapp book-review --template=plain

```

```codeBlockLines_e6Vv
cd book-review

```

This command will generate essential project files and configurations for you.

- [Install](#install)
- [Prerequisite](#prerequisite)
- [Installation](#installation)
- [Updating Chromia CLI](#updating-chromia-cli)
- [Docker](#docker)
  - [Start the Docker container with Chromia CLI pre-installed](#start-the-docker-container-with-chromia-cli-pre-installed)[Skip to main content](#__docusaurus_skipToContent_fallback)

1. You can spot `chromia.yml` file to have a FT4 library as a dependency:

chromia.yml

```codeBlockLines_e6Vv
blockchains:
  asset_management:
    module: main
    moduleArgs:
      main:
        basic: 5
compile:
  rellVersion: 0.13.5
database:
  schema: schema_asset_management
test:
  modules:
    - test
libs:
  ft4:
    registry: https://bitbucket.org/chromawallet/ft3-lib
    path: rell/src/lib/ft4
    tagOrBranch: v1.0.0r
    rid: x"FA487D75E63B6B58381F8D71E0700E69BEDEAD3A57D1E6C1A9ABB149FAC9E65F"
    insecure: false

```

2. Run `chr install` to download the FT4 library.

This configuration sets up your project with the FT4 library and necessary dependencies for building the asset management system.[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In this section, we’ll create the `create_book` operation. This operation allows us to add new book entries to the
blockchain by updating the dapp’s state.

## Define the `create_book` operation [​](\#define-the-create_book-operation "Direct link to define-the-create_book-operation")

In Rell, an operation is a signed public function that modifies the state of the blockchain or, more specifically,
updates the dapp state. Operations serve as the primary means to interact with and alter the state of your dapp.

Open the file `src/main/operations.rell` and add the following Rell code:

src/main/operations.rell

```codeBlockLines_e6Vv
operation create_book(isbn: text, title: text, author: text) {
  create book(isbn = isbn, title = title, author = author);
}

```

### Breakdown of the code [​](\#breakdown-of-the-code "Direct link to Breakdown of the code")

- **`operation` keyword:** Defines a new operation. This functions like a public function that can be called to perform
actions that change the state of your dapp.
- **Parameters:** The `create_book` operation takes three parameters: `isbn`, `title`, and `author`. These parameters
correspond to the attributes of the `book` entity.
- **`create` command:** Inside the operation, the `create` command inserts a new book entry into the dapp’s state using
the provided parameters.

## Understanding the process [​](\#understanding-the-process "Direct link to Understanding the process")

Here’s an overview of what happens when you execute the `create_book` operation:

Signs transaction

Update

User

create\_book: isbn, title, author

Chromia Node

Blockchain

Table/State

Row: isbn = 1234, title = 1984, author = George Orwell

And a detailed view of the transaction process:

TransactionBlockchain transactionsTables/StateRellChromia NodeUserBlockchain transactionsTables/StateRellChromia NodeUserArgs: Title, Author, ISBNTransaction confirmed or rejectedSigns operation/transaction 'create\_book'Validates transaction to add new book dataApply transaction "tx create\_book isbn, title, author"Call to update state from operationInsert book in tableConfirm book transaction committed

1. **User signs a transaction:** The user initiates a transaction to execute the `create_book` operation.
2. **Transaction validation:** The Chromia node validates the transaction and forwards it to the blockchain.
3. **State update:** The operation `create_book` updates the dapp’s state by creating a new book entry.
4. **Blockchain confirmation:** If the transaction is confirmed, it is added to the blockchain, and the dapp’s state is
updated accordingly.

## Add unit tests [​](\#add-unit-tests "Direct link to Add unit tests")

Testing ensures that your operations work as expected. We’ll add a test for the `create_book` operation.

Insert the following test code into `src/test/book_review_test.rell`, so the file looks like this:

src/test/book\_review\_test.rell

```codeBlockLines_e6Vv
@test module;

import main.{ book, create_book };

function test_add_book() {
    rell.test.tx()
        .op(create_book("123", "Book1", "Author1"))
        .op(create_book("124", "Book2", "Author2"))
        .run();

    val all_books = book @* { };

    assert_equals(all_books.size(), 2);
    assert_equals(all_books[0].title, "Book1");
    assert_equals(all_books[0].author, "Author1");
}

```

### Breakdown of the test [​](\#breakdown-of-the-test "Direct link to Breakdown of the test")

- **Transaction creation:** `rell.test.tx()` creates a test transaction.
- **Adding operations:** Two `create_book` operations are added to the transaction.
- **Execution:** `run()` executes the transaction.
- **Assertions:** The test queries all books and verifies that there are two entries with the correct attributes.

Got it! Here’s the revised version:

* * *

## Running the test [​](\#running-the-test "Direct link to Running the test")

To run the test, ensure you're in your project folder and enter the following command in your terminal:

```codeBlockLines_e6Vv
chr test

```

## Testing on a local node [​](\#testing-on-a-local-node "Direct link to Testing on a local node")

To test the `create_book` operation on a local Chromia node, follow these steps:

1. **Start a local Chromia node**: Open your terminal and run the following command:





```codeBlockLines_e6Vv
chr node start

```

2. **Add a book**: In a new terminal window or tab, run the following command to add a book:





```codeBlockLines_e6Vv
chr tx --await create_book "ISBN1234" "'1984'" "George Orwell"

```


The result should be:

```codeBlockLines_e6Vv
transaction with rid TxRid(rid=<RID>) was posted CONFIRMED

```

This confirms that the transaction was added to the blockchain, and the `book` table now contains a new row with the
book data.

- [Define the `create_book` operation](#define-the-create_book-operation)
  - [Breakdown of the code](#breakdown-of-the-code)
- [Understanding the process](#understanding-the-process)
- [Add unit tests](#add-unit-tests)
  - [Breakdown of the test](#breakdown-of-the-test)
- [Running the test](#running-the-test)
- [Testing on a local node](#testing-on-a-local-node)[Skip to main content](#__docusaurus_skipToContent_fallback)

# Courses tagged with: tag

No courses found for this tag.[Skip to main content](#__docusaurus_skipToContent_fallback)

In this introductory lesson, you'll start your journey by defining a `book` entity in the Rell language.

You'll also create an operation to store book entries on the blockchain, learn about test modules to ensure your
decentralized app (dapp) functions as intended and write a query to retrieve all books.

## Sections

[Create your first entity](/courses/book-review/book-entity/tables)

[Add your first operation](/courses/book-review/book-entity/basic-operations)

[Write a query to retrieve all books](/courses/book-review/book-entity/write-queries)

[Start lesson »](/courses/book-review/book-entity/tables)[Skip to main content](#__docusaurus_skipToContent_fallback)

## Dapp Development Courses

#### Courses that cover Dapp development concepts and implementation.

[Beginner **Write your first dapp on Chromia** \\
Develop a simple book review dapp while learning Chromia's core concepts and Rell.](/courses/book-review/introduction)

[Concepts](/tags/Concepts) [Rell](/tags/Rell) [Dapp](/tags/Dapp)

Start Course [Beginner **Web3 for Web2 developers** \\
Transition smoothly from Web2 to Web3 development, tailored for web developers.](/courses/web3-for-web2-devs/introduction)

[Web3](/tags/Web3) [Dapp](/tags/Dapp)

Start Course [Intermediate **Create a simple app on Chromia using Rell and React** \\
Build a decentralized news feed app with database design and MetaMask integration.](/courses/my-news-feed/introduction)

[Rell](/tags/Rell) [React](/tags/React) [MetaMask](/tags/MetaMask) [FT4](/tags/FT4) [Dapp](/tags/Dapp)

Start Course [Intermediate **Monetize your dapp** \\
Explore strategies for monetizing your dapp.](/courses/monetize-dapp/introduction)

[Rell](/tags/Rell) [fee](/tags/fee) [Multichain](/tags/Multichain) [Dapp](/tags/Dapp) [FT4](/tags/FT4)

Start Course [Advanced **Build an event-driven multi-blockchain dapp** \\
Create a multi-blockchain dapp with event-driven communication.](/courses/icmf-course/introduction)

[Rell](/tags/Rell) [Crosschain](/tags/Crosschain) [Multichain](/tags/Multichain) [Dapp](/tags/Dapp)

Start Course [Advanced **Build a decentralized marketplace using FT4** \\
Learn to create a marketplace dapp with NFT and token transfers.](/courses/marketplace-course/introduction)

[FT4](/tags/FT4) [Rell](/tags/Rell) [Dapp](/tags/Dapp)

Start Course[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Now that we've created the `book` entity, the next step is introducing the `book_review` entity. This entity will enable
us to record book reviews. The model is as follows:

booktextisbntexttitletextauthorbook\_reviewbookbooktextreviewer\_nametextreviewintegerratingcontains

## Add the book review entity [​](\#add-the-book-review-entity "Direct link to Add the book review entity")

To define the `book_review` entity, open the file `src/main/entities.rell` and add the following code:

src/main/entities.rell

```codeBlockLines_e6Vv
entity book_review {
  index book: book;
  reviewer_name: text;
  review: text;
  rating: integer;
}

```

### Breakdown of the code [​](\#breakdown-of-the-code "Direct link to Breakdown of the code")

- **`entity` keyword:** Defines a new entity, similar to creating a table in a SQL database.
- **`index book: book;`**: The `index` keyword is used to optimize queries involving the `book` relation. This attribute
refers to a `book`, creating a link between a book and its reviews.
- **`reviewer_name: text;`**: Allows users to enter their name or alias as a reviewer.
- **`review: text;`**: Stores the textual content of the review.
- **`rating: integer;`**: Captures the numerical rating given to the book review.

You can begin recording book reviews with these attributes in your Chromia-based app. For a deeper understanding of
managing relationships between entities, check out our
[Understand relationships in Rell](/courses/relationships-course/introduction) course, which covers building and
optimizing table relationships.

- [Add the book review entity](#add-the-book-review-entity)
  - [Breakdown of the code](#breakdown-of-the-code)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Let's start with a quick overview of Ethereum, and then we will continue with comparing Ethereum to Chromia and also discuss the benefits and challenges
with the two solutions.

## Ethereum [​](\#ethereum-1 "Direct link to Ethereum")

**Tech and Architecture**

- Ethereum is a blockchain platform featuring an architecture that supports smart contracts, enabling applications to run autonomously and securely without downtime or interference.
- It has for a long time used the **Proof-of-Work (PoW)** consensus mechanism but has now transitioned to **Proof-of-Stake (PoS)** in Ethereum 2.0, aimed at improving scalability and energy efficiency.
- Uses **Ethereum Virtual Machine (EVM)**, which enables the execution of code of varying algorithmic complexity.

**Scalability**

- Ethereum's current challenge is scalability, which is addressed in Ethereum 2.0 with the introduction of methods to increase transaction throughput.
- Layer 2 solutions like rollups and sidechains are being used to enhance Ethereum's scalability and reduce gas fees.

**Development Tools**

- Ethereum supports **Solidity** as the primary language for writing smart contracts.
- It provides extensive development tools like Truffle, Hardhat, and Remix, which simplify the process of smart contract development and deployment.

**Fee Structure**

- Ethereum's gas fee model can lead to high transaction costs, especially during periods of network congestion.

## Comparison [​](\#comparison "Direct link to Comparison")

### Development [​](\#development "Direct link to Development")

* * *

Ethereum

- Ethereum uses Solidity for smart contract development, which has a learning curve but offers robust capabilities for decentralized applications.

- The platform has a large ecosystem with extensive developer tools and community support. Examples of these are:
  - Truffle Suite: a development framework for Ethereum that provides a development environment, testing framework, and asset pipeline.
  - Remix: a browser-based IDE that allows for writing, deploying, and administering smart contracts in Solidity.
  - Hardhat: a development environment for Ethereum software. It consists of different components for editing, compiling, debugging, and deploying your smart contracts and dapps.

Chromia

- Chromia uses Rell, a relational blockchain programming language. Rell can be a more user-friendly language than Go or Rust, making it easier for developers to build dapps on Chromia.
- Development on Chromia using Rell is very similar to Web2 development. For more insights on this, check out our guide [here](https://docs.chromia.com/category/rell-language).
- Chromia provides tools and libraries to simplify authentication, transaction signing, and asset management, and new features are added to support rapid dapp development.
- Chromia's development environment has support for testing using its own test framework and simple deployment using developer-friendly tools.

### Scalability [​](\#scalability "Direct link to Scalability")

* * *

Ethereum

- Ethereum faces challenges in scalability, primarily due to its capacity to handle only about 15-30 transactions per second. This limitation often leads to network congestion, especially during periods of high demand from complex smart contracts and decentralized applications (dapps). The result is slower transaction times and higher fees, which has been a significant concern for users and developers alike.

- To increase scalability, Ethereum uses Layer 2 solutions like Optimistic and ZK Rollups; these solutions work by packing transactions together in batches before committing them to Ethereum as one transaction.


Chromia

- Chromia's approach is that every dapp on Chromia operates on a unique subchain. Each subchain can handle about 500 transactions every second.
If a dapp witnesses growth, it can with ease be expanded by adding more chains.
This structure guarantees sustained high throughput and a predictable way of scaling your dapp, much like in a traditional cloud environment.

Since every subchain is isolated from other subchains, this means that you can process transactions in parallel. In essence, this means scaling horizontally
and only your app architecture sets the limit for scalability.

Chromia's sidechain architecture is built into the platform, making it a low effort for developers to utilize this approach of sidechains.


### Operational Costs & Fees [​](\#operational-costs--fees "Direct link to Operational Costs & Fees")

* * *

Ethereum

- Ethereum uses a gas fee model, meaning that there is a fee associated with executing a smart contract or sending transactions to the network.
- Ethereum's gas fee model can be expensive, with fees varying based on network demand. Again, Layer 2-solutions are used to lower the fees.
- This means that the user has to pay a transaction fee to perform actions on smart contracts, and there is a fee to create and update smart contracts for the developer

Chromia

- Chromia changes the game by allowing developers to host their decentralized app (dapp) in a container for a fixed,
predictable fee. This transparency means developers know how much their operational costs are each month, and they can create their own end-user fee structures to cover these operational expenses.

So, instead of being charged gas fees for every action, there's a single, more manageable cost to work with.

- As a Chromia dapp grows in usage, the developer of the dapp can increase the resources of their container. Very similar to how
you manage resources in a Cloud environment.


### Revenue Models [​](\#revenue-models "Direct link to Revenue Models")

* * *

Ethereum

- Revenue models on Ethereum are primarily transaction-based, with developers setting up smart contracts that collect fees for various services.
- It is possible to setup revenue models like subscription fees, advertising and in-app purchases but the end-user will always pay a transaction fee on top of the revenue-model choosen.

Chromia

- Operational costs of dapps are fixed and predictable on Chromia. The dapp developer can choose which fee model they want to use for their end-users.
With Chromia, you are not locked in by transactions and gas fees.

- For your dapp, you can have a monthly subscription fee, charge for single features, or, if you want, per transaction.
This opens up a more user-friendly experience since you can even let the user start for free and then
open up for revenues later when the user has found the value of your dapp. This is a common practice in traditional web applications and should be no different for Web3.


### Conclusion and Comparison Summary to Chromia [​](\#conclusion-and-comparison-summary-to-chromia "Direct link to Conclusion and Comparison Summary to Chromia")

* * *

In the evolving landscape of blockchain platforms, Ethereum and Chromia each present unique features and approaches.
Let's summarize and discuss the benefits and challenges.

### Architecture [​](\#architecture "Direct link to Architecture")

Ethereum uses a traditional blockchain architecture with a proof-of-stake consensus mechanism. It is one of the major blockchain platforms and has a large ecosystem of dapps, communities, and utilities for developers.
There are many tools to make development efficient on Ethereum, like Remix and Hardhat.

Ethereum has some limitations when it comes to scalability, and Gas fees are quite high. This can be a challenge for developers since a
a lot of effort needs to be spent on developing smart contracts that generate as few transactions as possible.

Chromia offers simplicity with its development language Rell, extensive library and tool support, and its scalable subchain architecture.
Since Chromia has a different scaling model where dapps can scale horizontally, it will not experience the limitations of Ethereum when it comes to scaling.
Chromia also has a lot of similarities to Web2 developers.

### Scalability Considerations [​](\#scalability-considerations "Direct link to Scalability Considerations")

Ethereums shifted from Proof of Work to Proof of Stake consensus mechanism with Ethereum 2.0. While this primarily improves security and energy efficiency, it also sets the foundation for future scalability enhancements like parallel chains.
Today, Layer 2 solutions like Optimistic and ZK Rollups help Ethereum scale and offload the main chain by executing transactions outside the main chain and posting the data back to it, significantly increasing throughput and reducing transaction costs.

Chromia has parallel chains built into its architecture from the start, making it a very straightforward scaling solution.
Each dapp operates on its own subchain, capable of handling high transaction volumes. More subchains can be added as needed, which makes it scale very well.

Scalability on Chromia can be easily managed through resource adjustments, which are very close to cloud services. Making the development and resource management effort more straightforward.
The ability to add subchains enables parallel execution of transactions, which gives the developer full control of scaling.

### Operational Costs & Fees [​](\#operational-costs--fees-1 "Direct link to Operational Costs & Fees")

Deploying smart contracts to the Ethereum network has a cost in the form of a gas fee. These fees can be significant, especially for complex contracts, as they are a one-time cost paid during deployment.
If you need to update your dapps logic or fix a bug, you often have to deploy a new smart contract, which again has a cost, and if you want to modify data in your smart contract, this is done through transactions that will generate a gas fee.

Chromia, however, offers a fixed, predictable fee for hosting dapps. You simply pay a monthly fee for the resources you require for your dapp. It's no more complex than adjusting resources in a traditional Cloud environment.
This model not only simplifies budgeting for developers but also allows them to craft unique fee structures for end-users without having to think about transaction fees. This really enhances the end-user experience.

### Revenue Models [​](\#revenue-models-1 "Direct link to Revenue Models")

Ethereum's Gas Fee model often causes unpredictability in costs for developers.

Ethereum provides traditional blockchain revenue streams; you can stake ETH and gain rewards, and you can add transaction fees to smart contract executions. These methods are effective but may not offer the flexibility some developers seek since the end user has to pay a gas fee for every transaction sent through the network. This limits the options for revenue models.

Chromia, on the other hand, allows developers to choose their revenue models, from subscriptions to feature-based charges or even per-transaction fees.
This flexibility opens up creative revenue strategies that are more aligned with today's web apps.

### Final Words [​](\#final-words "Direct link to Final Words")

While Ethereum presents a powerful, scalable, and flexible blockchain ecosystem, Chromia distinguishes itself with its user-friendly approach, predictable cost model, and adaptable revenue strategies.
These features make Chromia an appealing option, particularly for developers seeking an easy entry into the blockchain space.

- [Ethereum](#ethereum-1)
- [Comparison](#comparison)
  - [Development](#development)
  - [Scalability](#scalability)
  - [Operational Costs & Fees](#operational-costs--fees)
  - [Revenue Models](#revenue-models)
  - [Conclusion and Comparison Summary to Chromia](#conclusion-and-comparison-summary-to-chromia)
  - [Architecture](#architecture)
  - [Scalability Considerations](#scalability-considerations)
  - [Operational Costs & Fees](#operational-costs--fees-1)
  - [Revenue Models](#revenue-models-1)
  - [Final Words](#final-words)[Skip to main content](#__docusaurus_skipToContent_fallback)

## AI Courses

#### Courses that cover AI concepts and implementation.

[Advanced **Create your chat agent with Chromia** \\
Learn to build and experiment with a chat agent on Chromia, focusing on AI and blockchain integration.](/courses/chat-agent-course/introduction)

[AI](/tags/AI) [Chatbot](/tags/Chatbot) [Rell](/tags/Rell)

Start Course[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Congratulations! You have successfully completed the course.

Now that you have a foundational understanding of Chromia, here are some next steps:

- Explore more advanced Chromia features and concepts.
- Build more complex dapps with real-world use cases.
- Join the Chromia developer community for support and collaboration.

Congratulations on completing this tutorial! You're now equipped to start building your own blockchain-powered decentralized applications. Happy coding!

## Join Discord for support [​](\#join-discord "Direct link to Join Discord for support")

We have a Discord Channel for those who are new to Chromia. Please post your queries or feedback regarding this course. It's a pretty active channel.

Here's the [invite link](https://discord.com/invite/chromia?ref=learn.chromia.com) to join our Discord.

## Spread the word [​](\#spread-the-word "Direct link to Spread the word")

Liked the course? Do spread the word.

- [Join Discord for support](#join-discord)
- [Spread the word](#spread-the-word)[Skip to main content](#__docusaurus_skipToContent_fallback)

In this lesson, you'll learn how to sign transactions for user authenticity and create an administration function called `book_keeper` to manage and add books available for review.

You'll also learn how to use queries in Rell for efficient data filtering and sorting.
You'll create queries to filter and sort reviews by rating.

## Sections

[Sign a transaction](/courses/book-review/sign-transaction/sign-transaction)

[Using filters and sorting in queries](/courses/book-review/sign-transaction/structure)

[Start lesson »](/courses/book-review/sign-transaction/sign-transaction)[Skip to main content](#__docusaurus_skipToContent_fallback)

Let's wrap up our guide for EVM developers transitioning to Chromia with a few key points.

**Simplified development**

Transitioning from Solidity to Rell is relatively straightforward. Rell offers a structured and developer-friendly approach to development. Its modern syntax and relational data model facilitate the creation of advanced dapps without sacrificing structure and maintainability.

Rell's intuitive query language and its use of entities and models make it robust, supporting the development of complex applications with intricate data models. This is a significant advantage compared to many Web3 environments, where smart contracts are often designed to be lightweight with minimal models, potentially limiting their functionality.

**On-chain operations**

Here are some additional benefits of transitioning to Chromia from EVM and Solidity:

1. **Enhanced scalability:** Chromia's architecture is designed to handle higher transaction throughput, making it suitable for large-scale dapps.
2. **Improved security:** The structured nature of Rell and its relational model can help mitigate common vulnerabilities found in smart contract development.
3. **Developer experience:** The modern syntax and powerful query capabilities of Rell streamline the development process, making it more accessible and efficient.

For more information on the benefits of Chromia and transitioning from EVM and Solidity, visit [chromia.com](https://www.chromia.com).

By leveraging these advantages, developers can build more sophisticated, maintainable, and scalable dapps on Chromia, making it an excellent choice for those looking to advance beyond the limitations of traditional EVM-based development.[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

This tutorial will take you through each step, from setting up your development environment to understanding the code.

Before we dive into coding, let's ensure your development environment is ready.

## Step 1: Install Node.js and setup the project [​](\#step-1-install-nodejs-and-setup-the-project "Direct link to Step 1: Install Node.js and setup the project")

1. **Node.js Installation**: If you don't have Node.js installed, you can download and install it from the
[official website](https://nodejs.org/). Node.js allows us to run JavaScript on the server side.

2. **Create a Project Directory**: In your terminal, navigate to the directory where you want to create your project and
run:





```codeBlockLines_e6Vv
mkdir chromia-book-review-demo

```













```codeBlockLines_e6Vv
cd chromia-book-review-demo

```

3. **Initialize a Node.js Project**: Run the following command to create a `package.json` file:





```codeBlockLines_e6Vv
npm init -y

```


## Step 2: Install packages [​](\#step-2-install-packages "Direct link to Step 2: Install packages")

Now that your project is set up, you'll need to install some essential packages:

```codeBlockLines_e6Vv
npm install typescript postchain-client readline @types/node

```

- `typescript`: This package provides typescript support.
- `postchain-client`: This package provides tools for interacting with the Chromia blockchain.
- `readline`: This is a core Node.js module that helps us read user input from the command line.

## Step 4: Configure TypeScript [​](\#step-4-configure-typescript "Direct link to Step 4: Configure TypeScript")

To use TypeScript in your project, you need a configuration file named `tsconfig.json`. You can create one with the
following command:

```codeBlockLines_e6Vv
npx tsc --init

```

This command generates a default `tsconfig.json` file that you can customize based on your project's needs.

## Step 5: Integrate the code [​](\#step-5-integrate-the-code "Direct link to Step 5: Integrate the code")

With all the necessary packages installed, it's time to integrate the code into your project. You can do this by
following these steps:

1. Create a TypeScript file in your project directory for our client, `book_review.ts`. In the upcoming sections, we
will add code for our client to this file, but for now, it will be empty.

2. When you want to run your Typescript code, it needs to be transpiled to JavaScript by running the following command:





```codeBlockLines_e6Vv
npx tsc book_review.ts

```


This command generates a `book_review.js` file containing the compiled JavaScript code.

3. Finally, run your code with Node.js:





```codeBlockLines_e6Vv
node book_review.js

```


This will execute your TypeScript code and interact with the Chromia blockchain as specified.

That's it! You've successfully set up your development environment, installed the necessary packages, and integrated
TypeScript into your project. Next, we will explore our client example.

- [Step 1: Install Node.js and setup the project](#step-1-install-nodejs-and-setup-the-project)
- [Step 2: Install packages](#step-2-install-packages)
- [Step 4: Configure TypeScript](#step-4-configure-typescript)
- [Step 5: Integrate the code](#step-5-integrate-the-code)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In this section, we'll look into querying the Chromia blockchain to retrieve information about transactions and our dapp
table state.

Queuing using `postchain-client` is really simple; let's look at an example that fetches all books and then breaks them
down.

First, we need to add a type for `Book` to hold our book information:

```codeBlockLines_e6Vv
type Book = {
  isbn: string;
  title: string;
  author: string;
};

```

Then, we add a function to fetch and list all books.

```codeBlockLines_e6Vv
const getAllBooks = async () => {
  const bookList = await client.query<Book[]>("get_all_books", {});
  console.log("Book list\n", bookList);
};

```

In this function we use the `client` and the `query` command to execute our query. We define the return type as a
generic type, in this case `Book[]`.

Then we add the arguments:

#### First Argument `queryFunctionName`: [​](\#first-argument-queryfunctionname "Direct link to first-argument-queryfunctionname")

This is the name of the query function defined on the blockchain. It corresponds to a function in a Rell script
responsible for retrieving all book records.

#### Second Argument `queryArguments`: [​](\#second-argument-queryarguments "Direct link to second-argument-queryarguments")

An empty object ( `{}`) signifies that this query doesn't require any specific arguments to function. This object could
contain parameters the blockchain function uses to filter or process results if necessary.

## Handling the response [​](\#handling-the-response "Direct link to Handling the response")

The `client.query` method returns a promise that, when resolved, yields an array of books ( `Book[]`). These retrieved
books can then be displayed, processed, or used in any other way according to your app's needs. In this example, we
output the result to the console.

We can add `getAllBooks();` to our main function, resulting in the function below. Now, you can re-run the client and
see that we also list our added book. To re-run the example code, you can use the command `chr node start --wipe` to
start with a new node without any data.

```codeBlockLines_e6Vv
async function main() {
  client = await createClient({
    nodeUrlPool: "http://localhost:7740",
    blockchainRid: blockchainRID,
  });

  console.log("Creating a new book transactions");
  await client.signAndSendUniqueTransaction(
    { name: "create_book", args: ["ISBN1", "Chromia 101", "John Doe"] },
    bookKeeperSignatureProvider
  );

  getAllBooks();
}

```

- [Handling the response](#handling-the-response)[Skip to main content](#__docusaurus_skipToContent_fallback)

In this lesson, you'll learn how to use input validation in Rell to enhance app security. We'll use the `require` function within the `create_book_review` operation to ensure users enter valid data. You'll also write tests for existing and non-existing books, providing robust input validation.

We'll also explore how to structure query results using the `book_review_dto` struct. This struct combines book and review data into a single organized object.

## Sections

[Verify inputs](/courses/book-review/input-verification/input-verification)

[Adding structured results from queries](/courses/book-review/input-verification/structure)

[Start lesson »](/courses/book-review/input-verification/input-verification)[Skip to main content](#__docusaurus_skipToContent_fallback)

## Rell: Core & Advanced Features

#### Explore the core concepts and advanced features of Rell.

[Intermediate **Rell masterclass** \\
Optimize SQL statements and learn advanced database interactions in Rell.](/courses/rell-masterclass/introduction)

[Rell](/tags/Rell) [SQL](/tags/SQL)

Start Course [Intermediate **Understand relationships in Rell** \\
Master complex data relationships with Rell.](/courses/relationships-course/introduction)

[Rell](/tags/Rell) [SQL](/tags/SQL)

Start Course

## Dapp: Building Decentralized Apps

#### Develop and deploy decentralized applications with Chromia.

[Beginner **Web3 for Web2 developers** \\
Transition smoothly from Web2 to Web3 development, tailored for web developers.](/courses/web3-for-web2-devs/introduction)

[Web3](/tags/Web3) [Dapp](/tags/Dapp)

Start Course [Beginner **Chromia for EVM developers** \\
As an EVM developer, explore the Chromia platform and learn how to transition to it through hands-on examples.](/courses/chromia-for-evm-developers/introduction)

[Concepts](/tags/Concepts) [Rell](/tags/Rell) [Dapp](/tags/Dapp)

Start Course [Beginner **Write your first dapp on Chromia** \\
Develop a simple book review dapp while learning Chromia's core concepts and the Rell language.](/courses/book-review/introduction)

[Concepts](/tags/Concepts) [Rell](/tags/Rell) [Dapp](/tags/Dapp)

Start Course [Advanced **Create your chat agent with Chromia** \\
Learn to build and experiment with a chat agent on Chromia, focusing on AI and blockchain integration.](/courses/chat-agent-course/introduction)

[AI](/tags/AI) [Chatbot](/tags/Chatbot) [Rell](/tags/Rell)

Start Course

## FT4: Developing with FT4

#### Explore effective strategies for integrating FT4 into your applications.

[Advanced **Build a decentralized marketplace using FT4** \\
Learn to create a marketplace dapp with NFT and token transfers.](/courses/marketplace-course/introduction)

[FT4](/tags/FT4) [Rell](/tags/Rell) [Dapp](/tags/Dapp)

Start Course [Advanced **Monetize your dapp** \\
Explore strategies for monetizing your dapp.](/courses/monetize-dapp/introduction)

[Rell](/tags/Rell) [Multichain](/tags/Multichain) [Dapp](/tags/Dapp) [FT4](/tags/FT4)

Start Course

## Multichain: Building Crosschain Solutions

#### Learn to build and manage multichain architectures for decentralized applications.

[Intermediate **Confirm events across blockchains** \\
Use cross-chain events for secure user access control.](/courses/iccf-course/introduction)

[Rell](/tags/Rell) [Crosschain](/tags/Crosschain) [Multichain](/tags/Multichain)

Start Course [Advanced **Build an event-driven multi-blockchain dapp** \\
Create a multi-blockchain dapp with event-driven communication.](/courses/icmf-course/introduction)

[Rell](/tags/Rell) [Crosschain](/tags/Crosschain) [Multichain](/tags/Multichain)

Start Course

## Client: Chromia Frontend

#### Building User-Centric Client Applications on Chromia

[Intermediate **Create a simple app on Chromia using Rell and React** \\
Build a decentralized news feed app and learn about database design and MetaMask integration.](/courses/my-news-feed/introduction)

[Rell](/tags/Rell) [React](/tags/React) [MetaMask](/tags/MetaMask) [FT4](/tags/FT4)

Start Course [Intermediate **Build an Asset Management System With React and FT4** \\
Learn to create account and token transfers.](/courses/ft4-demo-app/introduction)

[React](/tags/React) [FT4](/tags/FT4) [Rell](/tags/Rell) [Dapp](/tags/Dapp)

Start Course [Intermediate **Create Tic Tac Toe game on Chromia using Rell and Unity** \\
Create Tic Tac Toe game on Chromia using Rell and Unity. Learn game logic, design, and operations, and integrate MetaMask for authentication on the frontend.](/courses/tic-tac-toe/introduction)

[Rell](/tags/Rell) [FT4](/tags/FT4) [MetaMask](/tags/MetaMask)

Start Course[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In this section, we have created a simple Twitter clone and discuss how authentication is implemented in both Solidity
and Rell.

## Solidity [​](\#solidity "Direct link to Solidity")

In Solidity, authentication is inherently built into the language. By using `msg.sender`, you can get the address of the
entity (person or contract) that initiated the current function call. This is commonly used to authenticate and
authorize function calls.

For example, to add a post to a user's account:

Solidity

```codeBlockLines_e6Vv
function createPost(string memory _text) public {
    Post memory newPost = Post(_text, block.timestamp);
    users[msg.sender].posts.push(newPost);
}

```

You can also restrict access to certain functions by using `msg.sender`. For instance, administrative functions can be
restricted to the contract deployer using the require function:

`require(msg.sender == owner, "Only the owner can call this function.");`

## Rell [​](\#rell "Direct link to Rell")

In Rell, authentication is handled using the FT4 library. It operates similarly to Solidity's `msg.sender` but requires
setting up an authentication handler. You use `auth.authenticate()` to authenticate and fetch the user.

First, set up the auth handler as an extension:

Rell

```codeBlockLines_e6Vv
import lib.ft4.auth;

@extend(auth.auth_handler)
function () = auth.add_auth_handler(
    flags = ["MySession"]
);

```

Here's an example of how to modify a `create_post` operation with authentication in Rell:

Rell

```codeBlockLines_e6Vv
entity user {
    mutable name;
    key id: byte_array;
    key account: byte_array;
}

operation create_post(user_id : byte_array, content: text) {
    var account = auth.authenticate();
    create Post ( user @ { account }, content = content );
}

```

Just like in Solidity, the authentication process in Rell is straightforward and integrates seamlessly into the code.

For owner-specific operations, you can define an owner user in your blockchain configuration and use `require` to
enforce restrictions:

Rell

```codeBlockLines_e6Vv
require(op_context.is_signer(owner), "Only the owner can call this operation");

```

Both Solidity and Rell provide efficient ways to handle authentication:

1. **Solidity:** Uses msg.sender for authentication and authorization.
2. **Rell:** Utilizes the FT4 library for authentication, with `auth.authenticate()` to fetch the authenticated user.

You can learn more about FT4 and Authentication in Rell
[here](https://docs.chromia.com/category/ft4-accounts-and-tokens).

- [Solidity](#solidity)
- [Rell](#rell)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Before we start with code examples, let's take a quick look at the architecture of Chromia and talk a bit about the
programming language Rell.

This diagram shows the different layers of a dapp on the Chromia platform:

- **Backend:** Written in the Rell programming language and deployed on the Chromia platform. It runs on nodes hosted by
a decentralized network of system providers.
- **State Management:** Dapp state is stored in a database managed by the Chromia core software and duplicated across
multiple nodes.
- **Blockchain:** Transactions, when finalized, are stored on the blockchain, which is also duplicated across multiple
nodes.

Deploy to node

JVM

Rest Client

Rell Interpreter/Block builder

Consensus Algorithm

Rell code for dapp

Data tables/State

PostgreSQL

Dapp Blockchain

PostgreSQL

[Rell](https://docs.chromia.com/category/rell-language), Chromia's relational programming language, is designed to be
easy to learn and convenient to use for any developer. It has many similarities to modern programming languages and uses
a relational approach with an efficient and developer-friendly query language.

Rell code is compiled and deployed to a container on the Chromia platform. Each dapp has its own blockchain managed by
the Chromia network. When a dapp is deployed, you can send transactions and query data from your dapp frontend.
Deploying Rell code automatically creates the necessary tables and relations to hold a dapp's state in a PostgreSQL
database, which is automatically managed and duplicated across multiple Chromia nodes. Chromia nodes translate queries
and operations in your deployed Rell code into SQL and execute the code as needed using an interpreter or compiler.

You can learn more about the structure of a decentralized app built with Rell
[here](https://docs.chromia.com/overview/dapp).

## Interacting with a Chromia dapp [​](\#interacting-with-a-chromia-dapp "Direct link to Interacting with a Chromia dapp")

Validator NodesChromia NodeDapp FrontendUserValidator NodesChromia NodeDapp FrontendUserInteract with dappSend transaction/queryBroadcast transactionValidate transaction (Supermajority agrees)Record transaction on blockchainConfirm transaction recordedReturn responseDisplay result

On Chromia, you interact with your dapp using standard web requests. This approach allows for a familiar and
straightforward way to communicate with the blockchain and manage app state. There are libraries, like
[Postchain Client](https://docs.chromia.com/category/chromia-clients), to make this even easier by providing functions
for dapp interactions. You send signed transactions or read-only queries to a node to either mutate the state or fetch
data.

A Chromia node receives your transaction and begins a round of communication among the other Chromia nodes running your
dapp (also known as validators). Together, they ensure that a "supermajority" agrees on the transaction's validity
before it is executed. When two-thirds of validator nodes agree that the transaction is valid, a
[consensus](https://docs.chromia.com/overview/node#builds-blocks-and-verifies-consensus) is reached, and the transaction
is executed. Executing a transaction means that the operations contained in it are performed, which can result in state
changes that are applied to the dapp's state database. The transaction is also recorded on the blockchain, ensuring that
it is immutable and reflected across all nodes.

This concludes our overview of Chromia's architecture. To learn more, visit
[here](https://docs.chromia.com/overview/architecture). Next, we will explore some core concepts of Solidity and
translate them into Chromia and Rell code.

- [Interacting with a Chromia dapp](#interacting-with-a-chromia-dapp)[Skip to main content](#__docusaurus_skipToContent_fallback)

In this lesson, you'll set up your development environment and connect to the Chromia blockchain. You'll import
necessary modules from Chromia `postchain-client`, and you will learn how to implement the different functions in your
front-end app.

Next, you'll query the blockchain and transmit transactions using the client instance. To sign transactions, we will use
the `postchain-client` library. You'll generate a cryptographic keypair to secure transaction signing.

Finally, you'll see a practical example where we create and query for entities.

## Sections

[Prerequisites](/courses/book-review/build-client/prerequisites)

[Connect to the Chromia blockchain](/courses/book-review/build-client/sign-transaction)

[Query the blockchain with postchain-client](/courses/book-review/build-client/query-blockchain)

[Complete the example](/courses/book-review/build-client/complete-example)

[Start lesson »](/courses/book-review/build-client/prerequisites)[Skip to main content](#__docusaurus_skipToContent_fallback)

You may want to deploy the project in two steps; Staging and Production. To create a new deployment you would follow [these steps](https://docs.chromia.com/testnet/deploy-dapp-cli) using `chr deployment create`. When you have two deployments, one for production and one for staging, your `deployments` section of `chromia.yml` might look like this:

```codeBlockLines_e6Vv
deployments:
  staging:
    url: "https://my.staging.dev:7740"
    brid: x"5926EE7B51B728853C8014AD9F208F1001FEE6395B49D14E70B43E4CD9D607C1"
    container: my_staging_container
    chains:
      my-chain: x"18C8F8497FCC86FF6A91CA7CEC46F944A9C39E3E657D79A83DA453219F30368E"
  production:
    url: "https://my.production:7740"
    brid: x"63A8F21DC932C8CE8E9C96DE3D2909DDDE692BBC008D5F50E6A3561CFA47A854"
    container: my_prod_container
    chains:
      my-chain: x"45893974893F4B030AF63DDF7F72564097903012802AB0B3DA6C126751DB90C3"

```

Typically, on the staging network, you may accept bigger types of changes, so resetting the database upon deployment might be a good idea. To do this, you can have two entrypoints, `main.rell` and `development.rell`. The main module serves as entry point for a production environment and in the development module, we import main, and add a operation that resets all tables:

src/development.rell

```codeBlockLines_e6Vv
module;

import main;

operation reset() {
  // Delete all tables:
  // delete foo @* {};
  // etc
}

```

We can then update our `blockchains` tag of `chromia.yml` to use this module based on an environment variable:

chromia.yml

```codeBlockLines_e6Vv
blockchains:
  my-chain:
    module: ${MAIN_MODULE:-main}

```

We can then create the following pipeline jobs:

- Gitlab CI
- Bitbucket Pipelines

```codeBlockLines_e6Vv
deploy-staging:
  stage: deploy
  rules:
    - if: $CI_COMMIT_BRANCH == "development" # development branch name
  variables:
    MAIN_MODULE: development
    POSTCHAIN_CLIENT_PUBKEY: ${CI_SECRET_PUBKEY}
    POSTCHAIN_CLIENT_PRIVKEY: ${CI_SECRET_PRIVKEY}
  script:
    - chr tx reset --network staging --blockchain my-chain
    - chr deployment update --network staging --blockchain my-chain

deploy-production:
  stage: deploy
  rules:
    - if: $CI_COMMIT_BRANCH == "main" # production branch name
  variables:
    MAIN_MODULE: main
    POSTCHAIN_CLIENT_PUBKEY: ${CI_SECRET_PUBKEY}
    POSTCHAIN_CLIENT_PRIVKEY: ${CI_SECRET_PRIVKEY}
  script:
    - chr deployment update --network production --blockchain my-chain

```

In this example we see that we also add a rule for which branch is used. So whenever something is merged to the development branch, we reset and update the staging network, and when deploying to production, we just update. We also add the private and public keys of the deployment admin to the GitLab secrets.

```codeBlockLines_e6Vv
pipelines:
  branches:
    development: # development branch
      - step:
          name: Deploy to Staging
          script:
            - export MAIN_MODULE=development
            - chr tx reset --network staging --blockchain my-chain
            - chr deployment update --network testnet --blockchain my-chain

    main: # production branch
      - step:
          name: Deploy to Production
          script:
            - export MAIN_MODULE=main
            - chr deployment update --network production --blockchain my-chain

```

In this example we create two pipeline steps based of which branch is triggered. When triggered on the development branch, we reset the network and update the deployment. Similarly on the main branch, we update the production network. Note that we have to add the `POSTCHAIN_CLIENT_PUBKEY` and `POSTCHAIN_CLIENT_PRIVKEY` properties to bitbucket pipelines UI containing the keypair for the deployment user.[Skip to main content](#__docusaurus_skipToContent_fallback)

The FT4 session object provides a method to burn tokens. The `burn` method is used to burn tokens from the account.

asset\_management/src/hooks/token-hooks.ts

```codeBlockLines_e6Vv
import { useFtSession } from "@chromia/react";
import { publicClientConfig as clientConfig } from "@/utils/generate-client-config";

interface BurnTokenParams {
  ticker: string;
  name: string;
  amount: number;
}

function useBurnTokens() {
  const { data: ftAccounts } = useFtAccounts({ clientConfig });
  const { data: session } = useFtSession(
    ftAccounts?.length ? { clientConfig, account: ftAccounts[0] } : null,
  );

  const burnTokens = useCallback(
    async (token: BurnTokenParams) => {
      if (!session) return;

      try {
        await session.account.burn(token.ticker, createAmount(token.amount));

        onSuccess?.(token);
      } catch (error) {
        console.error(error);

        onError?.(token);
      }
    },
    [session],
  );

  return burnTokens;
}

```

In the code snippet above, the `burn` method is called on the session object's account property to burn the specified amount of tokens.[Skip to main content](#__docusaurus_skipToContent_fallback)

This course will guide you to explore the blockchain application of the asset management system.

In this course, you will learn how to:

- Basic interaction or rell dapp.
  - Creating operations and queries.
  - Working with accounts and assets.
  - Implementing tests.

## Lessons

[Lesson 1 - Configure the Blockchain dapp](/courses/ft4-demo-app/module-blockchain/setup)

[Lesson 2 - Account Management](/courses/ft4-demo-app/module-blockchain/account-management)

[Lesson 3 - Asset Registration](/courses/ft4-demo-app/module-blockchain/asset-registration)

[Lesson 4 - Test](/courses/ft4-demo-app/module-blockchain/test)

[Start module »](/courses/ft4-demo-app/module-blockchain/setup)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In this section, we will create something more useful: a decentralized news feed where users can create posts and follow
each other. We'll start by designing the core functionality of our news feed to store individual posts and connect them
to a user.

The code shown below should be familiar to Solidity developers:

Solidity

```codeBlockLines_e6Vv
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract NewsFeedClone {
    struct Post {
        string text;
        uint256 timestamp;
        address user;
    }

    struct User {
      string username;
    }

    event PostCreated(address indexed user, string text, uint256 timestamp);
    event UserCreated(address indexed user, string username);

    function createPost(address user, string memory _text) public {
        emit PostCreated(user, _text, block.timestamp);
    }

    function registerUser(string memory username) public {
        emit UserCreated(msg.sender, username);
    }
}

```

Now let's do the same in Rell and then we will look at the differences:

Rell

```codeBlockLines_e6Vv
module;

entity post {
    content: text;
    timestamp: timestamp = op_context.last_block_time;
    author: user;
}

entity user {
    key id: byte_array;
    mutable name;
}

operation register_user(user_id: byte_array, username: text) {
    create user ( id = user_id, name = username );
}

operation create_post(author_id: byte_array, content: text) {
    create post ( user @ { author_id }, content = content );
}

```

As we can see, these implementations are very similar but there are a few key differences. In our Solidity solution, we
emit an event instead of storing the data in the contract. This is done because, on EVM blockchains, gas fees need to be
considered, and storing data and keeping logic in the contract is not a scalable solution. Using Chromia and Rell, we
can store all data on-chain. There is no need to store data outside of your dapp. Our posts will be stored in a
relational database, making it easy to retrieve directly from the dapp using queries, all without worrying about
transaction fees.

## Let's look at the details [​](\#lets-look-at-the-details "Direct link to Let's look at the details")

In Rell, we have the concept of data models, which isn't really the case for Solidity. In these examples, we use the
`struct` keyword to define structures to hold data in Solidity, and in Rell we use `entity`, which is an actual data
model entity. The struct keyword is also available in Rell and works just like in Solidity. Read more on structs
[here](https://docs.chromia.com/rell/language-features/modules/struct). Entities in Rell are similar to tables in a SQL
database. Deploying the code we just wrote will automatically create the necessary tables and relations in Chromia's
distributed relational database. In this example, we also have a relation between a user and their posts. They are part
of the model in both implementations, but in Rell, it becomes an actual database relation. To gain a deeper insight into
managing these relationships, explore our [Understand relationships in Rell](/courses/relationships-course/introduction)
course.

Rell

```codeBlockLines_e6Vv
entity post {
    content: text;
    timestamp = op_context.last_block_time;
    author: user;
}

entity user {
    user_id: byte_array;
    name: text;
}

```

Solidity

```codeBlockLines_e6Vv
struct Post {
    string text;
    uint256 timestamp;
    address user;
}

struct User {
    address user;
    string username;
}

```

Let's look at the Rell parts:

- The `entity` keyword initiates the definition of our entity, similar to defining a table in a database.
- Attributes, like columns in a database table, each hold specific data types related to the entity.
- Our connection between a post and its author is simply defined by adding an attribute `author: user`. This will
automatically set up the relation in the underlying database for the state.

So now we have defined our model and can look at functions to create new instances of the model. We start with Solidity:

Solidity

```codeBlockLines_e6Vv
function createPost(address user, string memory _text) public {
    emit PostCreated(user, _text, block.timestamp);
}

```

Sending a transaction calling the `createPost` function will result in an event being emitted to the Event log with data
for the post. Emitting events in Solidity is a gas-efficient way to record information. Since transactions on Ethereum
require gas, optimizing your smart contract to reduce the amount of on-chain data storage (which is expensive) is wise.
Events log data in transaction receipts and don't consume as much gas as storing data directly on the blockchain.
However, there is a trade-off between centralization and decentralization with this approach.

In Rell, the function is similar:

Rell

```codeBlockLines_e6Vv
operation create_post(author_id: byte_array, content: text) {
    val author = user @ { author_id }
    create post ( author, content = content );
}

```

An operation in Rell is a function where the body contains logic to change the dapp's state. A transaction can contain
one or many operations, and the logic of each operation will alter the dapp table state. The `create` keyword is used to
insert a new post in the dapp state. Since we want to connect the author to the post, we first fetch the entity and then
use it as a parameter in our create call. When this transaction is executed, a new post is inserted into the state with
a relation to the author, and then the transaction is added to the Chromia blockchain.

## Fetching posts for a user [​](\#fetching-posts-for-a-user "Direct link to Fetching posts for a user")

Now that we have our model set up with relationships between users and posts in both Solidity and Rell, we can set up
methods for fetching posts for a specific user. Since our Solidity contract emits events to the log when we add a new
post, we need to query the event log instead of interacting directly with the smart contract to fetch posts.

Solidity

```codeBlockLines_e6Vv
const contract = new web3.eth.Contract(contractABI, contractAddress);

contract
  .getPastEvents("PostCreated", {
    filter: {
      user: "0x123...", // Ethereum address of the user
    },
    fromBlock: fetchFromBlock,
    toBlock: "latest",
  })
  .then(function (events) {
    console.log(events);
    // Perform logic here
  });

```

In this example, we use web3.js to fetch and filter events. In a real app, we would probably put this in the backend and
expose this function to the client using an API. In Chromia and Rell, we can stay on-chain to fetch our data.

Rell

```codeBlockLines_e6Vv
query get_my_posts(user_id: byte_array) {
    val user = user @ { .id == user_id };
    return post @* { .author == user } ( .content );
}

```

Since we have a more relational approach, we can create a strongly typed query for all posts of a specific user. This is
done in just two lines of code, and the query syntax is a form of query language. Let's dissect it a bit.

First, we call `val user = user @ { .id == user_id }`, this query uses `user @` to fetch a single entity and then we add
the filter `{ .id == user_id }` to specify which user to fetch. Our next query uses the `@*` operator in `post @*` to
retrieve a collection of post entities. `@*` means that we expect 0 or more objects of this type from the query. The
curly braces at the end, as seen in `post @* { .author == user }`, specify our filter criteria for the query. The
subsequent segment of the query defines which attributes we wish to retrieve, in this case, `.content`. More about
operators and database operations can be found
[here](https://docs.chromia.com/rell/language-features/database/overview).

This summarizes the first part of the news feed dapp and the corresponding smart contract in Solidity. Our app can now
create posts and keep track of which posts belong to which user.

- [Let's look at the details](#lets-look-at-the-details)
- [Fetching posts for a user](#fetching-posts-for-a-user)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In this section, we will learn about signing transactions, which involves verifying the authenticity of the user who is
sending the transaction to the blockchain.

We will create an administration function for a bookkeeper responsible for managing and adding books available for
review. Only a specific administrator will be authorized to sign the transactions required for this task..

## Setup module arguments [​](\#setup-module-arguments "Direct link to Setup module arguments")

We will use module arguments to ensure that only the administrator can add books. These arguments configure a module on
the Chromia blockchain and enable access to variables from a context called `chain_context`. Here's how to set it up:

### Create a keypair [​](\#create-a-keypair "Direct link to Create a keypair")

First, generate a new keypair for the administrator, which will be used to sign transactions. Run the following command
in your project folder:

```codeBlockLines_e6Vv
chr keygen --file .chromia/config

```

This command generates a new keypair and stores it in a file called `.chromia/config` within your project folder.

### Define a struct for module arguments [​](\#define-a-struct-for-module-arguments "Direct link to Define a struct for module arguments")

We need to define a struct to hold our module arguments. This struct should be added to the module where you want to
access these arguments. For this example, add it to `src/main/entities.rell`:

src/main/entities.rell

```codeBlockLines_e6Vv
struct module_args {
  admin_pubkey: byte_array;
}

```

### Configure module arguments in `chromia.yml` [​](\#configure-module-arguments-in-chromiayml "Direct link to configure-module-arguments-in-chromiayml")

Next, define the module arguments in the `chromia.yml` configuration file. Update your `chromia.yml` file as follows:

```codeBlockLines_e6Vv
blockchains:
  book-review:
    module: main
    moduleArgs:
      main:
        admin_pubkey: <pubkey from .chromia/config>

```

**Explanation of example configuration:**

- **`book-review`**: The name of your blockchain configuration. This should correspond to the blockchain configuration
you are working with.
- **`module: main`**: Specifies that the `main` module is used for this blockchain configuration.
- **`moduleArgs`**: Under this section, you define arguments specific to the module.
  - **`main`**: This should match the module name defined in your source code.
  - **`admin_pubkey`**: This is the argument name that the module will use to verify the administrator's public key.
  - **`<pubkey from .chromia/config>`**: Replace this placeholder with the actual public key extracted from the
    `.chromia/config` file. This key is used to authorize administrative actions.

For more details on the `chromia.yml` configuration file, visit the
[Chromia project settings documentation](https://docs.chromia.com/project-config/).

## Require signed transactions [​](\#require-signed-transactions "Direct link to Require signed transactions")

Now, update our `create_book` operation to require that the administrator signs the transaction. Modify
`src/main/operations.rell` with the following code:

src/main/operations.rell

```codeBlockLines_e6Vv
operation create_book(isbn: text, title: text, author: text) {
  val adminPubkey = chain_context.args.admin_pubkey;
  require(op_context.is_signer(adminPubkey), "Only admin can create books");

  create book ( .isbn = isbn, .title = title, .author = author );
}

```

Here’s what happens in this operation:

- **Retrieve the administrator's public key**: `val adminPubkey = chain_context.args.admin_pubkey;`
  - This fetches the public key from the module arguments defined in `chain_context`.
- **Check if the transaction is signed by the administrator**:
`require(op_context.is_signer(adminPubkey), "Only admin can create books");`
  - This checks if the transaction is signed with the administrator's public key. If not, it throws an error message:
    `"Only admin can create books"`.

This ensures that only transactions signed by the administrator can create books.

## Setup and test signing [​](\#setup-and-test-signing "Direct link to Setup and test signing")

To test the transaction signing, we will update existing test functions to verify the correct behaviour.

### Step 1: Update `test_add_book` [​](\#step-1-update-test_add_book "Direct link to step-1-update-test_add_book")

First, add a local keypair for testing in your test file `src/test/book_review_test.rell`:

src/test/book\_review\_test.rell

```codeBlockLines_e6Vv
val book_keeper = rell.test.keypair(
    priv = x"DEE3B1414196653BF7FA621B2EEFC3146093B1932BA2ABFAEED830906D81972A",
    pub = x"0359A8F2CE1BEF95F583169B7DF053AA227A93B2652B0A9C22975FEED638032610"
);

```

This creates a test keypair for `book_keeper` with the provided private and public keys.

Next, update your `chromia.yml` to include this new keypair:

chromia.yml

```codeBlockLines_e6Vv
blockchains:
  book-review:
    module: main
    moduleArgs:
      main:
        admin_pubkey: <pubkey from .chromia/config>
compile:
  rellVersion: 0.13.5
database:
  schema: schema_hello
test:
  modules:
    - test
  moduleArgs:
    main:
      admin_pubkey: "0359A8F2CE1BEF95F583169B7DF053AA227A93B2652B0A9C22975FEED638032610"

```

In the `test` section, we set the `admin_pubkey` to the same public key used for `book_keeper`.

Now, update the existing `test_add_book` function to use the `book_keeper` keypair:

src/test/book\_review\_test.rell

```codeBlockLines_e6Vv
function test_add_book() {
    rell.test.tx()
        .op(create_book("123", "Book1", "Author1"))
        .op(create_book("124", "Book2", "Author2"))
        .sign(book_keeper)
        .run();

    val all_books = book @* { };

    assert_equals(all_books.size(), 2);
    assert_equals(all_books[0].title, "Book1");
    assert_equals(all_books[0].author, "Author1");
}

```

### Step 2: Update `test_add_book_review` [​](\#step-2-update-test_add_book_review "Direct link to step-2-update-test_add_book_review")

Update the existing `test_add_book_review` function to use the `book_keeper` keypair:

src/test/book\_review\_test.rell

```codeBlockLines_e6Vv
function test_add_book_review() {
    rell.test.tx()
        .op(create_book("123", "Book1", "Author1"))
        .op(create_book_review("123", "Reviewer1", "ReviewText1", 5))
        .op(create_book_review("123", "Reviewer2", "ReviewText2", 3))
        .sign(book_keeper)
        .run();

    val reviews = book_review @* { };
    val book = book @ { .isbn == "123" };

    assert_equals(reviews.size(), 2);
    assert_equals(book, reviews[0].book);
    assert_equals(reviews[0].reviewer_name, "Reviewer1");
    assert_equals(reviews[0].review, "ReviewText1");
    assert_equals(reviews[0].rating, 5);
}

```

### Step 3: Update `test_get_books` [​](\#step-3-update-test_get_books "Direct link to step-3-update-test_get_books")

Add the new `test_get_books` function to verify the creation of books:

src/test/book\_review\_test.rell

```codeBlockLines_e6Vv
function test_get_books() {
    rell.test.tx()
        .op(create_book("123", "Book1", "Author1"))
        .op(create_book("124", "Book2", "Author2"))
        .sign(book_keeper)
        .run();

    val reviews = get_all_books();
    assert_equals(reviews.size(), 2);
}

```

### Step 4: Test non-administrator access [​](\#step-4-test-non-administrator-access "Direct link to Step 4: Test non-administrator access")

To further verify security, create another test where a keypair not configured as an administrator attempts to sign a
transaction.

The available users/keypairs are:

```codeBlockLines_e6Vv
bob, alice, trudy, charlie, dave, eve, frank, grace, heidi

```

Add a definition for the `bob` keypair in your test file:

src/test/book\_review\_test.rell

```codeBlockLines_e6Vv
val bob = rell.test.keypairs.bob;

```

And use this keypair in a test to sign the `create_book` transaction:

src/test/book\_review\_test.rell

```codeBlockLines_e6Vv
function test_add_book_as_non_admin() {
    rell.test.tx()
        .op(create_book("123", "Book1", "Author1"))
        .sign(bob)
        .run_must_fail();
}

```

note

This test is expected to fail, which means it is correctly passing the test condition. Bob's public key is not listed as
an administrator in the module arguments, so the transaction should fail.

## Run tests [​](\#run-tests "Direct link to Run tests")

After updating your tests, run them to verify everything is working as expected:

```codeBlockLines_e6Vv
chr test

```

This command will execute all the test functions and ensure that the transaction signing and authorization are working
correctly.

- [Setup module arguments](#setup-module-arguments)
  - [Create a keypair](#create-a-keypair)
  - [Define a struct for module arguments](#define-a-struct-for-module-arguments)
  - [Configure module arguments in `chromia.yml`](#configure-module-arguments-in-chromiayml)
- [Require signed transactions](#require-signed-transactions)
- [Setup and test signing](#setup-and-test-signing)
  - [Step 1: Update `test_add_book`](#step-1-update-test_add_book)
  - [Step 2: Update `test_add_book_review`](#step-2-update-test_add_book_review)
  - [Step 3: Update `test_get_books`](#step-3-update-test_get_books)
  - [Step 4: Test non-administrator access](#step-4-test-non-administrator-access)
- [Run tests](#run-tests)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

To get started, ensure the following prerequisites are installed:

Set up PostgreSQL database

Rell requires PostgreSQL 16.3. The IDE can work without it but can't run a node. A console or a remote postchain app can
run without a database.

The default database configuration for Rell is:

- database: `postchain`
- user: `postchain`
- password: `postchain`

## Install [​](\#install "Direct link to Install")

- Mac
- Linux
- Docker
- Windows

1. Install Homebrew: [Homebrew installation guide](https://brew.sh/)

2. Install PostgreSQL:





```codeBlockLines_e6Vv
brew install postgresql@16
brew services start postgresql@16
createuser -s postgres

```

3. Prepare the PostgreSQL database:





```codeBlockLines_e6Vv
psql -U postgres -c "CREATE DATABASE postchain WITH TEMPLATE = template0 LC_COLLATE = 'C.UTF-8' LC_CTYPE = 'C.UTF-8' ENCODING 'UTF-8';" -c "CREATE ROLE postchain LOGIN ENCRYPTED PASSWORD 'postchain'; GRANT ALL ON DATABASE postchain TO postchain;"

```











note





If you get an error saying peer authentication failed, you must change the authentication method from `peer` to
`md5`. You can change it in the `pg_hba.conf` file of your `psql` database.


1. Install PostgreSQL:





```codeBlockLines_e6Vv
sudo apt install postgresql-16

```

2. Prepare the PostgreSQL database:





```codeBlockLines_e6Vv
sudo -u postgres psql -c "CREATE DATABASE postchain WITH TEMPLATE = template0 LC_COLLATE = 'C.UTF-8' LC_CTYPE = 'C.UTF-8' ENCODING 'UTF-8';" -c "CREATE ROLE postchain LOGIN ENCRYPTED PASSWORD 'postchain'; GRANT ALL ON DATABASE postchain TO postchain;"

```


1. Install Docker: [Docker installation guide](https://docs.docker.com/engine/install/)

2. Prepare the PostgreSQL database:





```codeBlockLines_e6Vv
docker run --name postgres -e POSTGRES_USER=postchain -e POSTGRES_PASSWORD=postchain -p 5432:5432 -d postgres:16.3-alpine3.20

```











note





We use the Alpine version of PostgreSQL because it provides the correct collation settings by default. This can be
explicitly set using the environment variable:







```codeBlockLines_e6Vv
POSTGRES_INITDB_ARGS="--lc-collate=C.UTF-8 --lc-ctype=C.UTF-8 --encoding=UTF-8"

```


1. Download the PostgreSQL installer from the [official website](https://www.postgresql.org/download/windows/).

2. Install the executable and add the PostgreSQL folder containing the binaries to your environment variables. Open the
Command Prompt (CMD) and run the following command, ensuring that you set the path to your binaries correctly and
replace the `<version>` placeholder with the actual version number:





```codeBlockLines_e6Vv
setx POSTGRESQL "C:\Program Files\PostgreSQL\<version>\bin"

```

3. Reopen the Command Prompt (CMD) to update the environment variables. Prepare the PostgreSQL database by running the
following two commands sequentially:





```codeBlockLines_e6Vv
psql -U postgres -c "CREATE DATABASE postchain WITH TEMPLATE = template0 LC_COLLATE = 'en_US.UTF-8' LC_CTYPE = 'en_US.UTF-8' ENCODING 'UTF-8';"
psql -U postgres -c "CREATE ROLE postchain LOGIN ENCRYPTED PASSWORD 'postchain'; GRANT ALL ON DATABASE postchain TO postchain;"

```











note





Depending on your Windows version, you may encounter various errors related to permissions or incorrect PostgreSQL
installations. If this happens, we recommend installing Docker and deploying the PostgreSQL container.


Install Chromia CLI

This topic contains instructions to install and update the
[Chromia CLI](https://gitlab.com/chromaway/core-tools/chromia-cli).

## Prerequisite [​](\#prerequisite "Direct link to Prerequisite")

Before proceeding, make sure the following prerequisites are met:

- **PostgreSQL database**: See [Set up PostgreSQL database](/docs/install/database-setup).
- **RELL\_JAVA environment**: Chromia CLI do requries a java runtime (version 21 or later) to execute. Through the
different package managers this has been abstracted away for you so you don't need to set this up. If you want to
control which java runtime you use to execute Chromia CLI with it is recomended to set RELL\_JAVA variable in your
environment to point to a valid Java installation

## Installation [​](\#installation "Direct link to Installation")

You can install Chromia CLI using a package manager or by downloading it directly from
[Chromia CLI Packages](https://gitlab.com/chromaway/core-tools/chromia-cli/-/packages).

- macOS
- Linux/WSL
- Windows

To install Chromia CLI ( `chr`) on macOS, follow these steps:

1. If Homebrew is not installed, install it by running:





```codeBlockLines_e6Vv
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

```

2. Add the Chromia repository to Homebrew by running the following command:





```codeBlockLines_e6Vv
brew tap chromia/core https://gitlab.com/chromaway/core-tools/homebrew-chromia.git

```

3. Install Chromia CLI with:





```codeBlockLines_e6Vv
brew install chromia/core/chr

```











info





To install a specific version of Chromia CLI, use the following commands:







```codeBlockLines_e6Vv
brew install chromia/core/chr@<version>
brew unlink chr
brew link chr@<version>

```











You can list available versions using: `brew search chr`.

4. To verify the installation, check the version by running:





```codeBlockLines_e6Vv
chr --version

```


To install Chromia CLI ( `chr`) on Linux or WSL (Windows Subsystem for Linux), follow these steps:

1. Download and add Chromia's `apt-repo` public key to your system’s trusted keyrings:





```codeBlockLines_e6Vv
curl -fsSL https://apt.chromia.com/chromia.gpg | sudo tee /usr/share/keyrings/chromia.gpg

```

2. Add the Chromia repository to your list of package sources:





```codeBlockLines_e6Vv
echo "deb [arch=amd64 signed-by=/usr/share/keyrings/chromia.gpg] https://apt.chromia.com stable main" | sudo tee /etc/apt/sources.list.d/chromia.list

```

3. Run the following command to update your package sources:





```codeBlockLines_e6Vv
sudo apt-get update

```











info





If you added `apt.chromia.com` before Chromia CLI version `0.16.0`, run the following command to allow the repository
update:







```codeBlockLines_e6Vv
sudo apt-get --allow-releaseinfo-change update

```

4. Once the repository is updated, install Chromia CLI by running:





```codeBlockLines_e6Vv
sudo apt-get install chr

```

5. To verify that Chromia CLI is installed successfully, check the version:





```codeBlockLines_e6Vv
chr --version

```


To install Chromia CLI ( `chr`) on Windows using [Scoop](https://scoop.sh/), follow these steps:

1. If Scoop is not installed, install it by running the following command in PowerShell (run as Administrator):





```codeBlockLines_e6Vv
iwr -useb get.scoop.sh | iex

```

2. Add the Chromia repository (bucket) to Scoop by running:





```codeBlockLines_e6Vv
scoop bucket add chromia https://gitlab.com/chromaway/core-tools/scoop-chromia/

```

3. Add the Java bucket to Scoop by running:





```codeBlockLines_e6Vv
scoop bucket add java

```









This will enable scoop to download the openjdk21 which chromia-cli depends on when installing

4. Install Chromia CLI by running:





```codeBlockLines_e6Vv
scoop install chr

```

5. To verify that Chromia CLI is installed successfully, check the version:





```codeBlockLines_e6Vv
chr --version

```


## Updating Chromia CLI [​](\#updating-chromia-cli "Direct link to Updating Chromia CLI")

You can download and install the latest Chromia CLI from
[here](https://gitlab.com/chromaway/core-tools/chromia-cli/-/packages), or if you have installed the Chromia CLI via a
package manager, you can update it with the following:

- macOS
- Linux
- Windows

```codeBlockLines_e6Vv
brew update
brew upgrade chr

```

```codeBlockLines_e6Vv
sudo apt-get update
sudo apt-get install chr

```

```codeBlockLines_e6Vv
scoop update
scoop update chr

```

## Docker [​](\#docker "Direct link to Docker")

Docker can run a standalone Linux container with the Chromia CLI pre-installed. Make sure that you have set up the
[PostgreSQL database](/docs/install/database-setup).

To use the published Docker images, you must first have Docker installed and configured on your host machine. Please
refer to the Docker documentation on how to [install Docker](https://docs.docker.com/get-docker/) on Windows, Mac, and
Linux.

### Start the Docker container with Chromia CLI pre-installed [​](\#start-the-docker-container-with-chromia-cli-pre-installed "Direct link to Start the Docker container with Chromia CLI pre-installed")

To run the latest version of the Chromia CLI, use the `docker run` command and specify the CLI Docker image name and
`chr`.

```codeBlockLines_e6Vv
docker run --rm -v $(pwd):/usr/app registry.gitlab.com/chromaway/core-tools/chromia-cli/chr:<latest version> chr

```

note

Make sure to configure your `chromia.yml` file correctly:

- **Mac**: Use `host.docker.internal` for `database:host`.
- **Windows**: Set `database:host` to `172.17.0.1`.
- **Linux**: Use the `--network=host` argument in Docker commands.

These configurations are crucial to ensure connectivity between Chromia CLI and the PostgreSQL instance.

See the [Docker command line reference](https://docs.docker.com/engine/reference/commandline/docker/) for more
information on updating or uninstalling the Docker image.

```codeBlockLines_e6Vv
#!/bin/bash

# Allocate a pseudo-TTY one when run in interactive mode
if [ -t 0 ] && [ -t 1 ] ; then TTY="--tty"; else TTY=""; fi

docker run \
  # Sets the network to host to not need to change the database hostname (linux only)
  --network=host \
  # Set timezone based on system settings (linux only)
  -e TZ=$(cat /etc/timezone) \
  # Sets process ownership to current user
  --user $(id -u):$(id -g) \
  --mount type=bind,source="/etc/passwd",target=/etc/passwd,readonly \
  --mount type=bind,source="/etc/group",target=/etc/group,readonly \
  # Configures ssh-agent (only needed if chr install is called on non-public repositores)
  -e SSH_AUTH_SOCK=$SSH_AUTH_SOCK \
  --volume "$SSH_AUTH_SOCK:$SSH_AUTH_SOCK" \
  --mount type=bind,source="${HOME}/.ssh",target=${HOME}/.ssh,readonly \
  --mount type=bind,source="${HOME}/.config/jgit",target=${HOME}/.config/jgit \
  # Mounts current folder into the container (Use `Get-Location` on PowerShell)
  --mount type=bind,source="$(pwd)",target=/usr/app \
  --interactive ${TTY} \
  --rm \
  registry.gitlab.com/chromaway/core-tools/chromia-cli/chr:${CHR_VERSION:-latest} chr "$@"

```

## Clone the repository [​](\#clone-the-repository "Direct link to Clone the repository")

Clone the course repository:

```codeBlockLines_e6Vv
git clone https://bitbucket.org/chromawallet/chat-agent-course.git

```

## Navigate to the project directory [​](\#navigate-to-the-project-directory "Direct link to Navigate to the project directory")

Enter the project folder:

```codeBlockLines_e6Vv
cd chat-agent-course

```

## Install the necessary libraries [​](\#install-the-necessary-libraries "Direct link to Install the necessary libraries")

```codeBlockLines_e6Vv
npm install

```

Now, you’re ready to proceed with the course.

- [Install](#install)
- [Prerequisite](#prerequisite)
- [Installation](#installation)
- [Updating Chromia CLI](#updating-chromia-cli)
- [Docker](#docker)
  - [Start the Docker container with Chromia CLI pre-installed](#start-the-docker-container-with-chromia-cli-pre-installed)
- [Clone the repository](#clone-the-repository)
- [Navigate to the project directory](#navigate-to-the-project-directory)
- [Install the necessary libraries](#install-the-necessary-libraries)[Skip to main content](#__docusaurus_skipToContent_fallback)

This guide will teach us how to use the Chromia CLI to write and execute pipelines for testing and deploying Rell code on the Chromia blockchain platform. The provided pipeline file defines different stages for building, testing, and deploying Rell code. We will explain each step and its corresponding actions.

**Defining base image**

First, we will define the base image to use in our pipelines. In this example, we are using the `latest` tag, but it is recommended to use a fixed version so as not to get any surprises.

- GitLab CI
- Bitbucket Pipelines

```codeBlockLines_e6Vv
image: registry.gitlab.com/chromaway/core-tools/chromia-cli/chr:latest

```

```codeBlockLines_e6Vv
image: registry.gitlab.com/chromaway/core-tools/chromia-cli/chr:latest

```

**Building the project**

In this stage, we build the blockchain configurations for all configured blockchains in our project and save them as artifacts.

- GitLab CI
- Bitbucket Pipelines

We also define the stages `build`, `test`, and `deploy` to which we will attach our jobs later.

```codeBlockLines_e6Vv
stages:
  - build
  - test
  - deploy

build:
  stage: build
  script:
    - chr build
  artifacts:
    when: on_success
    paths:
      - build/*.xml

```

```codeBlockLines_e6Vv
pipelines:
  default:
    - step:
        name: Build
        script:
          - chr build
        artifacts:
          - build/**

```

caution

Remember that if your project has dependencies, your script must also run `chr install` before any other action, such as build, test, or start.

**Running tests**

To run unit tests, we need to add a Postgres service container. We use the Alpine version of the image since it has the expected collation settings.

- GitLab CI
- Bitbucket Pipelines

We also define global variables for database properties that can be reused in the integration test job.

```codeBlockLines_e6Vv
variables:
  POSTGRES_DB: postchain
  POSTGRES_USER: postchain
  POSTGRES_PASSWORD: postchain
  CHR_DB_URL: jdbc:postgresql://postgres/postchain

test:
  stage: test
  services:
    - postgres:15-alpine
  script: chr test --test-report
  artifacts:
    when: always
    reports:
      junit: build/reports/*.xml

```

We add Postgres in the definitions section and configure it as a service container in the pipeline.

```codeBlockLines_e6Vv
definitions:
  services:
    postgres:
      image: "postgres:15-alpine"
      variables:
        POSTGRES_DB: postchain
        POSTGRES_USER: postchain
        POSTGRES_PASSWORD: postchain

pipelines:
  default:
    - step:
        name: Test
        services:
          - postgres
        script:
          - export CHR_DB_URL=jdbc:postgresql://localhost:5432/postchain
          - chr test --test-report --test-report-dir build/test-reports
        artifacts:
          - build/test-reports/*.xml

```

In the integration test job, we start by running a test node on a background thread and wait for the messaging port 9870 to be exposed before proceeding. If your integration tests are run in TypeScript, Kotlin, or any other language than shell, using frameworks such as [Testcontainers](https://testcontainers.com) to start the test node as a sidecar is a good choice. Read the guide on [how to set this up in TypeScript here](/courses/rell-integration-test/introduction).

- GitLab CI
- Bitbucket Pipelines

```codeBlockLines_e6Vv
integration-test:
  stage: test
  services:
    - postgres:15-alpine
  before_script:
    - chr node start &
    - while ! nc -z localhost 9870; do sleep 1; done; sleep 1
  script:
    - chr tx --await set_name Alice
    - $([ "$(chr query hello_world)" = "\"Hello Alice!\"" ])
  artifacts:
    when: on_failure
    paths:
      - logs/*.log

```

```codeBlockLines_e6Vv
pipelines:
  default:
    - step:
        name: Integration Test
        services:
          - postgres
        script:
          - chr node start &
          - while ! nc -z localhost 9870; do sleep 1; done; sleep 1
          - chr tx --await set_name Alice
          - $([ "$(chr query hello_world)" = "\"Hello Alice!\"" ])
        artifacts:
          - logs/**

```[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Rell is the programming language of Chromia, designed for building decentralized applications (dapps). It integrates
relational data models seamlessly, providing an efficient and intuitive way to develop robust applications on the
blockchain. For more details, visit the [Rell introduction](https://docs.chromia.com/rell/rell-intro).

## Organizing your project [​](\#organizing-your-project "Direct link to Organizing your project")

To structure your project effectively, we'll organize the code into dedicated files and folders. This approach ensures
clarity, ease of management, and scalability.

### Project setup [​](\#project-setup "Direct link to Project setup")

1. Create the main module folder:
   - Since this project will consist of a single module, create a new folder named `main` within the `src` directory.
     This folder will house all module-specific files.
2. Set up essential files:
   - Inside the `main` folder, create the following files:
     - `module.rell`
     - `entities.rell`
     - `functions.rell`
     - `operations.rell`
     - `queries.rell`
3. Initialize the module ( `module.rell`):


   - In the `module.rell` file, add the following code:

src/main/module.rell

```codeBlockLines_e6Vv
module;

```

   - The `module;` code in this file is a requirement in Rell. It declares the presence of a module and tells Rell to
     treat the contents of this folder as a single module, which helps organize and manage code effectively.
4. Delete the existing `main.rell` file:
   - The `src` folder currently contains a file named `main.rell`. While it's possible to place all your code in this
     file, adopting a modular structure with multiple files is much clearer and better organized. As part of the
     restructuring process, go ahead and delete the existing `main.rell` file.

Your project should now be structured like this:

```codeBlockLines_e6Vv
book-review/
├── src/
│   ├── main/
│   │   ├── entities.rell
│   │   ├── functions.rell
│   │   ├── module.rell
│   │   ├── operations.rell
│   │   └── queries.rell
│   └── test/
│       └── book_review_test.rell
├── .gitignore
└── chromia.yml

```

Each file serves a specific purpose within the project, promoting clear organization and efficient management as your
application evolves. In the following sections, we will explore each component in detail, starting with defining
entities in Rell and progressively building out the decentralized application.

- [Organizing your project](#organizing-your-project)
  - [Project setup](#project-setup)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Now that we have a mechanism to add reviews connected to books, we need a way to retrieve them. We'll define a query for
that.

## Define the query [​](\#define-the-query "Direct link to Define the query")

Open the file `src/main/queries.rell` and add the following Rell code:

src/main/queries.rell

```codeBlockLines_e6Vv
query get_all_reviews_for_book(isbn: text) {
  val reviews = book_review @* { .book.isbn == isbn } (
    .reviewer_name,
    .review,
    .rating
  );
  return reviews;
}

```

### Breakdown of the query [​](\#breakdown-of-the-query "Direct link to Breakdown of the query")

1. **Input Parameter:** The query takes an `isbn` parameter to specify which book's reviews you want to retrieve.
2. **Join Operation:** `val reviews = book_review @* { .book.isbn == isbn };` retrieves all `book_review` entities where
the `book.isbn` matches the given `isbn`.
3. **Attributes:** We specify which attributes to include in the result by adding:




```codeBlockLines_e6Vv
(
     .reviewer_name,
     .review,
     .rating
);

```


This query retrieves all reviews for a specified book, including the reviewer's name, the review text, and the rating.

## Test it on a local Chromia node [​](\#test-it-on-a-local-chromia-node "Direct link to Test it on a local Chromia node")

Testing on a local Chromia node is done using the Chromia CLI. Here are the steps:

1. **Update or start the local Chromia node:**
   - **If the node is already running**, use the following command to update it:





     ```codeBlockLines_e6Vv
     chr node update

     ```

   - **If the node is not already running**, start it with:





     ```codeBlockLines_e6Vv
     chr node start

     ```











     note





     After running `chr node update`, the query might take a moment to become available. You may need to wait for the
     following block to be processed before executing the query. If you get a "400 Bad Request" error, please wait a few
     moments and try again.
2. **Execute the query:** In a new terminal window or tab, run the following command to fetch all reviews for a book:





```codeBlockLines_e6Vv
chr query get_all_reviews_for_book "isbn=ISBN1234"

```









The expected result should be:





```codeBlockLines_e6Vv
[\
     {\
       "rating": 5,\
       "review": "It was a great book",\
       "reviewer_name": "Alice"\
     }\
]

```


## Summary [​](\#summary "Direct link to Summary")

In this lesson, we:

1. Defined a `book_review` entity in Chromia's Rell.
2. Implemented a query to retrieve all reviews for a specific book.

In upcoming lessons, we'll explore Rell's powerful capabilities further, including handling validation, structuring
results from queries and executing transactions with signatures.

- [Define the query](#define-the-query)
  - [Breakdown of the query](#breakdown-of-the-query)
- [Test it on a local Chromia node](#test-it-on-a-local-chromia-node)
- [Summary](#summary)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In this section, we'll define the `Book` entity using Rell. This will allow us to manage book data and perform queries
on it.

## Define the `Book` entity [​](\#define-the-book-entity "Direct link to define-the-book-entity")

In Rell, entities are similar to tables in relational databases. We'll create a `Book` entity to manage the book
information.

### Entity diagram [​](\#entity-diagram "Direct link to Entity diagram")

booktextisbntexttitletextauthor

### Add the entity definition [​](\#add-the-entity-definition "Direct link to Add the entity definition")

Open the `src/main/entities.rell` file and insert the following Rell code:

src/main/entities.rell

```codeBlockLines_e6Vv
entity book {
  key isbn: text;
  title: text;
  author: text;
}

```

### Code explanation [​](\#code-explanation "Direct link to Code explanation")

- **`entity` keyword:** Defines a new entity, similar to creating a table in a database.
- **Attributes:**
  - `key isbn: text`: Sets `isbn` as the unique identifier for each book. The `key` keyword ensures uniqueness and
    `text` specifies that the `isbn` is stored as text.
  - `title: text` and `author: text`: Define the `title` and `author` attributes, both stored as text.

With the `Book` entity defined, you can now use it in your decentralized application.

- [Define the `Book` entity](#define-the-book-entity)
  - [Entity diagram](#entity-diagram)
  - [Add the entity definition](#add-the-entity-definition)
  - [Code explanation](#code-explanation)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

With our core in place we can now add the ability to follow other users and read a feed of their posts. Adding this functionality is clear in both Solidity and Rell. Let's start by extending our Solidity contract.

We add a function to follow a user, which takes both the address of the user and the user we want to follow. Then, an event is emitted to store the relationship between the user and the user to follow. In the upcoming authentication section, we will show how to make this more secure using the authenticated user, but for now, we take both users as parameters.

Solidity

```codeBlockLines_e6Vv
event FollowUser(address indexed user, address indexed userToFollow);

function followUser(address user, address userToFollow) public {
    emit FollowUser(user, userToFollow);
}

```

In Rell, we add an entity `follow` which defines a many-to-many relationship between a user and a follower. Then we add a function that creates a new entry in our relationship table. Again, we can store all data on-chain in our dapp.

Rell

```codeBlockLines_e6Vv
entity follow {
    index user;
    index follows: user;
    key user, follows;
}

// Then we add a follow method to follow a user
operation follow_user(user_id: byte_array, user_id_to_follow: byte_array) {
    val user = user @ { .id == user_id };
    val to_follow = user @ { .id == user_id_to_follow };
    create follow ( user = user, follows = to_follow );
}

```

Breaking it down, our operation `follow_user` first fetches the entities for our two users. Then, it creates a new entry for our follow entity, establishing the relationship between a user and the user they follow. We can also simplify this by doing our user queries inline:

Rell

```codeBlockLines_e6Vv
operation follow_user(user_id: byte_array, user_id_to_follow: byte_array) {
    create follow ( user = user @ { .id == user_id }, follows = user @ { .id == user_id_to_follow } );
}

```

## Fetching posts from followers [​](\#fetching-posts-from-followers "Direct link to Fetching posts from followers")

Now that we have the model and operations in place to follow users, let's look at how we can retrieve a feed from our followers. In Solidity, we need to do this in several steps. First, we fetch the followed users by querying the event log for `FollowUser` events matching our user's address. After this, we do another query where we iterate over our followed users and fetch their posts.

Solidity

```codeBlockLines_e6Vv
const contract = new web3.eth.Contract(contractABI, contractAddress);

async function getFollowedUsers(web3, contract, userAddress) {
    const followEvents = await contract.getPastEvents('FollowUser', {
        filter: { user: userAddress },
        fromBlock: 0,
        toBlock: 'latest'
    });

    return followEvents.map(event => event.returnValues.userToFollow);
}

async function getPostsOfFollowedUsers(web3, contract, followedUsers) {
    let posts = [];

    for (const user of followedUsers) {
        const userPosts = await contract.getPastEvents('PostCreated', {
            filter: { user: user },
            fromBlock: 0,
            toBlock: 'latest'
        });

        posts = posts.concat(userPosts.map(event => ({
            user: event.returnValues.user,
            text: event.returnValues.text,
            timestamp: new web3.utils.BN(event.returnValues.timestamp).toNumber(),
        })));
    }

    return posts;
}

const followedUsers = await getFollowedUsers(web3, contract, 'userAddress');
const posts = await getPostsOfFollowedUsers(web3, contract, followedUsers);

```

This is a cumbersome way to fetch relational data. There are solutions to offload this into a relational database for frontend querying, but this increases complexity and makes the solution more centralized. In Rell, this can be handled efficiently on-chain, thanks to its relational approach. This code snippet shows a query that fetches all posts from users that the specified user is following.

Rell

```codeBlockLines_e6Vv
query get_posts_from_followers(user_id: byte_array) {
    val posts = (user, follow, post) @* {
        .id == user_id, // Join on user id
        follow.user == user, // Join on who the user follows
        post.author == follow.follows // Join on posts for who the user follows
    } (
        post.timestamp,
        post.content,
        user_id = user_id
    );

    return (
        posts = posts
    );
}

```

In this query, we use joins to fetch all data in one go. Since Chromia's blockchain is relational and based on PostgreSQL, this is a very efficient query. With this section, we start seeing all the benefits of using a relational blockchain on Chromia. Next, we'll look into authentication in both Solidity and Rell.

- [Fetching posts from followers](#fetching-posts-from-followers)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Let's first explore some core concepts of development in Solidity and see how they translate to Rell before we get into
practical examples. We will cover these topics which introduce the foundations of blockchain development:

- Setting up your smart contracts and dapps
- Declaring state variables and models
- Interacting with your dapp/smart contract
- Using internal functions
- Querying for data

## Smart contract and dapp states [​](\#smart-contract-and-dapp-states "Direct link to Smart contract and dapp states")

We'll start by defining a contract in Solidity, adding a struct and a state variable, and then do the same in Rell.

**Solidity:**

Solidity

```codeBlockLines_e6Vv
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CompanyManager {
     // Define struct for our data
     struct Company {
        string name;
        string full_address;
    }

    // Declare a state variable holding our companies in an array
    Company[] public companies;
}

```

**Rell:**

Rell

```codeBlockLines_e6Vv
module;

entity company {
    name: text;
    address: text;
}

```

The code looks pretty similar, right? However, in Rell, we don't need to declare any variable for companies. This is
because defining an entity in Rell automatically includes it in the state of your dapp upon deployment.

As a Solidity developer, declaring an array and storing data in the contract might seem daunting due to Gas Fees.
However, with Rell, this is not an issue. An instance of an entity in Rell is stored on-chain in a relational database
without incurring any gas fees. Chromia adopts a unique approach to resource management and fees, allowing developers to
lease containers with a fixed amount of resources (vCPU, RAM, storage, and I/O) similar to traditional cloud service
providers. This means there are no transaction fees (gas fees) for users, as the costs are covered by leasing these
resources, making it possible to design user experiences similar to traditional Web2 applications.

To dig deeper, a table named `company` will be created in your dapp's state along with the attributes `name` and
`address`. This is similar to how a database table is created using an ORM with a code-first approach. Read more about
entities [here](https://docs.chromia.com/rell/language-features/modules/entity).

## Interacting with a dapp or smart contract [​](\#interacting-with-a-dapp-or-smart-contract "Direct link to Interacting with a dapp or smart contract")

In Solidity, interaction with a smart contract is done by calling functions marked as public. This serves as the entry
point for executing logic within a contract. Let's add an example to our smart contract:

Solidity

```codeBlockLines_e6Vv
function addCompany(string memory _name, string memory _address) public {
        Company memory newCompany = Company(_name, _address);
        companies.push(newCompany);
}

```

In Rell, you interact with a dapp using operations, which are similar to public functions in Solidity. Operations are
executed by signing and sending a transaction with the operation name and supplied parameters. The Chromia platform then
executes the logic in the body of the operation, which can modify the state of your dapp. Here's how you can add a new
company to your dapp state in Rell:

Rell

```codeBlockLines_e6Vv
operation create_company(name: text, address: text) {
    create company( name, address );
}

```

Inside the operation, we use the keyword `create` to add a new entry to the company entity in the dapp state.
Conceptually, this is similar to creating a new instance of a Company and pushing it to the array of companies in
Solidity. Rell's approach to defining operations allows for straightforward and efficient manipulation of the state
without the complexities of managing gas fees, as Chromia does not have gas fees. This makes developing using Chromia
both cost-effective and user-friendly. For more information on Rell operations, you can read the full documentation
[here](https://docs.chromia.com/rell/language-features/modules/operation).

## Internal functions [​](\#internal-functions "Direct link to Internal functions")

In Solidity, when you want a function that is only accessible from within the smart contract, you use the `private`
keyword. Let's add a simple validation of the company name as a private function:

Solidity

```codeBlockLines_e6Vv
function isValidName(string memory _name) private returns (bool) {
        return bytes(_name).length > 0; // Simple check: name is not empty
}

```

Similarly, in Rell, we can use functions to encapsulate reusable logic, such as validation or data retrieval. Functions
in Rell can only be accessed from within your dapp; they can be called from operations, queries, and other functions. If
a function is called from an operation, it can also alter the state of your dapp, allowing for well-structured code with
reusable logic.

Rell

```codeBlockLines_e6Vv
function is_valid_name(name: text) {
    not name.empty();
}

```

Let's put together what we have so far in our examples for both Solidity and Rell:

- Rell
- Solidity

Rell

```codeBlockLines_e6Vv
module;

entity company {
    name: text;
    address: text;
}

operation create_company(name: text, address: text) {
    require(is_valid_name(name), "Invalid name");
    create company( name, address );
}

function is_valid_name(name: text) {
    not name.empty();
}

```

Solidity

```codeBlockLines_e6Vv
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CompanyManager {
    struct Company {
        string name;
        string address;
    }

    Company[] private companies;

    function addCompany(string memory _name, string memory _address) public {
        require(isValidName(_name), "Invalid company name");
        Company memory newCompany = Company(_name, _address);
        companies.push(newCompany);
    }

    function isValidName(string memory _name) private pure returns (bool) {
        return bytes(_name).length > 0; // Simple check: name is not empty
    }
}

```

As you can see, we call the validation function to check that the name is valid in both Solidity and Rell. Both
languages use the `require` function to check the validation result. If the validation fails, an error will be thrown,
and the transaction and state changes will be rolled back. For more detailed information about functions, you can read
[here](https://docs.chromia.com/rell/language-features/modules/function).

## Querying data [​](\#querying-data "Direct link to Querying data")

In Solidity, retrieving data from a smart contract's state typically involves using public getter functions. Solidity
automatically creates getter functions for public state variables, but you can also write custom public functions to
return more complex data or computed results. These functions can be marked as viewed if they do not modify the
contract's state, ensuring that they do not consume any gas when called externally. Here's an example where we return a
company struct by supplying the index of the company:

Soldity

```codeBlockLines_e6Vv
function getCompany(uint _index) public view returns (Company memory) {
    return companies[_index]; // Returns the Company struct at the given index
}

```

In Rell, we use queries to fetch data, similar to Solidity's public view functions. Queries in Rell cannot modify the
database state but are used to retrieve data. Combined with Rell's built-in query language, this becomes very powerful.

Rell

```codeBlockLines_e6Vv
query get_company(id: rowid) {
    return company @ { .rowid == id };
}

```

In this example, we use the query language in Rell to fetch the company using `row_id` as its identifier. This method is
efficient and simple, allowing for powerful data retrieval operations. For more detailed information on queries, you can
read [here](https://docs.chromia.com/rell/language-features/modules/query).

## Summary [​](\#summary "Direct link to Summary")

This concludes our introduction to transitioning from Solidity to Chromia and Rell. We have covered several basic
concepts to get you started. In the next sections, we will showcase various examples illustrating different concepts to
help Solidity developers get up and running on Chromia.

- [Smart contract and dapp states](#smart-contract-and-dapp-states)
- [Interacting with a dapp or smart contract](#interacting-with-a-dapp-or-smart-contract)
- [Internal functions](#internal-functions)
- [Querying data](#querying-data)
- [Summary](#summary)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In this final lesson, we'll look into comprehensive testing of our asset management system. We'll look at different test scenarios and how to verify system behavior.

## Test Setup [​](\#test-setup "Direct link to Test Setup")

Our test module imports all necessary components:

src/test/module.rell

```codeBlockLines_e6Vv
@test module;

import lib.ft4.core.accounts.strategies.open.{ ras_open };
import lib.ft4.external.accounts. { get_accounts_by_signer };
import lib.ft4.external.accounts.strategies.{ register_account };
import lib.ft4.external.assets. { get_asset_balance, get_assets_by_name, transfer };
import lib.ft4.test.utils. { ft_auth_operation_for };
import lib.ft4.utils. { paged_result };
import lib.ft4.test.utils. { create_auth_descriptor };
import ^.main. { register_and_mint_asset };

```

## Structuring [​](\#structuring "Direct link to Structuring")

To retrieve account information, we've defined helper functions in our utils:

src/test/utils.rell

```codeBlockLines_e6Vv
struct account_dto {
    id: byte_array;
    type: text;
}

struct asset_dto {
    id: byte_array;
    name: text;
    symbol: text;
    decimals: integer;
    blockchain_rid: byte_array;
    icon_url: text;
    type: text;
    supply: big_integer;
}

function account_from_gtv(paged_result) = account_dto.from_gtv_pretty(paged_result.data[0]);

function asset_from_gtv(paged_result) = asset_dto.from_gtv_pretty(paged_result.data[0]);

```

These utilities help us work with account data in a structured way throughout our testing process.

## Test Cases [​](\#test-cases "Direct link to Test Cases")

### 1\. Asset Registration Test [​](\#1-asset-registration-test "Direct link to 1. Asset Registration Test")

This test verifies the functionality of creating an account and registering a new asset. It ensures that an asset can be successfully created and that the system accurately reflects this in the asset registry.

src/test/asset\_management\_test.rell

```codeBlockLines_e6Vv
function test_create_account_and_register_and_mint_asset() {
    val alice = rell.test.keypairs.alice;
    val trudy = rell.test.keypairs.trudy;

    val required_asset = (
        name = "TestAsset1",
        id = x"A85755C27F76B25C4139C929861E81C001C8C449F0260A9132F8ECFEA9075C39", //(asset_name, chain_context.blockchain_rid).hash();
        symbol = "TST1",
        decimals = 10,
        blockchain_rid = x"0000000000000000000000000000000000000000000000000000000000000000",
        icon_url = "https://url-to-asset-1-icon",
        type = "ft4",
        supply = 100L,
    );
    val auth_descriptor_alice = create_auth_descriptor(alice.pub, ["A", "T"], null.to_gtv());
    val auth_descriptor_trudy = create_auth_descriptor(trudy.pub, ["A", "T"], null.to_gtv());
    rell.test.tx()
        .op(ras_open(auth_descriptor_alice))
        .op(register_account())

        .sign(alice)
        .run();
    rell.test.tx()
        .op(ras_open(auth_descriptor_trudy))
        .op(register_account()).sign(trudy)
        .run();

    rell.test.tx()
        .op(ft_auth_operation_for(alice.pub))
        .op(
            register_and_mint_asset(
                required_asset.name,
                required_asset.symbol,
                required_asset.decimals,
                required_asset.supply,
                required_asset.icon_url
            )
        )
        .sign(alice)
        .run();

    //query
    val asset_gtv = get_assets_by_name(required_asset.name, 10, null);
    assert_equals(asset_gtv.data[0], required_asset.to_gtv_pretty());

    val asset_data = asset_from_gtv(asset_gtv);

    val account_alice = account_from_gtv(get_accounts_by_signer(alice.pub, 10, null));
    val account_trudy = account_from_gtv(get_accounts_by_signer(trudy.pub, 10, null));

    val balance_alice = get_asset_balance(account_alice.id, asset_data.id);
    assert_equals(balance_alice?.amount, required_asset.supply);
}

```

### 2\. Multiple Asset Registration Test [​](\#2-multiple-asset-registration-test "Direct link to 2. Multiple Asset Registration Test")

This test ensures that an account cannot register more than one asset, validating the one-asset-per-account restriction. The first asset registration should succeed, while the second attempt to register a different asset should fail.

src/test/asset\_management\_test.rell

```codeBlockLines_e6Vv
function test_create_account_and_register_and_mint_2_assets_must_fail() {
    val alice = rell.test.keypairs.alice;
    val trudy = rell.test.keypairs.trudy;
    val required_asset_1 = (
        name = "TestAsset1",
        symbol = "TST1",
        decimals = 10,
        icon_url = "https://url-to-asset-1-icon",
        type = "ft4",
        supply = 100L,
    );
    val required_asset_2 = (
        name = "TestAsset2",
        symbol = "TST2",
        decimals = 10,
        icon_url = "https://url-to-asset-1-icon",
        type = "ft4",
        supply = 100L,
    );
    val auth_descriptor_alice = create_auth_descriptor(alice.pub, ["A", "T"], null.to_gtv());
    val auth_descriptor_trudy = create_auth_descriptor(trudy.pub, ["A", "T"], null.to_gtv());
    rell.test.tx()
        .op(ras_open(auth_descriptor_alice))
        .op(register_account()).sign(alice)
        .run();
    rell.test.tx()
        .op(ras_open(auth_descriptor_trudy))
        .op(register_account()).sign(trudy)
        .run();
    rell.test.tx()
        .op(ft_auth_operation_for(alice.pub))
        .op(
            register_and_mint_asset(
                required_asset_1.name,
                required_asset_1.symbol,
                required_asset_1.decimals,
                required_asset_1.supply,
                required_asset_1.icon_url
            )
        ).sign(alice)
        .run();

    rell.test.tx()
        .op(ft_auth_operation_for(alice.pub))
        .op(
            register_and_mint_asset(
                required_asset_2.name,
                required_asset_2.symbol,
                required_asset_2.decimals,
                required_asset_2.supply,
                required_asset_2.icon_url
            )
        ).sign(alice)
        .run_must_fail();
}

```

### Transfer Test [​](\#transfer-test "Direct link to Transfer Test")

The FT4 library provides a transfer operation that we can use directly. Here's how we test asset transfers:

src/test/asset\_management\_test.rell

```codeBlockLines_e6Vv
function test_create_account_and_register_and_mint_and_transfer_asset() {
    val alice = rell.test.keypairs.alice;
    val trudy = rell.test.keypairs.trudy;
    val asset_name = "TestAsset1";
    val asset_amount = 100;
    val asset_amount_to_transfer = 20;

    val required_asset = (
        name = "TestAsset1",
        symbol = "TST1",
        decimals = 10,
        icon_url = "https://url-to-asset-1-icon",
        type = "ft4",
        supply = 100L,
    );

    val auth_descriptor = create_auth_descriptor(alice.pub, ["A", "T"], null.to_gtv());
    val auth_descriptor_trudy = create_auth_descriptor(trudy.pub, ["A", "T"], null.to_gtv());
    rell.test.tx()
        .op(ras_open(auth_descriptor))
        .op(register_account()).sign(alice)
        .run();
    rell.test.tx()
        .op(ras_open(auth_descriptor_trudy))
        .op(register_account()).sign(trudy)
        .run();

    rell.test.tx()
        .op(ft_auth_operation_for(alice.pub))
        .op(
            register_and_mint_asset(
                required_asset.name,
                required_asset.symbol,
                required_asset.decimals,
                required_asset.supply,
                required_asset.icon_url
            )
        ).sign(alice)
        .run();

    //query
    val asset_data = asset_from_gtv(get_assets_by_name(required_asset.name, 10, null));

    val account_alice = account_from_gtv(get_accounts_by_signer(alice.pub, 10, null));
    val account_trudy = account_from_gtv(get_accounts_by_signer(trudy.pub, 10, null));

    rell.test.tx()
        .op(ft_auth_operation_for(alice.pub))
        .op(transfer(account_trudy.id, asset_data.id, asset_amount_to_transfer)).sign(alice)
        .run();

    val alice_balance = get_asset_balance(account_alice.id, asset_data.id);
    assert_equals(alice_balance?.amount, asset_amount - asset_amount_to_transfer);

    val trudy_balance = get_asset_balance(account_trudy.id, asset_data.id);
    assert_equals(trudy_balance?.amount, asset_amount_to_transfer);
}

```

The transfer process involves several key steps:

1. **Account Setup**: Both sender and receiver must have valid accounts
2. **Asset Registration**: The asset must be registered and minted
3. **Transfer Execution**: Using FT4's transfer operation
4. **Balance Verification**: Checking that balances are updated correctly

## Running Tests [​](\#running-tests "Direct link to Running Tests")

To run all tests, use the Chromia CLI:

```codeBlockLines_e6Vv
chr test

```

- [Test Setup](#test-setup)
- [Structuring](#structuring)
- [Test Cases](#test-cases)
  - [1\. Asset Registration Test](#1-asset-registration-test)
  - [2\. Multiple Asset Registration Test](#2-multiple-asset-registration-test)
  - [Transfer Test](#transfer-test)
- [Running Tests](#running-tests)[Skip to main content](#__docusaurus_skipToContent_fallback)

## SQL Courses

#### Courses that cover SQL concepts and implementations.

[Intermediate **Rell masterclass** \\
Optimize SQL statements and learn advanced database interactions in Rell.](/courses/rell-masterclass/introduction)

[Rell](/tags/Rell) [SQL](/tags/SQL)

Start Course [Intermediate **Understand relationships in Rell** \\
Master complex data relationships with Rell.](/courses/relationships-course/introduction)

[Rell](/tags/Rell) [SQL](/tags/SQL)

Start Course[Skip to main content](#__docusaurus_skipToContent_fallback)

Let's add the remaining parts of our client to test different functions.

We start by defining the rest of our Book Review and Transaction (Tx) model:

```codeBlockLines_e6Vv
type BookReview = {
  book: Book;
  reviewer_name: string;
};

type TxOp = {
  op_name: string;
  op_args: any[];
};

type TxBody = {
  tx_rid: Buffer;
  ops: TxOp[];
  signers: Buffer[];
};

type Tx = {
  tx_body: TxBody;
  signatures: Buffer[];
};

```

* * *

We define functions to query for entities and some helper functions to read input from user:

```codeBlockLines_e6Vv
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

function getInput(query: string): Promise<string> {
  return new Promise((resolve) => {
    rl.question(query, (answer) => {
      resolve(answer);
    });
  });
}

const getReviewsForBook = async (isbn: string) => {
  const bookList = await client.query<BookReview[]>("get_all_reviews_for_book", { isbn: isbn });
  console.log("Book review list\n", bookList);
};

const getAllTransactions = async () => {
  await client.query<Tx[]>("get_transactions", {}).then((transactions) => {
    transactions.forEach((tx) => {
      console.log("TxRID:", tx.tx_body.tx_rid.toString("hex"));
      tx.tx_body.ops.forEach((op) => {
        console.log("OpName:", op.op_name);
        console.log("OpArgs:", op.op_args);
      });
    });
  });

  const transactions = (await client.query("get_transactions", {})) as Tx[];
  transactions.forEach((tx) => {
    console.log("TxRID:", tx.tx_body.tx_rid.toString("hex"));
    tx.tx_body.ops.forEach((op) => {
      console.log("OpName:", op.op_name);
      console.log("OpArgs:", op.op_args);
    });
  });
};

```

* * *

and finally our complete main function where we in this code example have added some more functions to show queries and
transactions

```codeBlockLines_e6Vv
async function main() {
  client = await createClient({
    nodeUrlPool: "http://localhost:7740",
    blockchainRid: blockchainRID,
  });

  console.log("Creating a new book transactions");
  await client.signAndSendUniqueTransaction(
    { name: "create_book", args: ["ISBN1", "Chromia 101", "John Doe"] },
    bookKeeperSignatureProvider
  );
  await getInput("Transaction comitted!\npress any key to continue...");

  console.log("Let's fetch and view all books currently in the node");
  await getAllBooks();
  await getInput("Press any key to continue...");

  console.log("We can now add a second book");
  await client.signAndSendUniqueTransaction(
    { name: "create_book", args: ["ISBN2", "Rell 101", "Jane Doe"] },
    bookKeeperSignatureProvider
  );
  await getInput("Transaction comitted, press any key to continue...");

  console.log("Let's fetch and view all books currently in the node");
  await getAllBooks();
  await getInput("Press any key to continue...");

  console.log("We can now add two reviews for the book with ISBN = ISBN2");

  await client.signAndSendUniqueTransaction(
    {
      name: "create_book_review",
      args: ["ISBN2", "Bob Doe", "This is a great book!", 5],
    },
    bookKeeperSignatureProvider
  );
  await client.signAndSendUniqueTransaction(
    {
      name: "create_book_review",
      args: ["ISBN2", "Charlie Doe", "It was ok!", 3],
    },
    bookKeeperSignatureProvider
  );
  await getInput("Transaction comitted, press any key to continue...");

  console.log("Let's fetch and view all books currently in the node");
  await getReviewsForBook("ISBN2");
  await getInput("Press any key to continue...");

  console.log("Now lets look at all transaction that have been commited to the blockchain");
  await getAllTransactions();
  await getInput("Press any key to continue...");
}

```

Now we have a fully functional example to showcase how simple it is to implement a front-end client using Chromia and
Postchain-client[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Transferring assets and tokens is crucial in dapp development. This example demonstrates building a simple English Auction in both Solidity and Rell, Chromia's language.

## Solidity [​](\#solidity "Direct link to Solidity")

Our initial example is presented in Solidity, featuring a streamlined version of an auction. It's important to note that this example primarily focuses on the core logic of the auction process. In a comprehensive, fully-functional auction smart contract, additional functions and checks are typically required. However, the purpose of this guide is to emphasize the essential operations and demonstrate how they can be effectively translated into Chromia's Rell language.

We start by defining a struct to hold our auctions within the contract. Additionally, our model uses event emission to persist the history of bids and claims. Using events instead of storing the entire history within the contract helps minimize gas fees. This approach is particularly beneficial for managing the costs associated with executing smart contracts on the blockchain. As we will discover later, this is not the case for Chromia.

Solidity

```codeBlockLines_e6Vv
struct Auction {
    uint256 index; // Auction Index
    address addressNFTCollection; // Address of the ERC721 NFT Collection contract
    address addressPaymentToken; // Address of the ERC20 Payment Token contract
    uint256 nftId; // NFT Id
    address creator; // Creator of the Auction
    address payable currentBidOwner; // Address of the highest bidder
    uint256 currentBidPrice; // Current highest bid for the auction
    uint256 endAuction; // Timestamp for the end day & time of the auction
    uint256 bidCount; // Number of bids placed on the auction
}

Auction[] private allAuctions;

```

Below is the full implementation of the Auction in Solidity. We will delve into the details of each part in the upcoming sections.

Full example in Solidity

Solidity

```codeBlockLines_e6Vv
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "./ERC20.sol";
import "./NFTCollection.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

contract Marketplace is IERC721Receiver {
    string public name;
    uint256 public index = 0;

    struct Auction {
        uint256 index; // Auction Index
        address addressNFTCollection; // Address of the ERC721 NFT Collection contract
        address addressPaymentToken; // Address of the ERC20 Payment Token contract
        uint256 nftId; // NFT Id
        address creator; // Creator of the Auction
        address payable currentBidOwner; // Address of the highest bidder
        uint256 currentBidPrice; // Current highest bid for the auction
        uint256 endAuction; // Timestamp for the end date & time of the auction
        uint256 bidCount; // Number of bids placed on the auction
    }

    Auction[] private allAuctions;

    event NewBidOnAuction(uint256 auctionIndex, uint256 newBid);
    event NFTClaimed(uint256 auctionIndex, uint256 nftId, address claimedBy);
    event TokensClaimed(uint256 auctionIndex, uint256 nftId, address claimedBy);
    event NFTRefunded(uint256 auctionIndex, uint256 nftId, address claimedBy);

    constructor(string memory _name) {
        name = _name;
    }

    function isContract(address _addr) private view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(_addr)
        }
        return size > 0;
    }

    function createAuction(
        address _addressNFTCollection,
        address _addressPaymentToken,
        uint256 _nftId,
        uint256 _initialBid,
        uint256 _endAuction
    ) external returns (uint256) {

        require(isContract(_addressNFTCollection), "Invalid NFT Collection contract address");
        require(isContract(_addressPaymentToken), "Invalid Payment Token contract address");
        require(_endAuction > block.timestamp, "Invalid end date for auction");
        require(_initialBid > 0, "Invalid initial bid price");

        NFTCollection nftCollection = NFTCollection(_addressNFTCollection);
        require(nftCollection.ownerOf(_nftId) == msg.sender, "Caller is not the owner of the NFT");
        require(nftCollection.getApproved(_nftId) == address(this), "Require NFT ownership transfer approval");
        require(nftCollection.transferNFTFrom(msg.sender, address(this), _nftId), "NFT transfer failed");

        address payable currentBidOwner = payable(address(0));

        Auction memory newAuction = Auction({
            index: index,
            addressNFTCollection: _addressNFTCollection,
            addressPaymentToken: _addressPaymentToken,
            nftId: _nftId,
            creator: msg.sender,
            currentBidOwner: currentBidOwner,
            currentBidPrice: _initialBid,
            endAuction: _endAuction,
            bidCount: 0
        });

        allAuctions.push(newAuction);
        index++;

        return index;
    }

    function isOpen(uint256 _auctionIndex) public view returns (bool) {
        Auction storage auction = allAuctions[_auctionIndex];
        return block.timestamp < auction.endAuction;
    }

    function bid(uint256 _auctionIndex, uint256 _newBid) external returns (bool) {
        require(_auctionIndex < allAuctions.length, "Invalid auction index");
        Auction storage auction = allAuctions[_auctionIndex];

        require(isOpen(_auctionIndex), "Auction is not open");
        require(_newBid > auction.currentBidPrice, "New bid price must be higher than the current bid");
        require(msg.sender != auction.creator, "Creator of the auction cannot place new bid");

        ERC20 paymentToken = ERC20(auction.addressPaymentToken);

        require(paymentToken.transferFrom(msg.sender, address(this), _newBid), "Transfer of token failed");

        if (auction.bidCount > 0) {
            paymentToken.transfer(auction.currentBidOwner, auction.currentBidPrice);
        }

        auction.currentBidOwner = payable(msg.sender);
        auction.currentBidPrice = _newBid;
        auction.bidCount++;

        emit NewBidOnAuction(_auctionIndex, _newBid);

        return true;
    }

    function endAuction(uint256 _auctionIndex) external {
        require(_auctionIndex < allAuctions.length, "Invalid auction index");
        require(!isOpen(_auctionIndex), "Auction is still open");

        Auction storage auction = allAuctions[_auctionIndex];

        require(
            msg.sender == auction.creator || msg.sender == auction.currentBidOwner,
            "Only creator or winner can end the auction"
        );

        NFTCollection nftCollection = NFTCollection(auction.addressNFTCollection);

        require(
            nftCollection.transferNFTFrom(address(this), auction.currentBidOwner, auction.nftId),
            "NFT transfer failed"
        );

        ERC20 paymentToken = ERC20(auction.addressPaymentToken);

        require(
            paymentToken.transfer(auction.creator, auction.currentBidPrice),
            "Token transfer failed"
        );

        emit NFTClaimed(_auctionIndex, auction.nftId, auction.currentBidOwner);
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC721Received.selector;
    }
}

```

## Rell [​](\#rell "Direct link to Rell")

Implementing the same example in Rell involves a more model-driven approach. We create a data model consisting of the entities needed, setting up a model that simplifies working with the auction logic and future extensions or feature additions.

Our model consists of:

- `auction` representing our auction with all properties needed to manage the entire auction life cycle.
- `bid` representing a bid from a participant in the auction.
- `artwork_nft` our NFT model.

Rell

```codeBlockLines_e6Vv
entity auction {
    key id: byte_array = op_context.transaction.tx_rid;
    key nft: artwork_nft;
    seller: account;
    mutable started: boolean;
    mutable end_at: timestamp;
    mutable ended: boolean;
    mutable highest_bid: integer = 0;
    mutable highest_bid_owner: account;
    payment_token: asset;
}

entity bid {
    auction: auction;
    bid: integer;
    bidder: account;
    index auction, bid;
}

entity artwork_nft {
    key id: byte_array = op_context.transaction.tx_rid;
    artwork_url: text;
    mutable owner: account;
    index owner;
}

```

In this example, we have already set up an NFT in our model. Like in the Solidity example, we assume the NFT has been minted, and there are minted tokens used as payment tokens for the auction. Setting up a token to use as currency is simple using Chromia FT4, and you can read more about this process [here](https://docs.chromia.com/ft4/ft4-register-assets). Registering a new NFT can be done using a mint operation, as shown below:

Rell

```codeBlockLines_e6Vv
operation mint(artwork_url: text) {
    val account = auth.authenticate();
    create artwork_nft( .artwork_url = artwork_url, .owner = account );
}

```

Now we move on to the logic of the dapp. Below, we present the full solution and then examine the central parts step by step.

Full example in Chromia Rell

Rell

```codeBlockLines_e6Vv
operation create_auction(nft_id: byte_array, starting_bid: integer, payment_token_id: byte_array, end_at: integer) {
    val account = auth.authenticate();

    val nft = require(artwork_nft @? { .id == nft_id }, "NFT missing");
    val payment_token = require(asset @? { .id == payment_token_id }, "Payment token asset missing");

    require(nft.owner == account, "You are not the owner of this NFT");
    require(starting_bid > 0, "Invalid initial bid price");
    require(end_at > op_context.transaction.tx_time, "Invalid end date for auction");

    // Transfer NFT to auction account
    nft.owner = account @ { .id == auction_meta.auction_account };

    create auction (
        .nft = nft,
        .seller = account,
        .started = true,
        .ended = false,
        .end_at = end_at,
        .highest_bid = starting_bid,
        .highest_bid_owner = account,
        .payment_token = payment_token
    );
}

operation bid(auction_id: byte_array, bid: integer) {
    val account = auth.authenticate();
    val auction = require(auction @? { .id == auction_id }, "Auction not found");
    val auction_account = account @ { .id == auction_meta.auction_account };

    require(auction.started, "Auction has not started yet");
    require(not auction.ended, "Auction has already ended");
    require(bid > auction.highest_bid, "Bid must be higher than the current highest bid");
    require(account != auction.seller, "The auction creator cannot place a bid");

    transfer(account, auction_account, auction.payment_token, bid);
    transfer(auction_account, auction.highest_bid_owner, auction.payment_token, auction.highest_bid);

    auction.highest_bid = bid;
    auction.highest_bid_owner = account;

    create bid ( .auction = auction, .bid = bid, .bidder = account );
}

operation __begin_block(height: integer) {
    val auctions = auction @* { .started and not .ended and .end_at <= op_context.last_block_time };
    for (auction in auctions) {
        end_auction(auction.id);
    }
}

function end_auction(auction_id: byte_array) {
    val auction = require(auction @? { .id == auction_id }, "Auction not found");
    val auction_account = account @ { .id == auction_meta.auction_account };

    require(auction.started, "Auction has not started yet");
    require(not auction.ended, "Auction has already ended");
    require(op_context.last_block_time >= auction.end_at, "Auction has not ended yet");

    auction.ended = true;
    auction.nft.owner = auction.highest_bid_owner;
    transfer(auction_account, auction.seller, auction.payment_token, auction.highest_bid);
}

```

## Create auction [​](\#create-auction "Direct link to Create auction")

To create and initialize a new auction, we must store key information such as the NFT up for auction, the highest bidder, and the highest bid.

- Rell
- Solidity

Rell

```codeBlockLines_e6Vv
operation create_auction(nft_id: byte_array, starting_bid: integer, payment_token_id: byte_array, end_at: integer) {
    val account = auth.authenticate();

    val nft = require(artwork_nft @? { .id == nft_id }, "NFT missing");
    val payment_token = require(asset @? { .id == payment_token_id }, "Payment token asset missing");

    require(nft.owner == account, "You are not the owner of this NFT");
    require(starting_bid > 0, "Invalid initial bid price");
    require(end_at > op_context.transaction.tx_time, "Invalid end date for auction");

    // Transfer NFT to auction account
    nft.owner = account @ { .id == auction_meta.auction_account };

    create auction (
        .nft = nft,
        .seller = account,
        .started = true,
        .ended = false,
        .end_at = end_at,
        .highest_bid = starting_bid,
        .highest_bid_owner = account,
        .payment_token = payment_token
    );
}

```

Solidity

```codeBlockLines_e6Vv
function createAuction(
    address _addressNFTCollection,
    address _addressPaymentToken,
    uint256 _nftId,
    uint256 _initialBid,
    uint256 _endAuction
) external returns (uint256) {

    require(isContract(_addressNFTCollection), "Invalid NFT Collection contract address");
    require(isContract(_addressPaymentToken), "Invalid Payment Token contract address");
    require(_endAuction > block.timestamp, "Invalid end date for auction");
    require(_initialBid > 0, "Invalid initial bid price");

    NFTCollection nftCollection = NFTCollection(_addressNFTCollection);
    require(nftCollection.ownerOf(_nftId) == msg.sender, "Caller is not the owner of the NFT");
    require(nftCollection.getApproved(_nftId) == address(this), "Require NFT ownership transfer approval");
    require(nftCollection.transferNFTFrom(msg.sender, address(this), _nftId), "NFT transfer failed");

    address payable currentBidOwner = payable(address(0));

    Auction memory newAuction = Auction({
        index: index,
        addressNFTCollection: _addressNFTCollection,
        addressPaymentToken: _addressPaymentToken,
        nftId: _nftId,
        creator: msg.sender,
        currentBidOwner: currentBidOwner,
        currentBidPrice: _initialBid,
        endAuction: _endAuction,
        bidCount: 0
    });

    allAuctions.push(newAuction);
    index++;

    return index;
}

```

In the Rell code, we start by authenticating the user who is creating the auction and retrieving their account information:

Rell

```codeBlockLines_e6Vv
val account = auth.authenticate();

```

Next, we fetch the NFT that will be auctioned:

Rell

```codeBlockLines_e6Vv
val nft = require(artwork_nft @? { .id == nft_id }, "NFT missing");

```

We verify that the user creating the auction is the actual owner of the NFT:

Rell

```codeBlockLines_e6Vv
require(nft.owner == account, "You are not the owner of this NFT");

```

To handle bids and final payments, we require a payment token for the auction:

Rell

```codeBlockLines_e6Vv
val payment_token = require(asset @? { .id == payment_token_id }, "Payment token asset missing");

```

We add relevant checks:

Rell

```codeBlockLines_e6Vv
require(starting_bid > 0, "Invalid initial bid price");
require(end_at > op_context.transaction.tx_time, "Invalid end date for auction");

```

`auction_meta.auction_account` represents a special account used to handle the assets (NFTs and payment tokens) involved in the auction process. This account is set up during the initialization of the app using Chromia FT4. Detailed information can be found [here](https://docs.chromia.com/ft4/ft4-register-accounts):

Rell

```codeBlockLines_e6Vv
nft.owner = account @ { .id == auction_meta.auction_account };

```

Finally, we create the auction entity and supply all necessary data:

Rell

```codeBlockLines_e6Vv
create auction (
    .nft = nft,
    .seller = account,
    .started = true,
    .ended = false,
    .end_at = end_at,
    .highest_bid = starting_bid,
    .highest_bid_owner = account,
    .payment_token = payment_token
);

```

To read more about account creation you can follow this [link](https://docs.chromia.com/ft4/ft4-register-accounts).

## Add bids [​](\#add-bids "Direct link to Add bids")

Once the auction is created and started, participants can begin placing their bids. The Rell example is structured and typed, making it straightforward to follow and understand the logic.

- Rell
- Solidity

Rell

```codeBlockLines_e6Vv
operation bid(auction_id: byte_array, bid: integer) {
    val account = auth.authenticate();
    val auction = require(auction @? { .id == auction_id }, "Auction not found");
    val auction_account = account @ { .id == auction_meta.auction_account };

    require(auction.started, "Auction has not started yet");
    require(not auction.ended, "Auction has already ended");
    require(bid > auction.highest_bid, "Bid must be higher than the current highest bid");
    require(account != auction.seller, "The auction creator cannot place a bid");

    transfer(account, auction_account, auction.payment_token, bid);
    transfer(auction_account, auction.highest_bid_owner, auction.payment_token, auction.highest_bid);

    auction.highest_bid = bid;
    auction.highest_bid_owner = account;

    create bid ( .auction = auction, .bid = bid, .bidder = account );
}

```

Solidity

```codeBlockLines_e6Vv
function bid(uint256 _auctionIndex, uint256 _newBid) external returns (bool) {
    require(_auctionIndex < allAuctions.length, "Invalid auction index");
    Auction storage auction = allAuctions[_auctionIndex];

    require(isOpen(_auctionIndex), "Auction is not open");
    require(_newBid > auction.currentBidPrice, "New bid price must be higher than the current bid");
    require(msg.sender != auction.creator, "Creator of the auction cannot place new bid");

    ERC20 paymentToken = ERC20(auction.addressPaymentToken);

    require(paymentToken.transferFrom(msg.sender, address(this), _newBid), "Transfer of token failed");

    if (auction.bidCount > 0) {
        paymentToken.transfer(auction.currentBidOwner, auction.currentBidPrice);
    }

    auction.currentBidOwner = payable(msg.sender);
    auction.currentBidPrice = _newBid;
    auction.bidCount++;

    emit NewBidOnAuction(_auctionIndex, _newBid);

    return true;
}

```

In the Rell code, we fetch the necessary entities to place a bid:

- `account`: The bidder's account
- `auction`: The auction where the bid is being placed
- `auction_account`: Used to transfer payment tokens and NFTs to and from the auction

Next, we perform relevant checks:

Rell

```codeBlockLines_e6Vv
require(auction.started, "Auction has not started yet");
require(not auction.ended, "Auction has already ended");
require(bid > auction.highest_bid, "Bid must be higher than the current highest bid");
require(account != auction.seller, "The auction creator cannot place a bid");

```

Once all checks pass, we can create the bid and transfer the payment tokens.

First, we transfer the new bid to the `auction_account` to lock the bid to the auction:

Rell

```codeBlockLines_e6Vv
transfer(account, auction_account, auction.payment_token, bid);

```

Then, we transfer the previous highest bid back to the highest bidder:

Rell

```codeBlockLines_e6Vv
transfer(auction_account, auction.highest_bid_owner, auction.payment_token, auction.highest_bid);

```

Finally, we update the auction with the current highest bidder and their bid, and create the bid in the dapp state:

Rell

```codeBlockLines_e6Vv
auction.highest_bid = bid;
auction.highest_bid_owner = account;

create bid ( .auction = auction, .bid = bid, .bidder = account );

```

## End auction [​](\#end-auction "Direct link to End auction")

The final step of the auction process occurs when the auction reaches its end time, and the account holding the highest bid wins the auction. Ending the auction in Solidity requires a manual trigger, which means sending a transaction to the `endAuction` function. This action incurs a fee.

Solidity

```codeBlockLines_e6Vv
function endAuction(uint256 _auctionIndex) external {
    require(_auctionIndex < allAuctions.length, "Invalid auction index");
    require(!isOpen(_auctionIndex), "Auction is still open");

    Auction storage auction = allAuctions[_auctionIndex];

    require(
        msg.sender == auction.creator || msg.sender == auction.currentBidOwner,
        "Only creator or winner can end the auction"
    );

    NFTCollection nftCollection = NFTCollection(auction.addressNFTCollection);

    require(
        nftCollection.transferNFTFrom(address(this), auction.currentBidOwner, auction.nftId),
        "NFT transfer failed"
    );

    ERC20 paymentToken = ERC20(auction.addressPaymentToken);

    require(
        paymentToken.transfer(auction.creator, auction.currentBidPrice),
        "Token transfer failed"
    );

    emit NFTClaimed(_auctionIndex, auction.nftId, auction.currentBidOwner);
}

```

In Rell, we can automate the process using the `__begin_block()` function, which is called every time a new block is created. This automates the process of ending the auction as soon as the auction time has expired, automatically paying the seller the highest bid and transferring the NFT to the highest bidder.

Rell

```codeBlockLines_e6Vv
operation __begin_block(height: integer) {
  val auctions = auction @* { .started and not .ended and .end_at <= op_context.last_block_time };
  for (auction in auctions) {
    end(auction.id);
  }
}

function end_auction(auction_id: byte_array) {
    val auction = require(auction @? { .id == auction_id }, "Auction not found");
    val auction_account = account @ { .id == auction_meta.auction_account };

    require(auction.started, "Auction has not started yet");
    require(not auction.ended, "Auction has already ended");
    require(op_context.last_block_time >= auction.end_at, "Auction has not ended yet");

    auction.ended = true;
    auction.nft.owner = auction.highest_bid_owner;
    transfer(auction_account, auction.seller, auction.payment_token, auction.highest_bid);
}

```

This concludes our example of an English Auction on both Solidity and Rell.
Both code bases are very similar making it easy to start using Rell if you have previously used Solidity.
A couple of key takeaways and advantages when you make this transition are:

1. **On-chain Storage:** Using Chromia and Rell, there is no need to rely on emitting events to keep the bidding history, as all data is stored on-chain.
2. **Automation:** `__begin_block()` helps us automate the auction and eliminates the need to actively user triggering functions.
3. **Modern Syntax:** Writing code in Rell is simpler due to its modern, structured, and lightweight syntax, making it easier to transition from Solidity.

- [Solidity](#solidity)
- [Rell](#rell)
- [Create auction](#create-auction)
- [Add bids](#add-bids)
- [End auction](#end-auction)[Skip to main content](#__docusaurus_skipToContent_fallback)

In this guide, we will build a simple function for creating a map that collects a structure based on a specific key. This is a standard pattern when working with many-to-one relations.

Say that you have, for example, the entity relations:

```codeBlockLines_e6Vv
entity house {
    key id: integer;
    color: text;
}

entity street {
    key address: text;
}

entity street_house {
    key house;
    index street;
}

```

For this relation, each house is unique and lives on a street, but each street can contain several houses. If we want to create a query that returns all houses grouped by their street, we'd like to get the following signature:

```codeBlockLines_e6Vv
query get_houses_by_street(): map<text, list<struct<house>>>

```

Each entry in the map has the address as a key and a list of house-structs as values. Performing a database query using the at-operator, we can at most get a `list<text, struct<house>>`:

```codeBlockLines_e6Vv
val house_list: list<(text, struct<house>)> = street_house @* {} ( .street.address, .house.to_struct() );

```

How do we create a map for this structure? Luckily, rell has a few annotations to aggregate the results into collections. `@group` is used to specify what we want to group with, and `@list` or `@set` can specify the target collection type.

We can now collect the results in a slightly better structure:

```codeBlockLines_e6Vv
val house_streets: list<(text, list<struct<house>>)> =
  street_house @* {} ( @group .street.address, @list .house.to_struct() );

```

The `@group` annotation tells the ORM that we want to group the results using the street address as the key, and the `@list` annotation collects all houses on the same street.

But we can directly convert the resulting type into a map using another annotation provided by Rell ORM, called @map:

```codeBlockLines_e6Vv
val houses_by_street = house_streets @ {} ( @map $ );

```

This is another at-expression that works on a collection. In the what-clause, we use `@map` to treat each entry as a map entry.

Using this approach, we can optimize the database query for obtaining the results and convert them into a map structure using fewer lines of code and in an optimized way.[Skip to main content](#__docusaurus_skipToContent_fallback)

This course will guide you to setup blockchain environment and create a rell dapp template.

In this course, you will learn how to:

- Setup environment.
- Create a project based on the asset-managent template.

## Lessons

[Set up the Fullstack application](/courses/ft4-demo-app/module-init/setup-application)

[Start module »](/courses/ft4-demo-app/module-init/setup-application)[Skip to main content](#__docusaurus_skipToContent_fallback)

- **postchain-client:**
Used to interact with the Chromia blockchain.

- **@chromia/ft4:**
Chromia's FT4 token standard library. Provides the tools to interact with the FT4 token standard.

- **@chromia/react:**
The Chromia React library provides a set of hooks for accessing postchain client and ft4 token standard.

- **connectkit:**
ConnectKit provides a pre-built UI for connecting to EVM based wallets like Metamask.

- **wagmi:**
Used to interact with the EVM based wallets.


FT4 supports both Ethereum and FT keystores. See the [FT4 documentation client keystore](https://docs.chromia.com/ft4/client/client-key-store#keystore-interface) for more information.[Skip to main content](#__docusaurus_skipToContent_fallback)

## Rell Courses

#### Courses that cover Rell concepts and implementation.

[Beginner **Write your first dapp on Chromia** \\
Develop a simple book review dapp while learning Chromia's core concepts and Rell.](/courses/book-review/introduction)

[Concepts](/tags/Concepts) [Rell](/tags/Rell)

Start Course [Beginner **Chromia for EVM developers** \\
A guide for EVM developers to explore Chromia with hands-on examples.](/courses/chromia-for-evm-developers/introduction)

[Concepts](/tags/Concepts) [Rell](/tags/Rell)

Start Course [Intermediate **Create a simple app on Chromia using Rell and React** \\
Build a decentralized news feed app with database design and MetaMask integration.](/courses/my-news-feed/introduction)

[Rell](/tags/Rell) [React](/tags/React) [MetaMask](/tags/MetaMask) [FT4](/tags/FT4)

Start Course [Intermediate **Rell masterclass** \\
Optimize SQL statements and learn advanced database interactions in Rell.](/courses/rell-masterclass/introduction)

[Rell](/tags/Rell) [SQL](/tags/SQL)

Start Course [Intermediate **Monetize your dapp** \\
Explore strategies for monetizing your dapp.](/courses/monetize-dapp/introduction)

[Rell](/tags/Rell) [Multichain](/tags/Multichain) [Dapp](/tags/Dapp) [FT4](/tags/FT4)

Start Course [Intermediate **Understand relationships in Rell** \\
Master complex data relationships with Rell.](/courses/relationships-course/introduction)

[Rell](/tags/Rell) [SQL](/tags/SQL)

Start Course [Advanced **Build an event-driven multi-blockchain dapp** \\
Create a multi-blockchain dapp with event-driven communication.](/courses/icmf-course/introduction)

[Rell](/tags/Rell) [Crosschain](/tags/Crosschain) [Multichain](/tags/Multichain)

Start Course [Advanced **Build a decentralized marketplace using FT4** \\
Learn to create a marketplace dapp with NFT and token transfers.](/courses/marketplace-course/introduction)

[FT4](/tags/FT4) [Rell](/tags/Rell)

Start Course [Advanced **Create your chat agent with Chromia** \\
Learn to build and experiment with a chat agent on Chromia, focusing on AI and blockchain integration.](/courses/chat-agent-course/introduction)

[AI](/tags/AI) [Chatbot](/tags/Chatbot) [Rell](/tags/Rell)

Start Course[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Stay in the root folder of the frontend application where `package.json` is located.

### Install dependencies [​](\#install-dependencies "Direct link to Install dependencies")

Use pnpm to install all required packages:

```codeBlockLines_e6Vv
pnpm install

```

### Configure the environment [​](\#configure-the-environment "Direct link to Configure the environment")

Create a `.env` file based on `.env.example` and fill it with the appropriate values:

```codeBlockLines_e6Vv
NEXT_PUBLIC_NODE_URL=http://localhost:7740
NEXT_PUBLIC_BRID=<Your_BRID_for_the_Dapp>

```

- `NEXT_PUBLIC_NODE_URL` – URL of the Chromia blockchain node.

- `NEXT_PUBLIC_BRID` – BRID of your locally or remotely running dapp.


#### Running the application [​](\#running-the-application "Direct link to Running the application")

After installing dependencies and configuring the `.env` file, run the application locally:

```codeBlockLines_e6Vv
pnpm dev

```

The app will be available at [http://localhost:3000](http://localhost:3000).

- [Install dependencies](#install-dependencies)
- [Configure the environment](#configure-the-environment)[Skip to main content](#__docusaurus_skipToContent_fallback)

We test the dapp manually by starting the corresponding blockchains, creating a subscription, and using it to access the warehouse.

First, ensure that the blockchains are defined in the following order to align with the internal IDs used in this course:

chromia.yml

```codeBlockLines_e6Vv
blockchains:
  subscription-chain: # Chain id 0
  ...
  digital-warehouse-chain: # Chain id 1
  ...

```

To start the blockchains, you need to run the node from the project folder in a separate terminal window:

```codeBlockLines_e6Vv
chr node start

```

Proceed with the setup by creating a new keypair and storing it in the `.chromia/config` directory, the default search path for Chromia CLI:

```codeBlockLines_e6Vv
chr keygen --file .chromia/config

```

Note down the `pubkey` printed to the console. You will use this as the account ID input for our operations.

Next, attempt to register a new product category to observe that making a transaction towards the digital warehouse will fail:

```codeBlockLines_e6Vv
chr tx --cid 1 register_product_category 555 0 --await

```

Result

```codeBlockLines_e6Vv
... Operation 'digital_warehouse_chain:register_product_category' failed: No account found

```

Create a new subscription on the Subscription chain before attempting again. First, we need to determine
the blockchain rid of the digital warehouse. You can obtain this by querying the node and storing the value in a variable:

```codeBlockLines_e6Vv
DW_BRID=$(curl -s localhost:7740/brid/iid_1) && echo $DW_BRID

```

Now, you can create a new subscription. Replace `<pubkey>` with the previously generated one:

```codeBlockLines_e6Vv
chr tx --cid 0 subscribe $DW_BRID '["<pubkey>", 0]' --await

```

Note the transaction rid that was output from the command. You can now use the following command to
authenticate the digital warehouse. Replace `<tx-rid>` with the previously obtained value.

This command specifies that we intend to make a transaction towards chain ID 1 and include an
`iccf-transaction` that needs verification against chain 0:

```codeBlockLines_e6Vv
chr tx --cid 1 --iccf-source 0 --iccf-tx <tx-rid> authorize --await

```

Now, we should be able to access the system. Let's attempt to register a product category and
update the inventory again:

```codeBlockLines_e6Vv
chr tx --cid 1 register_product_category 555 0 --await

```

```codeBlockLines_e6Vv
chr tx --cid 1 update_inventory '[555, 1500, "Got some stuff"]' --await

```

Let's wrap up by generating a warehouse report and checking the receipts in the subscription chain:

```codeBlockLines_e6Vv
chr query --cid 1 create_report 'from=0' 'to=null'

```

Result

```codeBlockLines_e6Vv
[\
    "history": [\
        [555, [\
            ["amount": 1500, "comment": "Got some stuff", "product_category": 555, "transaction": 5]]\
            ]\
        ],\
    "inventory": [\
        ["UNIT": "LITRE", "product_category": 555, "stock": 1500]\
        ],\
    "warehouse_id": 1\
]

```

```codeBlockLines_e6Vv
chr query --cid 0 get_receipts 'account_id=null' 'blockchain_rid=null' 'from=null'

```

Result

```codeBlockLines_e6Vv
[\
    [\
        "account_id": x"02EEB43C7400CA3CEBDECF1C8AC049EAC05EB361FE4C003EF6D298DEA792F58526",\
        "blockchain_rid": x"237B0EE3C60CBB1884E63F883F8230FED5C804A9C6933B28FD9214D65FD033B5",\
        "payment_amount": 30,\
        "period": "WEEK",\
        "receipt_id": x"6006EFC423E9032EA4C9584CDE791623A015749FD8BA4831457CCE0769BCA20A",\
        "timestamp": 1705504892289\
    ]\
]

```

Congratulations! You have now learned how to develop a dapp that verifies transactions on another chain to authenticate users.[Skip to main content](#__docusaurus_skipToContent_fallback)

This course will guide you to explore the frontend application of the asset management system.

In this course, you will learn how to:

- The essential tools and concepts required to interact with the FT4 token standard.
- Basic interaction with the FT4 token standard.
  - Creating an account.
  - Register and mint digital assets.
  - Implement asset transfers between accounts.

## Lessons

[Lesson 1 - Set up the Frontend Application](/courses/ft4-demo-app/module-frontend-application/setup)

[Lesson 2 - Chromia tools](/courses/ft4-demo-app/module-frontend-application/tools)

[Lesson 3 - Account Registration](/courses/ft4-demo-app/module-frontend-application/account-regisration)

[Lesson 4 - Register and Mint](/courses/ft4-demo-app/module-frontend-application/register-and-mint)

[Lesson 5 - Burn Tokens](/courses/ft4-demo-app/module-frontend-application/burn)

[Lesson 6 - Transfer asset](/courses/ft4-demo-app/module-frontend-application/transfer)

[Lesson 7 - Deploy onchain](/courses/ft4-demo-app/module-frontend-application/deploy-onchain)

[Start module »](/courses/ft4-demo-app/module-frontend-application/setup)[Skip to main content](#__docusaurus_skipToContent_fallback)

In this lesson, we will explore how to transfer assets between accounts using the FT4 token standard.

We can check the balances of the accounts using the `useGetBalances` hook from the `@chromia/react` package. After fetching the balances, we can check if the account has enough tokens to transfer.

asset\_management/src/hooks/token-hooks.ts

```codeBlockLines_e6Vv
import { useCallback } from "react";

import { createAmount, op } from "@chromia/ft4";
import {
  useFtAccounts,
  useFtSession,
  useGetAllAssets,
  useGetBalances,
  usePostchainClient,
} from "@chromia/react";
import { useAccount } from "wagmi";

import { ensureBuffer } from "@/utils/ensure-buffer";
import { publicClientConfig as clientConfig } from "@/utils/generate-client-config";

export function useTransferTokens({
  onSuccess,
  onError,
}: {
  onSuccess?: (token: MintTokenParams) => void;
  onError?: (token: MintTokenParams) => void;
}) {
  const { data: ftAccounts } = useFtAccounts({ clientConfig });

  const { data: session } = useFtSession(
    ftAccounts?.length ? { clientConfig, account: ftAccounts[0] } : null,
  );

  const { flatData: balances } = useGetBalances(
    ftAccounts?.length
      ? {
          clientConfig,
          account: ftAccounts[0],
          params: [10],
          swrInfiniteConfiguration: {
            refreshInterval: 20_000,
          },
        }
      : null,
  );

  const transferTokens = useCallback(
    async (recipient: string, amount: number) => {
      if (!balances?.length) {
        return;
      }
      const asset = balances[0].asset;

      try {
        await session?.account.transfer(
          ensureBuffer(recipient),
          ensureBuffer(asset.id),
          createAmount(amount),
        );

        onSuccess?.({ ticker: asset.symbol, name: asset.name, amount });
      } catch (error) {
        console.error(error);

        onError?.({ ticker: asset.symbol, name: asset.name, amount });
      }
    },
    [balances, onError, onSuccess, session?.account],
  );

  return transferTokens;
}

```

In the code snippet above, we have created a custom hook called `useTransferTokens` that uses the `useFtSession` hook to get the current session and the `useGetBalances` hook to get the account balances and check if the account has enough tokens to transfer. If the account has enough tokens, the `transfer` method is called on the session object's account property to transfer the specified amount of tokens to the recipient account.[Skip to main content](#__docusaurus_skipToContent_fallback)

Consider the following steps involved when ordering a product through our system:

Delivery ChainFactory ChainOrder ChainDelivery ChainFactory ChainOrder Chainpar\[Complete order\]par\[Manufacturing and processing\]Userorder\_details1production\_details2delivery\_details3Produce products4Prepare delivery5shipment\_ready6Ship Product7Accept Delivery8User

1. The user creates an order and sends the details to the Order Chain (OC).
2. OC forwards the production requirements to the Factory Chain (FC).
3. OC also communicates the delivery details to the Delivery Chain (DC).
4. The factory manufactures the ordered products.
5. Delivery prepares to deliver the products once ready.
6. FC notifies DC that the order is prepared for shipping.
7. Delivery completes the delivery of the order to the user (off-chain).
8. The user confirms receipt of the delivery.

Let's model this in Rell by defining three topics, one for each message we want to send between the chains and the
content for each message. Create a new file called `messages.rell` in the `src` directory and add the following code to
it:

src/messages.rell

```codeBlockLines_e6Vv
module;

namespace topic {
    val PRODUCTION_ORDER = "L_production";
    val NEW_DELIVERY = "L_delivery";
    val SHIPMENT_READY = "L_shipment_ready";
}

namespace msg {
    struct order_details {
        customer_id: integer;
        address: text;
        products: list<product>;
    }

    struct product {
        id: integer;
        quantity: integer;
    }

    // Order -> Factory
    struct production_details {
        order_id: integer;
        products: list<product>;
    }

    // Order -> Delivery
    struct delivery_details {
        order_id: integer;
        shipping_address: text;
        customer_id: integer;
    }

    // Factory -> Delivery
    struct shipment_ready {
        order_id: integer;
    }
}

```

The prefix `L_` is essential for ICMF, restricting message access to the sender's cluster. System blockchains

alone have the privilege to send global messages, denoted by the `G_` prefix. :::[Skip to main content](#__docusaurus_skipToContent_fallback)

In order to manage assets, you need an account. In this lesson, we will overview how the account creation process handled in the asset management template.

FT4 offers `registerAccount` operation to create an account.

asset\_management/src/hooks/chromia-hooks.ts

```codeBlockLines_e6Vv
import { useCallback, useState } from "react";

import {
  AuthFlag,
  createSingleSigAuthDescriptorRegistration,
  registerAccount,
  registrationStrategy,
} from "@chromia/ft4";
import {
  useEvmKeyStore,
  useFtAccounts,
  usePostchainClient,
} from "@chromia/react";
import { IClient } from "postchain-client";
import { useAccount } from "wagmi";

import { publicClientConfig as clientConfig } from "@/utils/generate-client-config";

export const useChromiaAccount = ({
  onAccountCreated,
}: {
  onAccountCreated?: () => void;
} = {}) => {
  const [isLoading, setIsLoading] = useState(false);
  const [tried, setTried] = useState(false);
  const { address: ethAddress } = useAccount();
  const { data: client } = usePostchainClient({ config: clientConfig });
  const { data: keyStore } = useEvmKeyStore();
  const { mutate, data: ftAccounts } = useFtAccounts({ clientConfig });

  const createAccount = useCallback(async () => {
    try {
      setIsLoading(true);

      if (!ethAddress || !keyStore || !client) return;

      const ad = createSingleSigAuthDescriptorRegistration(
        [AuthFlag.Account, AuthFlag.Transfer],
        keyStore.id,
      );

      await registerAccount(
        client as IClient,
        keyStore,
        registrationStrategy.open(ad),
      );

      await mutate();

      onAccountCreated?.();
    } catch (e) {
      console.error(e);
    } finally {
      setIsLoading(false);
      setTried(true);
    }
  }, [client, ethAddress, keyStore, mutate, onAccountCreated]);

  return {
    createAccount,
    isLoading,
    tried,
    account: ftAccounts?.[0],
    hasAccount: !!ftAccounts?.length,
  };
};

```[Skip to main content](#__docusaurus_skipToContent_fallback)

The Frontend Application can be deployed in 2 ways:

1. The traditional way hosted on any server. Pleas follow the `package.json` scripts in the project.
2. On chain of the dapp node. The [instructions](https://docs.chromia.com/intro/deployment/frontend-application/deploy-on-chain).[Skip to main content](#__docusaurus_skipToContent_fallback)

In this lesson, we will walk you through the process of minting an asset using the FT4 token standard.

We will use the `register_and_mint_asset` operation defined in the `asset_management/rell/src/main.rell` file to create a new asset and mint it to an account.

To call an operation, you will need an FT4 session. You can get the current session using the `useFtSession` hook from the `@chromia/react` package.

asset\_management/src/hooks/token-hooks.ts

```codeBlockLines_e6Vv
import { useFtSession } from "@chromia/react";
import { publicClientConfig as clientConfig } from "@/utils/generate-client-config";

interface MintTokenParams {
  ticker: string;
  name: string;
  amount: number;
}

function useMintToken() {
  const { data: ftAccounts } = useFtAccounts({ clientConfig });
  const { data: session } = useFtSession(
    ftAccounts?.length ? { clientConfig, account: ftAccounts[0] } : null,
  );

  const registerAsset = useCallback(
    async (token: MintTokenParams) => {
      if (!session) return;

      try {
        await session
          .transactionBuilder()
          .add(
            op(
              "register_and_mint_asset",
              token.name,
              token.ticker,
              8,
              BigInt(token.amount),
              "https://cdn-icons-png.flaticon.com/512/4863/4863873.png",
            ),
          )
          .buildAndSend();

        onSuccess?.(token);
      } catch (error) {
        console.error(error);

        onError?.(token);
      }
    },
    [session],
  );

  return mintToken;
}

```

In the code snippet above, we have created a custom hook called `useMintToken` that uses the `useFtSession` hook to get the current session.

The `useMintToken` hook takes a `MintTokenParams` object as an argument, which contains the following properties:

- `ticker`: The ticker symbol of the asset.
- `name`: The name of the asset.
- `amount`: The amount of the asset to mint.

Transactions can be built using the `transactionBuilder` method of the session object. We add the `register_and_mint_asset` operation to the transaction using the `add` method.

Calling the `buildAndSend` method will initiate a signature request for the transaction by using the configured keystore.[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Let's implement the Subscription Chain. For this, we will need two entities; `account` to store the account balance and
`receipt` to store digital receipts for logging purposes. This is done by configuring a new blockchain in `chromia.yml`.

```codeBlockLines_e6Vv
blockchains:
  # ↓↓↓ Delete this code snippet ↓↓↓
  digital-warehouse-example:
    module: main
  # ↑↑↑ Delete this code snippet ↑↑↑

  # ↓↓↓ Add this code snippet ↓↓↓
  subscription-chain:
    module: subscription_chain
# ↑↑↑ Add this code snippet ↑↑↑

```

Create a new file `entities.rell` in the `src/subscription_chain` directory and insert the following definitions:

src/subscription\_chain/entities.rell

```codeBlockLines_e6Vv
entity account {
    key id: pubkey;
    mutable balance: integer = 10000;
}

@log
entity receipt {
    // We don't reference the account entity here since this entity may be removed
    account_id: pubkey;
    amount: integer;
    period;
    blockchain_rid: byte_array;
    index account_id, blockchain_rid;
}

```

As seen here, the account is modeled by an entity that contains an ID and a mutable balance. For simplicity, we give
users 10,000 tokens upon account creation.

note

Exercise caution when managing funds on the blockchain, and it is recommended that you utilize the FT token library.

We also have an entity called `receipt`, annotated with `@log`. This annotation ensures that all entries in this
table are permanently immutable, which is crucial for transparent monetary transaction monitoring. To achieve this, we
include `account_id` as a reference to the account. Instead of directly referencing the `account` entity, we use `account_id`
to maintain flexibility in account deletion, if necessary, for legal reasons.

In the `receipt`, we include the payment amount, the purchased period, and the blockchain RID (Resource IDentifier) of
the Digital Warehouse Chain where the payment was directed. This ensures that the Warehouse Chain can verify the payment
and prevent double-spending across chains. Additionally, we have added an index on the `account_id` and `blockchain_rid`
to enhance query performance.

## Account creation [​](\#account-creation "Direct link to Account creation")

For this simple example, accounts are created dynamically when a user wishes to subscribe. Let's implement a
straightforward function to manage this process. Add the following code block to the `functions.rell` file
stored in the `src/subscription_chain` folder.

src/subscription\_chain/functions.rell

```codeBlockLines_e6Vv
function get_or_create_account(id: pubkey) {
    require(op_context.is_signer(id));
    return account @? { id } ?: create account(id);
}

```

## Subscription [​](\#subscription "Direct link to Subscription")

To create a new subscription, we define a new operation called `subscribe`, which requires the blockchain RID of the
chain where we want to confirm this transaction. We also include the `subscription` metadata.

src/subscription\_chain/operations.rell

```codeBlockLines_e6Vv
operation subscribe(blockchain_rid: byte_array, subscription) {
    val account = get_or_create_account(subscription.account_id);
    val subscription_fee = period_price(subscription.period);
    require(account.balance >= subscription_fee, "Insufficient funds");
    account.balance-=subscription_fee;
    create receipt (
        account_id = subscription.account_id,
        subscription_fee,
        subscription.period,
        blockchain_rid
    );
}

```

This operation retrieves an existing account or creates a new one, deducts the account balance, and generates a receipt.

## Queries [​](\#queries "Direct link to Queries")

The ability to query receipts for a specific user or transaction can be helpful for monitoring purposes. Let's complete
this dapp implementation by adding a set of queries to the `queries.rell` file stored in the `src/subscription_chain`
directory.

src/subscription\_chain/queries.rell

```codeBlockLines_e6Vv
query get_receipts(account_id: pubkey?, blockchain_rid: byte_array?, from: timestamp?)
    = (receipt, account) @* {
    if (account_id??) account.id == account_id else true,
    account.id == receipt.account_id,
    if (blockchain_rid??) .blockchain_rid == blockchain_rid else true,
    if (from??) .transaction.block.timestamp >= from else true
} (
    receipt_id = .transaction.tx_rid,
    account_id = account.id,
    period = .period,
    payment_amount = .amount,
    blockchain_rid = .blockchain_rid,
    timestamp = .transaction.block.timestamp
);

```

This query lets us filter receipts based on `account_id`, `blockchain_rid`, and `timestamp`.

## Unit test [​](\#unit-test "Direct link to Unit test")

Writing unit tests for this blockchain is straightforward. To do this, create a new file named `subscription_chain_test.rell`
in the `src/test` directory and add the following code to it:

src/test/subscription\_chain\_test.rell

```codeBlockLines_e6Vv
@test module;

import subscription_chain.{ subscribe, subscription, period, account, period_price, period, get_receipts };

val TEST_WAREHOUSE_CHAIN = x"ABAB";

function test_create_subscription() {

    rell.test.tx()
        .op(subscribe(TEST_WAREHOUSE_CHAIN, subscription(rell.test.pubkeys.alice, period.WEEK)))
        .sign(rell.test.keypairs.alice)
        .run();

    val test_account = account @? { rell.test.pubkeys.alice };

    assert_not_null(test_account);
    assert_equals(test_account.balance, 10000 - period_price(period.WEEK));
    val receipts = get_receipts(test_account.id, null, null);
    assert_equals(receipts.size(), 1);
    assert_equals(receipts[0].payment_amount, 30);
    assert_equals(receipts[0].blockchain_rid, TEST_WAREHOUSE_CHAIN);
}

```

Also, you have to add new configuration details to the `chromia.yml` file:

chromia.yml

```codeBlockLines_e6Vv
blockchains:
  subscription-chain:
    module: subscription_chain
    # ↓↓↓ Add this code snippet ↓↓↓
    test:
      modules:
        - test.subscription_chain_test
    # ↑↑↑ Add this code snippet ↑↑↑

# ↓↓↓ Delete this code snippet ↓↓↓
test:
  modules:
    - test
# ↑↑↑ Delete this code snippet ↑↑↑

```

The test creates a new subscription for the test user, Alice, and checks that a receipt is generated with the correct
amounts and blockchain target. To execute the test, use the `chr test` command.

Below are the project structure and the contents of the chromia.yml configuration file after the changes have been made. It can be handy for comparison at this stage of the course:

Project structure

```codeBlockLines_e6Vv
digital-warehouse-example/
├── build/
├── src/
│   ├── lib/
│   ├── subscription_chain/
│   │   ├── entities.rell
│   │   ├── functions.rell
│   │   ├── module.rell
│   │   ├── operations.rell
│   │   └── queries.rell
│   ├── test/
│   │   └── subscription_chain_test.rell
│   └── main.rell
├── .gitignore
└── chromia.yml

```

Final version of the `chromia.yml` file

chromia.yml

```codeBlockLines_e6Vv
blockchains:
  subscription-chain:
    module: subscription_chain
    test:
      modules:
        - test.subscription_chain_test
compile:
  rellVersion: 0.13.5
database:
  schema: schema_digital_warehouse_example
libs:
  iccf:
    registry: https://gitlab.com/chromaway/core/directory-chain
    path: src/iccf
    tagOrBranch: 1.32.2
    rid: x"1D567580C717B91D2F188A4D786DB1D41501086B155A68303661D25364314A4D"

```

- [Account creation](#account-creation)
- [Subscription](#subscription)
- [Queries](#queries)
- [Unit test](#unit-test)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In this course, we will build a simple digital warehouse where users are authorized by providing a fictional payment on
another chain. The proofs are constructed and verified by the Inter-Chain Confirmation Facility (ICCF).

ICCF provides a straightforward method for constructing proof that a transaction has occurred on one chain and verifying
this proof on another chain. While this facility enables message sending, it should not be confused with the Inter-Chain
Messaging Facility (ICMF), which you can learn more about [here](/courses/icmf-course/introduction).

Confirming an event (transaction) can be described by the following sequence:

Target ChainCluster Anchoring ChainSource ChainTarget ChainCluster Anchoring ChainSource Chaincritical\[Construct Proof\]critical\[Verify proof\]UserMake Transaction1Transaction Confirmed2Anchor Block3Block Anchored4Obtain Proof of Transaction5Present Proof of Transaction6Verifies Proof7Transaction Confirmed8User

1. The user sends a transaction to the source chain.
2. The source chain confirms the transaction and includes it in a block.
3. The block is sent to the cluster anchoring chain as a transaction.
4. The cluster anchoring chain verifies the block (anchors) and includes it in its own block.
5. The user constructs a proof by obtaining a confirmation proof for the transaction.
6. The user presents the proof to the target chain as another transaction.
7. The target chain validates the proof by verifying its anchoring in the cluster anchoring chain.
8. The target chain completes its verification by including the proof in a block.

As seen in this flow, the user drives this operation. The user constructs and presents the proof, making this step
asynchronous and possible anytime after the blocks have been confirmed. This approach is particularly suitable for
applications focusing on proving occurrences rather than transferring data. While it can be used for sending messages,
if the user is not concerned with verifying when the message arrives, using the messaging facility (ICMF) might be more
appropriate.

In this course, we will explore a scenario where one blockchain handles monetary transactions and subscriptions while
another chain manages the business logic. This setup allows us to prove that a monetary transaction occurred without the
money leaving the first chain.

## Repository link [​](\#repository-link "Direct link to Repository link")

The complete code repository for this course is available here:
[ICCF course repository](https://bitbucket.org/chromawallet/iccf-course).

- [Repository link](#repository-link)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

This course will guide you through building a decentralized marketplace where users can buy and sell game trading cards.

What we will cover:

- Registering a payment token to be used in the marketplace
- Registering and setting up user accounts
- Defining and minting NFTs using a model built in rell
- Building a marketplace where you can list NFTs for sale
- Handling transactions and transfering NFTs and Payment tokens between users

For many of these operations, we will use the
[Chromia FT4 library](https://docs.chromia.com/category/ft4-accounts-and-tokens), which manages accounts and assets and
handles transfers between accounts.

## Repository link [​](\#repository-link "Direct link to Repository link")

The complete code repository for this course is available here:
[Marketplace course repository](https://bitbucket.org/chromawallet/marketplace-course).

- [Repository link](#repository-link)[Skip to main content](#__docusaurus_skipToContent_fallback)

In this module, we will build our complete marketplace, supporting buying mystery cards, listing your cards on the marketplace, and operating to purchase cards from other users.

## Lessons

[Lesson 1 - Add a fee for buying a mystery card](/courses/marketplace-course/module-assets/buy-mystery-card)

[Lesson 2 - List a card for sale on the marketplace](/courses/marketplace-course/module-assets/list-card)

[Lesson 3 - Purchase a card from the marketplace](/courses/marketplace-course/module-assets/buy-listed-card)

[Lesson 4 - Test our marketplace](/courses/marketplace-course/module-assets/test-marketplace)

[Lesson 5 - Test using Chromia CLI](/courses/marketplace-course/module-assets/test-cli)

[Start module »](/courses/marketplace-course/module-assets/buy-mystery-card)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In this course, we will build a dapp consisting of three blockchains: Order, Factory, and Delivery. They will interact
with each other using ICMF.

The dapp we will build is an ordering system consisting of three blockchains:

1. Ordering chain: Users can order products using this chain
2. Factory chain: Produces products and keeps statistics of how many products have been created
3. Delivery chain: Handles delivery of orders to customers

The main idea for this system is to separate concerns for different actors. Products are made available on the order
chain and can be ordered (bought) by a user. Factory workers only need to interact with the factory chain. Delivery
companies only need to interact with the delivery chain. There are other ways to slice a dapp into several blockchains,
for example, in terms of sharding (having several factories for different product types) to either parallelize the
workload or to achieve different time scales (a factory may produce big batches, but the order and deliver chain need to
handle separate orders), but this serves as an excellent example on how to use the ICMF.

The system we will build can be modeled like this:

Production order

Delivery order

Shipment ready

Order Chain

Factory Chain

Delivery Chain

ICMF can be compared to a message queue, where a chain can emit events on a specific topic or subscribe to several
topics. This is an integral part of the architecture of Chromia, where blockchains need to communicate without user
interaction.

Sending a message using ICMF is easy in Rell, but what actually happens under the hood?

Receiver ChainSender ChainReceiver DappReceiver BlockchainSender BlockchainSender DappReceiver DappReceiver BlockchainSender BlockchainSender Dapploop\[Every block\]send\_message1put message in block header2Poll Topic3operation \_\_icmf\_message4Call function receive\_icmf\_message5

1. The sender dapp calls the function `send_message`, a part of the ICMF Rell library. This could be user-triggered via
an operation or by the dapp itself.
2. This emits an event on the node, which is sent to the cluster's anchoring chain.
3. The receiver node polls for messages on the subscribed topics before each block gets built.
4. When a message is found, the node calls the `__icmf_message` special operation on the dapp.
5. The ICMF library calls the function `receive_icmf_message`, which triggers any logic defined by the dapp.

Based on this, the ideal type of dapp for this type of messaging is when you want chains to broadcast a message to
indicate that it has completed an action. Then, it's up to the other chains to subscribe to this action and perform an
action based on the information in the message. This way, you can add more chains to your solution with new
responsibilities, and they must subscribe to their topics of interest. No logic needs to be changed in the sender chain.

In our scenario, the factory workers don't care who created an order and when it was created. They only care about
_that_ an order is created and start their manufacturing process, similarly, for the Delivery chain. The delivery
company only cares about what box or products they should deliver and where, not what's in the box.

## Repository link [​](\#repository-link "Direct link to Repository link")

The complete code repository for this course is available here:
[ICMF course repository](https://bitbucket.org/chromawallet/icmf-course).

- [Repository link](#repository-link)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Before we start, please make sure you have the following prerequisites in place:

Set up PostgreSQL database

Rell requires PostgreSQL 16.3. The IDE can work without it but can't run a node. A console or a remote postchain app can
run without a database.

The default database configuration for Rell is:

- database: `postchain`
- user: `postchain`
- password: `postchain`

## Install [​](\#install "Direct link to Install")

- Mac
- Linux
- Docker
- Windows

1. Install Homebrew: [Homebrew installation guide](https://brew.sh/)

2. Install PostgreSQL:





```codeBlockLines_e6Vv
brew install postgresql@16
brew services start postgresql@16
createuser -s postgres

```

3. Prepare the PostgreSQL database:





```codeBlockLines_e6Vv
psql -U postgres -c "CREATE DATABASE postchain WITH TEMPLATE = template0 LC_COLLATE = 'C.UTF-8' LC_CTYPE = 'C.UTF-8' ENCODING 'UTF-8';" -c "CREATE ROLE postchain LOGIN ENCRYPTED PASSWORD 'postchain'; GRANT ALL ON DATABASE postchain TO postchain;"

```











note





If you get an error saying peer authentication failed, you must change the authentication method from `peer` to
`md5`. You can change it in the `pg_hba.conf` file of your `psql` database.


1. Install PostgreSQL:





```codeBlockLines_e6Vv
sudo apt install postgresql-16

```

2. Prepare the PostgreSQL database:





```codeBlockLines_e6Vv
sudo -u postgres psql -c "CREATE DATABASE postchain WITH TEMPLATE = template0 LC_COLLATE = 'C.UTF-8' LC_CTYPE = 'C.UTF-8' ENCODING 'UTF-8';" -c "CREATE ROLE postchain LOGIN ENCRYPTED PASSWORD 'postchain'; GRANT ALL ON DATABASE postchain TO postchain;"

```


1. Install Docker: [Docker installation guide](https://docs.docker.com/engine/install/)

2. Prepare the PostgreSQL database:





```codeBlockLines_e6Vv
docker run --name postgres -e POSTGRES_USER=postchain -e POSTGRES_PASSWORD=postchain -p 5432:5432 -d postgres:16.3-alpine3.20

```











note





We use the Alpine version of PostgreSQL because it provides the correct collation settings by default. This can be
explicitly set using the environment variable:







```codeBlockLines_e6Vv
POSTGRES_INITDB_ARGS="--lc-collate=C.UTF-8 --lc-ctype=C.UTF-8 --encoding=UTF-8"

```


1. Download the PostgreSQL installer from the [official website](https://www.postgresql.org/download/windows/).

2. Install the executable and add the PostgreSQL folder containing the binaries to your environment variables. Open the
Command Prompt (CMD) and run the following command, ensuring that you set the path to your binaries correctly and
replace the `<version>` placeholder with the actual version number:





```codeBlockLines_e6Vv
setx POSTGRESQL "C:\Program Files\PostgreSQL\<version>\bin"

```

3. Reopen the Command Prompt (CMD) to update the environment variables. Prepare the PostgreSQL database by running the
following two commands sequentially:





```codeBlockLines_e6Vv
psql -U postgres -c "CREATE DATABASE postchain WITH TEMPLATE = template0 LC_COLLATE = 'en_US.UTF-8' LC_CTYPE = 'en_US.UTF-8' ENCODING 'UTF-8';"
psql -U postgres -c "CREATE ROLE postchain LOGIN ENCRYPTED PASSWORD 'postchain'; GRANT ALL ON DATABASE postchain TO postchain;"

```











note





Depending on your Windows version, you may encounter various errors related to permissions or incorrect PostgreSQL
installations. If this happens, we recommend installing Docker and deploying the PostgreSQL container.


Install Chromia CLI

This topic contains instructions to install and update the
[Chromia CLI](https://gitlab.com/chromaway/core-tools/chromia-cli).

## Prerequisite [​](\#prerequisite "Direct link to Prerequisite")

Before proceeding, make sure the following prerequisites are met:

- **PostgreSQL database**: See [Set up PostgreSQL database](/docs/install/database-setup).
- **RELL\_JAVA environment**: Chromia CLI do requries a java runtime (version 21 or later) to execute. Through the
different package managers this has been abstracted away for you so you don't need to set this up. If you want to
control which java runtime you use to execute Chromia CLI with it is recomended to set RELL\_JAVA variable in your
environment to point to a valid Java installation

## Installation [​](\#installation "Direct link to Installation")

You can install Chromia CLI using a package manager or by downloading it directly from
[Chromia CLI Packages](https://gitlab.com/chromaway/core-tools/chromia-cli/-/packages).

- macOS
- Linux/WSL
- Windows

To install Chromia CLI ( `chr`) on macOS, follow these steps:

1. If Homebrew is not installed, install it by running:





```codeBlockLines_e6Vv
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

```

2. Add the Chromia repository to Homebrew by running the following command:





```codeBlockLines_e6Vv
brew tap chromia/core https://gitlab.com/chromaway/core-tools/homebrew-chromia.git

```

3. Install Chromia CLI with:





```codeBlockLines_e6Vv
brew install chromia/core/chr

```











info





To install a specific version of Chromia CLI, use the following commands:







```codeBlockLines_e6Vv
brew install chromia/core/chr@<version>
brew unlink chr
brew link chr@<version>

```











You can list available versions using: `brew search chr`.

4. To verify the installation, check the version by running:





```codeBlockLines_e6Vv
chr --version

```


To install Chromia CLI ( `chr`) on Linux or WSL (Windows Subsystem for Linux), follow these steps:

1. Download and add Chromia's `apt-repo` public key to your system’s trusted keyrings:





```codeBlockLines_e6Vv
curl -fsSL https://apt.chromia.com/chromia.gpg | sudo tee /usr/share/keyrings/chromia.gpg

```

2. Add the Chromia repository to your list of package sources:





```codeBlockLines_e6Vv
echo "deb [arch=amd64 signed-by=/usr/share/keyrings/chromia.gpg] https://apt.chromia.com stable main" | sudo tee /etc/apt/sources.list.d/chromia.list

```

3. Run the following command to update your package sources:





```codeBlockLines_e6Vv
sudo apt-get update

```











info





If you added `apt.chromia.com` before Chromia CLI version `0.16.0`, run the following command to allow the repository
update:







```codeBlockLines_e6Vv
sudo apt-get --allow-releaseinfo-change update

```

4. Once the repository is updated, install Chromia CLI by running:





```codeBlockLines_e6Vv
sudo apt-get install chr

```

5. To verify that Chromia CLI is installed successfully, check the version:





```codeBlockLines_e6Vv
chr --version

```


To install Chromia CLI ( `chr`) on Windows using [Scoop](https://scoop.sh/), follow these steps:

1. If Scoop is not installed, install it by running the following command in PowerShell (run as Administrator):





```codeBlockLines_e6Vv
iwr -useb get.scoop.sh | iex

```

2. Add the Chromia repository (bucket) to Scoop by running:





```codeBlockLines_e6Vv
scoop bucket add chromia https://gitlab.com/chromaway/core-tools/scoop-chromia/

```

3. Add the Java bucket to Scoop by running:





```codeBlockLines_e6Vv
scoop bucket add java

```









This will enable scoop to download the openjdk21 which chromia-cli depends on when installing

4. Install Chromia CLI by running:





```codeBlockLines_e6Vv
scoop install chr

```

5. To verify that Chromia CLI is installed successfully, check the version:





```codeBlockLines_e6Vv
chr --version

```


## Updating Chromia CLI [​](\#updating-chromia-cli "Direct link to Updating Chromia CLI")

You can download and install the latest Chromia CLI from
[here](https://gitlab.com/chromaway/core-tools/chromia-cli/-/packages), or if you have installed the Chromia CLI via a
package manager, you can update it with the following:

- macOS
- Linux
- Windows

```codeBlockLines_e6Vv
brew update
brew upgrade chr

```

```codeBlockLines_e6Vv
sudo apt-get update
sudo apt-get install chr

```

```codeBlockLines_e6Vv
scoop update
scoop update chr

```

## Docker [​](\#docker "Direct link to Docker")

Docker can run a standalone Linux container with the Chromia CLI pre-installed. Make sure that you have set up the
[PostgreSQL database](/docs/install/database-setup).

To use the published Docker images, you must first have Docker installed and configured on your host machine. Please
refer to the Docker documentation on how to [install Docker](https://docs.docker.com/get-docker/) on Windows, Mac, and
Linux.

### Start the Docker container with Chromia CLI pre-installed [​](\#start-the-docker-container-with-chromia-cli-pre-installed "Direct link to Start the Docker container with Chromia CLI pre-installed")

To run the latest version of the Chromia CLI, use the `docker run` command and specify the CLI Docker image name and
`chr`.

```codeBlockLines_e6Vv
docker run --rm -v $(pwd):/usr/app registry.gitlab.com/chromaway/core-tools/chromia-cli/chr:<latest version> chr

```

note

Make sure to configure your `chromia.yml` file correctly:

- **Mac**: Use `host.docker.internal` for `database:host`.
- **Windows**: Set `database:host` to `172.17.0.1`.
- **Linux**: Use the `--network=host` argument in Docker commands.

These configurations are crucial to ensure connectivity between Chromia CLI and the PostgreSQL instance.

See the [Docker command line reference](https://docs.docker.com/engine/reference/commandline/docker/) for more
information on updating or uninstalling the Docker image.

```codeBlockLines_e6Vv
#!/bin/bash

# Allocate a pseudo-TTY one when run in interactive mode
if [ -t 0 ] && [ -t 1 ] ; then TTY="--tty"; else TTY=""; fi

docker run \
  # Sets the network to host to not need to change the database hostname (linux only)
  --network=host \
  # Set timezone based on system settings (linux only)
  -e TZ=$(cat /etc/timezone) \
  # Sets process ownership to current user
  --user $(id -u):$(id -g) \
  --mount type=bind,source="/etc/passwd",target=/etc/passwd,readonly \
  --mount type=bind,source="/etc/group",target=/etc/group,readonly \
  # Configures ssh-agent (only needed if chr install is called on non-public repositores)
  -e SSH_AUTH_SOCK=$SSH_AUTH_SOCK \
  --volume "$SSH_AUTH_SOCK:$SSH_AUTH_SOCK" \
  --mount type=bind,source="${HOME}/.ssh",target=${HOME}/.ssh,readonly \
  --mount type=bind,source="${HOME}/.config/jgit",target=${HOME}/.config/jgit \
  # Mounts current folder into the container (Use `Get-Location` on PowerShell)
  --mount type=bind,source="$(pwd)",target=/usr/app \
  --interactive ${TTY} \
  --rm \
  registry.gitlab.com/chromaway/core-tools/chromia-cli/chr:${CHR_VERSION:-latest} chr "$@"

```

Let's kick things off by setting up your blockchain app project using the Chromia CLI.

Create a new directory for your project and navigate to it:

```codeBlockLines_e6Vv
chr create-rell-dapp asset_management --template=asset-management

```

```codeBlockLines_e6Vv
cd asset_management

```

- [Install](#install)
- [Prerequisite](#prerequisite)
- [Installation](#installation)
- [Updating Chromia CLI](#updating-chromia-cli)
- [Docker](#docker)
  - [Start the Docker container with Chromia CLI pre-installed](#start-the-docker-container-with-chromia-cli-pre-installed)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

The decentralized application (dapp) we are developing comprises two blockchains: the Subscription Chain and the Digital
Warehouse Chain.

Digital Warehouse ChainSubscription ChainDigital Warehouse ChainSubscription ChainUserMake Payment1Construct Proof2Present Proof of Payment3Access Granted4User

The user initiates a payment on the Subscription Chain to establish a 'subscription'. This involves deducting a specified
value from the user's account. This process can be further customized and expanded using the [FT-library](https://docs.chromia.com/category/ft4-accounts-and-tokens) at a later stage. Subsequently, the user presents a payment receipt to the Digital Warehouse Chain, enabling access to the system. This access facilitates the user in managing inventory updates within a fictional warehouse.

This architecture facilitates the management of multiple warehouses through the deployment of multiple warehouse chains.
By delegating payment processing to another chain, this component could potentially integrate into a broader, more versatile
system.

## Subscription model [​](\#subscription-model "Direct link to Subscription model")

To model our subscription, we will create a structure that can be passed to the Subscription Chain and later verified on
the Digital Warehouse chain. This structure will serve as metadata to be extracted by the warehouse during payment
verification. Let’s create a new directory called `subscription_chain` and add a file named `module.rell` to it.

src/subscription\_chain/module.rell

```codeBlockLines_e6Vv
module;

```

Create a file named `entities.rell` in the `src/subscription_chain` directory and insert the following code:

src/subscription\_chain/entities.rell

```codeBlockLines_e6Vv
struct subscription {
    account_id: pubkey;
    period;
}

enum period {
    WEEK,
    MONTH,
}

val MILLIS_IN_A_DAY = 24 * 60 * 60 * 1000;

```

Create another file called `functions.rell` in the `src/subscription_chain` and insert the following code:

src/subscription\_chain/functions.rell

```codeBlockLines_e6Vv
function period_price(period): integer {
    return when (period) {
        MONTH -> 90;
        else -> 30;
    };
}

function period_to_millis(period): integer {
    return MILLIS_IN_A_DAY * when (period) {
        MONTH -> 30;
        else -> 7;
    } ;
}

```

When a user requests a new subscription, we set the account ID and period. Additionally, utility functions are provided
to convert the period to an associated price and duration.

- [Subscription model](#subscription-model)[Skip to main content](#__docusaurus_skipToContent_fallback)

We will test the dapp manually by starting three blockchains locally, placing a customer order, and then tracing its
path through the blockchains.

First, ensure that your chains are configured in the following order in your `chromia.yml` file.

chromia.yml

```codeBlockLines_e6Vv
blockchains:
  order-chain: # internal id 0
    ...
  delivery-chain: # internal id 1
    ...
  factory-chain: # internal id 2
    ...

```

The Chromia CLI will initiate the chains sequentially based on their internal IDs as defined. Knowing these IDs is
advantageous for testing purposes, as they are more convenient to handle compared to the referential ID (brid).

Let's start testing by starting the node in a separate terminal window.

```codeBlockLines_e6Vv
chr node start

```

We then proceed with the setup by registering two products, with ID 101 and 102:

```codeBlockLines_e6Vv
chr tx --cid 0 register_product 101 --await

```

```codeBlockLines_e6Vv
chr tx --cid 0 register_product 102 --await

```

Now we are ready to make our first order. The input argument to `make_customer_order` is a struct of type
`order_details`. A struct should be encoded as an array when passed through the CLI, so making an order for 1 product of
type 101 and 10 products of type 102 sent to a customer with id 1104 on address Homestreet 2 would be encoded as
`[1104, "Homestreet 2", [[101, 1], [102, 10]]]`. Let's make an order using these details to chain 0:

```codeBlockLines_e6Vv
chr tx --cid 0 make_customer_order '[1104, "Homestreet 2", [[101, 1], [102, 10]]]' --await

```

Note the additional quotes around the order details to ensure our terminal parses it as a single program argument.

To verify that our order was created, we can query the order chain for all orders:

```codeBlockLines_e6Vv
chr query --cid 0 list_orders

```

Result

```codeBlockLines_e6Vv
[{details=[{product_id=102, quantity=10}, {product_id=101, quantity=1}], order_id=3}]

```

Let's also verify that the factory chain with ID 2 has manufactured the products with the correct amount. We will
perform the following query:

```codeBlockLines_e6Vv
chr query --cid 2 get_total_manufactured_products

```

Result

```codeBlockLines_e6Vv
[{id=101, quantity=1}, {id=102, quantity=10}]

```

Finally, verifying that the delivery chain, with ID 1, has created a delivery for us and has a status:

```codeBlockLines_e6Vv
chr query --cid 1 list_deliveries

```

Result

```codeBlockLines_e6Vv
[{customer_id=1104, order_id=3, shipping_address="Homestreet 2", shipping_state="DISPATCHED"}]

```

The `shipping_state` will be either CREATED or DISPATCHED depending on whether the chain has processed the second
message. If it has not, wait a few seconds. For completeness, we can mark the delivery as DELIVERED by calling the
following command:

```codeBlockLines_e6Vv
chr tx --cid 1 accept_delivery 3

```

Congratulations! You have now built your first multi-chain app![Skip to main content](#__docusaurus_skipToContent_fallback)

In the minting lesson, we added the `operation buy_mystery_card`, which a user calls to mint a new random card. But for it to actually be a purchase operation, we need to set a price and withdraw this amount from the user when the operation is called.

The card cost will be withdrawn from the user and added to a particular dapp account, which holds all revenues from card sales.

This dapp economy account doesn't exist yet, so let's use FT4 again to create this account. We need to add a new entity, `dapp_account`, to store our economy account, which gives us easy access to this account from our Rell code.

We define a structure in our Rell code to reference the account.

rell\_marketplace/module.rell

```codeBlockLines_e6Vv
struct module_args {
    dapp_account_signer: pubkey;
}

```

Then we create the account in the `dapp_meta` object we declared earlier.

rell\_marketplace/module.rell

```codeBlockLines_e6Vv
import lib.ft4.core.accounts.{ account, create_account_with_auth, single_sig_auth_descriptor };

object dapp_meta {
    asset = Unsafe.register_asset("Collector Card", "CRD", 6, chain_context.blockchain_rid, "https://url-to-asset-icon");
    account = create_account_with_auth(single_sig_auth_descriptor(chain_context.args.dapp_account_signer, set(["A", "T"])));
}

```

Let's break it down: we use the function `create_account_with_auth` to create a new account, and we pass a single signature auth descriptor with these values:

- Dapp account pubkey from moduleArgs settings
- Flags are "A" for managing accounts and "T" to allow token transfers using this account.

Then, we create a new keypair which we will use as "account owner" for our dapp:

```codeBlockLines_e6Vv
chr keygen --file .chroma/dapp-account

```

Then we open `chromia.yaml` add this as a module argument, and add the `pubkey` to the economy account as value.

chromia.yml

```codeBlockLines_e6Vv
blockchains:
  rell-marketplace:
    module: main
    moduleArgs:
      lib.ft4.core.accounts:
        rate_limit:
          max_points: 10
          recovery_time: 5000
          points_at_account_creation: 2
      rell_marketplace:
        dapp_account_signer: x"<dapp_account_pubkey>"
compile:
  rellVersion: 0.13.5
database:
  schema: schema_rell_marketplace
test:
  modules:
    - rell_marketplace_test
  moduleArgs:
    rell_marketplace:
      dapp_account_signer: x"<dapp_account_pubkey>"

```

Now, we have an account to which we can transfer charges. For example, when someone buys a card, we transfer the amount from the user to this account.

Let's put this to use by adding a transfer when a user buys a mystery card. We add a transfer with the following parameters:

- From account
- To account
- Asset
- Amount

Our operation `buy_mystery_card` will now look like this

rell\_marketplace/marketplace.rell

```codeBlockLines_e6Vv
operation buy_mystery_card() {
    val account = auth.authenticate();
    Unsafe.transfer(account, dapp_meta.account, dapp_meta.asset, 100);
    mint_card(account);
}

```

In this operation we fixed the price of purchasing a card to 100 CRD, which will transfer 100 CRD from the authenticated account to our `dapp_account`.

Dapp Fee AccountDappUserDapp Fee AccountDappUserBuys a cardTransfer 100 CRD from the User to the dapp fee accountMint new Card NFTThe user is set as the owner of the minted NFT[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Before we start, please make sure you have the following prerequisites in place:

Set up PostgreSQL database

Rell requires PostgreSQL 16.3. The IDE can work without it but can't run a node. A console or a remote postchain app can
run without a database.

The default database configuration for Rell is:

- database: `postchain`
- user: `postchain`
- password: `postchain`

## Install [​](\#install "Direct link to Install")

- Mac
- Linux
- Docker
- Windows

1. Install Homebrew: [Homebrew installation guide](https://brew.sh/)

2. Install PostgreSQL:





```codeBlockLines_e6Vv
brew install postgresql@16
brew services start postgresql@16
createuser -s postgres

```

3. Prepare the PostgreSQL database:





```codeBlockLines_e6Vv
psql -U postgres -c "CREATE DATABASE postchain WITH TEMPLATE = template0 LC_COLLATE = 'C.UTF-8' LC_CTYPE = 'C.UTF-8' ENCODING 'UTF-8';" -c "CREATE ROLE postchain LOGIN ENCRYPTED PASSWORD 'postchain'; GRANT ALL ON DATABASE postchain TO postchain;"

```











note





If you get an error saying peer authentication failed, you must change the authentication method from `peer` to
`md5`. You can change it in the `pg_hba.conf` file of your `psql` database.


1. Install PostgreSQL:





```codeBlockLines_e6Vv
sudo apt install postgresql-16

```

2. Prepare the PostgreSQL database:





```codeBlockLines_e6Vv
sudo -u postgres psql -c "CREATE DATABASE postchain WITH TEMPLATE = template0 LC_COLLATE = 'C.UTF-8' LC_CTYPE = 'C.UTF-8' ENCODING 'UTF-8';" -c "CREATE ROLE postchain LOGIN ENCRYPTED PASSWORD 'postchain'; GRANT ALL ON DATABASE postchain TO postchain;"

```


1. Install Docker: [Docker installation guide](https://docs.docker.com/engine/install/)

2. Prepare the PostgreSQL database:





```codeBlockLines_e6Vv
docker run --name postgres -e POSTGRES_USER=postchain -e POSTGRES_PASSWORD=postchain -p 5432:5432 -d postgres:16.3-alpine3.20

```











note





We use the Alpine version of PostgreSQL because it provides the correct collation settings by default. This can be
explicitly set using the environment variable:







```codeBlockLines_e6Vv
POSTGRES_INITDB_ARGS="--lc-collate=C.UTF-8 --lc-ctype=C.UTF-8 --encoding=UTF-8"

```


1. Download the PostgreSQL installer from the [official website](https://www.postgresql.org/download/windows/).

2. Install the executable and add the PostgreSQL folder containing the binaries to your environment variables. Open the
Command Prompt (CMD) and run the following command, ensuring that you set the path to your binaries correctly and
replace the `<version>` placeholder with the actual version number:





```codeBlockLines_e6Vv
setx POSTGRESQL "C:\Program Files\PostgreSQL\<version>\bin"

```

3. Reopen the Command Prompt (CMD) to update the environment variables. Prepare the PostgreSQL database by running the
following two commands sequentially:





```codeBlockLines_e6Vv
psql -U postgres -c "CREATE DATABASE postchain WITH TEMPLATE = template0 LC_COLLATE = 'en_US.UTF-8' LC_CTYPE = 'en_US.UTF-8' ENCODING 'UTF-8';"
psql -U postgres -c "CREATE ROLE postchain LOGIN ENCRYPTED PASSWORD 'postchain'; GRANT ALL ON DATABASE postchain TO postchain;"

```











note





Depending on your Windows version, you may encounter various errors related to permissions or incorrect PostgreSQL
installations. If this happens, we recommend installing Docker and deploying the PostgreSQL container.


Install Chromia CLI

This topic contains instructions to install and update the
[Chromia CLI](https://gitlab.com/chromaway/core-tools/chromia-cli).

## Prerequisite [​](\#prerequisite "Direct link to Prerequisite")

Before proceeding, make sure the following prerequisites are met:

- **PostgreSQL database**: See [Set up PostgreSQL database](/docs/install/database-setup).
- **RELL\_JAVA environment**: Chromia CLI do requries a java runtime (version 21 or later) to execute. Through the
different package managers this has been abstracted away for you so you don't need to set this up. If you want to
control which java runtime you use to execute Chromia CLI with it is recomended to set RELL\_JAVA variable in your
environment to point to a valid Java installation

## Installation [​](\#installation "Direct link to Installation")

You can install Chromia CLI using a package manager or by downloading it directly from
[Chromia CLI Packages](https://gitlab.com/chromaway/core-tools/chromia-cli/-/packages).

- macOS
- Linux/WSL
- Windows

To install Chromia CLI ( `chr`) on macOS, follow these steps:

1. If Homebrew is not installed, install it by running:





```codeBlockLines_e6Vv
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

```

2. Add the Chromia repository to Homebrew by running the following command:





```codeBlockLines_e6Vv
brew tap chromia/core https://gitlab.com/chromaway/core-tools/homebrew-chromia.git

```

3. Install Chromia CLI with:





```codeBlockLines_e6Vv
brew install chromia/core/chr

```











info





To install a specific version of Chromia CLI, use the following commands:







```codeBlockLines_e6Vv
brew install chromia/core/chr@<version>
brew unlink chr
brew link chr@<version>

```











You can list available versions using: `brew search chr`.

4. To verify the installation, check the version by running:





```codeBlockLines_e6Vv
chr --version

```


To install Chromia CLI ( `chr`) on Linux or WSL (Windows Subsystem for Linux), follow these steps:

1. Download and add Chromia's `apt-repo` public key to your system’s trusted keyrings:





```codeBlockLines_e6Vv
curl -fsSL https://apt.chromia.com/chromia.gpg | sudo tee /usr/share/keyrings/chromia.gpg

```

2. Add the Chromia repository to your list of package sources:





```codeBlockLines_e6Vv
echo "deb [arch=amd64 signed-by=/usr/share/keyrings/chromia.gpg] https://apt.chromia.com stable main" | sudo tee /etc/apt/sources.list.d/chromia.list

```

3. Run the following command to update your package sources:





```codeBlockLines_e6Vv
sudo apt-get update

```











info





If you added `apt.chromia.com` before Chromia CLI version `0.16.0`, run the following command to allow the repository
update:







```codeBlockLines_e6Vv
sudo apt-get --allow-releaseinfo-change update

```

4. Once the repository is updated, install Chromia CLI by running:





```codeBlockLines_e6Vv
sudo apt-get install chr

```

5. To verify that Chromia CLI is installed successfully, check the version:





```codeBlockLines_e6Vv
chr --version

```


To install Chromia CLI ( `chr`) on Windows using [Scoop](https://scoop.sh/), follow these steps:

1. If Scoop is not installed, install it by running the following command in PowerShell (run as Administrator):





```codeBlockLines_e6Vv
iwr -useb get.scoop.sh | iex

```

2. Add the Chromia repository (bucket) to Scoop by running:





```codeBlockLines_e6Vv
scoop bucket add chromia https://gitlab.com/chromaway/core-tools/scoop-chromia/

```

3. Add the Java bucket to Scoop by running:





```codeBlockLines_e6Vv
scoop bucket add java

```









This will enable scoop to download the openjdk21 which chromia-cli depends on when installing

4. Install Chromia CLI by running:





```codeBlockLines_e6Vv
scoop install chr

```

5. To verify that Chromia CLI is installed successfully, check the version:





```codeBlockLines_e6Vv
chr --version

```


## Updating Chromia CLI [​](\#updating-chromia-cli "Direct link to Updating Chromia CLI")

You can download and install the latest Chromia CLI from
[here](https://gitlab.com/chromaway/core-tools/chromia-cli/-/packages), or if you have installed the Chromia CLI via a
package manager, you can update it with the following:

- macOS
- Linux
- Windows

```codeBlockLines_e6Vv
brew update
brew upgrade chr

```

```codeBlockLines_e6Vv
sudo apt-get update
sudo apt-get install chr

```

```codeBlockLines_e6Vv
scoop update
scoop update chr

```

## Docker [​](\#docker "Direct link to Docker")

Docker can run a standalone Linux container with the Chromia CLI pre-installed. Make sure that you have set up the
[PostgreSQL database](/docs/install/database-setup).

To use the published Docker images, you must first have Docker installed and configured on your host machine. Please
refer to the Docker documentation on how to [install Docker](https://docs.docker.com/get-docker/) on Windows, Mac, and
Linux.

### Start the Docker container with Chromia CLI pre-installed [​](\#start-the-docker-container-with-chromia-cli-pre-installed "Direct link to Start the Docker container with Chromia CLI pre-installed")

To run the latest version of the Chromia CLI, use the `docker run` command and specify the CLI Docker image name and
`chr`.

```codeBlockLines_e6Vv
docker run --rm -v $(pwd):/usr/app registry.gitlab.com/chromaway/core-tools/chromia-cli/chr:<latest version> chr

```

note

Make sure to configure your `chromia.yml` file correctly:

- **Mac**: Use `host.docker.internal` for `database:host`.
- **Windows**: Set `database:host` to `172.17.0.1`.
- **Linux**: Use the `--network=host` argument in Docker commands.

These configurations are crucial to ensure connectivity between Chromia CLI and the PostgreSQL instance.

See the [Docker command line reference](https://docs.docker.com/engine/reference/commandline/docker/) for more
information on updating or uninstalling the Docker image.

```codeBlockLines_e6Vv
#!/bin/bash

# Allocate a pseudo-TTY one when run in interactive mode
if [ -t 0 ] && [ -t 1 ] ; then TTY="--tty"; else TTY=""; fi

docker run \
  # Sets the network to host to not need to change the database hostname (linux only)
  --network=host \
  # Set timezone based on system settings (linux only)
  -e TZ=$(cat /etc/timezone) \
  # Sets process ownership to current user
  --user $(id -u):$(id -g) \
  --mount type=bind,source="/etc/passwd",target=/etc/passwd,readonly \
  --mount type=bind,source="/etc/group",target=/etc/group,readonly \
  # Configures ssh-agent (only needed if chr install is called on non-public repositores)
  -e SSH_AUTH_SOCK=$SSH_AUTH_SOCK \
  --volume "$SSH_AUTH_SOCK:$SSH_AUTH_SOCK" \
  --mount type=bind,source="${HOME}/.ssh",target=${HOME}/.ssh,readonly \
  --mount type=bind,source="${HOME}/.config/jgit",target=${HOME}/.config/jgit \
  # Mounts current folder into the container (Use `Get-Location` on PowerShell)
  --mount type=bind,source="$(pwd)",target=/usr/app \
  --interactive ${TTY} \
  --rm \
  registry.gitlab.com/chromaway/core-tools/chromia-cli/chr:${CHR_VERSION:-latest} chr "$@"

```

Let's kick things off by setting up your blockchain app project. Follow these steps:

1. Create a new project from the template using the Chromia CLI:

```codeBlockLines_e6Vv
chr create-rell-dapp order-system-example --template=plain

```

```codeBlockLines_e6Vv
cd order-system-example

```

2. Configure the ICMF library by adding the following to the newly generated `chromia.yml` file:

chromia.yml

```codeBlockLines_e6Vv
libs:
  icmf:
    registry: https://gitlab.com/chromaway/core/directory-chain
    path: src/messaging/icmf
    tagOrBranch: 1.29.0
    rid: x"19D6BC28D527E6D2239843608486A84F44EDCD244E253616F13D1C65893F35F6"

```

3. Run `chr install` to download the library. This will allow sending and receiving messages between different
blockchains.

4. Add the following definitions to the very beginning of the `chromia.yml` file that will make it easier for us to
configure the chains for messaging:


chromia.yml

```codeBlockLines_e6Vv
definitions:
  - &sender # Configuration for a chain that sends messages
    gtx:
      modules:
        - "net.postchain.d1.icmf.IcmfSenderGTXModule"
  - &receiver # Base configuration for a chain that receives messages
    gtx:
      modules:
        - "net.postchain.d1.icmf.IcmfReceiverGTXModule"
    sync_ext:
      - "net.postchain.d1.icmf.IcmfReceiverSynchronizationInfrastructureExtension"
  - &sender_receiver # Base configuration for a chain that will both send and receive messages
    gtx:
      modules:
        - "net.postchain.d1.icmf.IcmfSenderGTXModule"
        - "net.postchain.d1.icmf.IcmfReceiverGTXModule"
    sync_ext:
      - "net.postchain.d1.icmf.IcmfReceiverSynchronizationInfrastructureExtension"

```

Here we have defined an array containing three elements, each associated with an anchor: `&sender`, `&receiver`, and
`&sender_receiver`. Each of these anchors represents a specific configuration that a chain will adopt based on whether
it is intended to send messages, receive messages, or both.

Below you can find the project structure and also the contents of the `chromia.yml` configuration file after the
performed changes. It can be very useful for comparison:

Project structure

```codeBlockLines_e6Vv
order-system-example/
├── build/
├── src/
│   ├── lib/
│   ├── test/
│   └── main.rell
├── .gitignore
└── chromia.yml

```

Final version of the `chromia.yml` file

chromia.yml

```codeBlockLines_e6Vv
definitions:
  - &sender # Configuration for a chain that sends messages
    gtx:
      modules:
        - "net.postchain.d1.icmf.IcmfSenderGTXModule"
  - &receiver # Base configuration for a chain that receives messages
    gtx:
      modules:
        - "net.postchain.d1.icmf.IcmfReceiverGTXModule"
    sync_ext:
      - "net.postchain.d1.icmf.IcmfReceiverSynchronizationInfrastructureExtension"
  - &sender_receiver # Base configuration for a chain that will both send and receive messages
    gtx:
      modules:
        - "net.postchain.d1.icmf.IcmfSenderGTXModule"
        - "net.postchain.d1.icmf.IcmfReceiverGTXModule"
    sync_ext:
      - "net.postchain.d1.icmf.IcmfReceiverSynchronizationInfrastructureExtension"
blockchains:
  order-system-example:
    module: main
compile:
  rellVersion: 0.13.5
database:
  schema: schema_order_system_example
test:
  modules:
    - test
libs:
  icmf:
    registry: https://gitlab.com/chromaway/core/directory-chain
    path: src/messaging/icmf
    tagOrBranch: 1.29.0
    rid: x"19D6BC28D527E6D2239843608486A84F44EDCD244E253616F13D1C65893F35F6"

```

- [Install](#install)
- [Prerequisite](#prerequisite)
- [Installation](#installation)
- [Updating Chromia CLI](#updating-chromia-cli)
- [Docker](#docker)
  - [Start the Docker container with Chromia CLI pre-installed](#start-the-docker-container-with-chromia-cli-pre-installed)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

The final chain in our example is the factory chain. The chain should react to production orders emitted from the order
chain and should notify when an order is ready for shipment. These would likely be separate steps in a real-world case,
but we will simplify this in our example.

We can say a product is 'manufactured' by increasing its value and reemitting the message directly. The database model
consists of only a single entity. To encapsulate the logic for this new blockchain, we create a new module
`factory_chain` in the `src/factory_chain` directory with the following content:

src/factory\_chain/module.rell

```codeBlockLines_e6Vv
module;

import lib.icmf.{ send_message };
import lib.icmf.receiver.{ receive_icmf_message };
import messages.{ topic.*, msg };

```

Define the corresponding manufactured product entity in the `src/factory_chain/entities.rell` file:

src/factory\_chain/entities.rell

```codeBlockLines_e6Vv
entity manufactured_product {
    key id: integer;
    mutable quantity: integer;
}

```

Additionally, you need to add two queries to fetch the quantity of a manufactured product and the total number of
manufactured products to the `src/factory_chain/queries.rell` file.

src/factory\_chain/queries.rell

```codeBlockLines_e6Vv
query get_total_manufactured(id: integer) = manufactured_product @? { id }.quantity;

query get_total_manufactured_products() = manufactured_product @* {} ( $.to_struct() );

```

## Sending and receiving a message [​](\#sending-and-receiving-a-message "Direct link to Sending and receiving a message")

To send and receive messages in a single chain, we will apply what we have learned from previous sections in our
configuration. Open the `chromia.yml` file and insert the `factory_chain` property, along with its underlying
configuration details, into the `blockchains` section to create a new blockchain.

chromia.yml

```codeBlockLines_e6Vv
blockchains:
  # ↓↓↓ Add this code snippet ↓↓↓
  factory-chain:
    module: factory_chain
    config:
      <<: *sender_receiver
      icmf:
        receiver:
          local:
            - topic: "L_production"
              brid: null
  # ↑↑↑ Add this code snippet ↑↑↑

```

Insert the following code to the `functions.rell` file to handle our messages.

src/factory\_chain/functions.rell

```codeBlockLines_e6Vv
@extend(receive_icmf_message)
function (sender: byte_array, topic: text, body: gtv) {
    when (topic) {
        PRODUCTION_ORDER -> {
            val order = msg.production_details.from_gtv(body);
            for (product in order.products) manufacture_product(product);
            send_message(SHIPMENT_READY, msg.shipment_ready(order.order_id).to_gtv());
        }
        else -> require(false, "Message type %s not handled".format(topic));
    }
}

function manufacture_product(product: msg.product) {
    if (not exists(manufactured_product @? { .id == product.id})) {
        create manufactured_product( id = product.id, quantity = product.quantity);
    } else {
        update manufactured_product @ { .id == product.id } (quantity += product.quantity);
    }
}

```

## Testing [​](\#testing "Direct link to Testing")

To test the factory chain, we need to add new configuration details to the `chromia.yaml` file. Insert the `test`
property under the `factory_chain` section, along with other details.

chromia.yml

```codeBlockLines_e6Vv
blockchains:
  factory-chain:
    # ↓↓↓ Add this code snippet ↓↓↓
    test:
      modules:
        - test.factory_chain_test
    # ↑↑↑ Add this code snippet ↑↑↑

```

The test emits a message and the dapp responds to it by emitting an event. Create a new file `factory_chain_test.rell`
in the `src/test` directory and insert the following code:

src/test/factory\_chain\_test.rell

```codeBlockLines_e6Vv
@test module;

import factory_chain.{ manufactured_product };
import messages.{ msg, topic.* };
import lib.icmf.test.{ test_icmf_message };

function test_manufacture_order() {
    rell.test.tx().op(
            test_icmf_message(
                x"",
                PRODUCTION_ORDER,
                msg.production_details(
                    order_id = 1,
                    products = [msg.product(id = 2, quantity = 10)]
                )
                    .to_gtv()
            )
        )
        .run();
    assert_events(("icmf_message", (topic = SHIPMENT_READY, body = msg.shipment_ready(1).to_gtv()).to_gtv_pretty()));
    assert_equals(manufactured_product @ { .id == 2 }.quantity, 10);
}

```

Then run the `chr test` command to verify the test results.

```codeBlockLines_e6Vv
Running tests for chain: factory-chain
TEST: factory_chain_test:test_manufacture_order
OK: factory_chain_test:test_manufacture_order (0.688s)

------------------------------------------------------------
TEST RESULTS:

OK factory_chain_test:test_manufacture_order

SUMMARY: 0 FAILED / 1 PASSED / 1 TOTAL (0.688s)

***** OK *****

```

Now, you have successfully written a dapp that uses three separate blockchains. In the final section, we will wrap
things up by running the blockchains locally and testing the flow.

Below you can find the project structure and the contents of the `chromia.yml` configuration file after the changes have
been made. It can be handy for comparison at this stage of the course:

Project structure

```codeBlockLines_e6Vv
order-system-example/
├── build/
├── src/
│   ├── delivery_chain/
│   │   ├── entities.rell
│   │   ├── functions.rell
│   │   ├── module.rell
│   │   ├── operations.rell
│   │   └── queries.rell
│   ├── factory_chain/
│   │   ├── entities.rell
│   │   ├── functions.rell
│   │   ├── module.rell
│   │   └── queries.rell
│   ├── lib/
│   ├── order_chain/
│   │   ├── entities.rell
│   │   ├── functions.rell
│   │   ├── module.rell
│   │   ├── operations.rell
│   │   └── queries.rell
│   ├── test/
│   │   ├── delivery_chain_test.rell
│   │   ├── factory_chain_test.rell
│   │   └── order_chain_test.rell
│   └── messages.rell
├── .gitignore
└── chromia.yml

```

Final version of the `chromia.yml` file

chromia.yml

```codeBlockLines_e6Vv
definitions:
  - &sender # Configuration for a chain that sends messages
    gtx:
      modules:
        - "net.postchain.d1.icmf.IcmfSenderGTXModule"
  - &receiver # Base configuration for a chain that receives messages
    gtx:
      modules:
        - "net.postchain.d1.icmf.IcmfReceiverGTXModule"
    sync_ext:
      - "net.postchain.d1.icmf.IcmfReceiverSynchronizationInfrastructureExtension"
  - &sender_receiver # Base configuration for a chain that will both send and receive messages
    gtx:
      modules:
        - "net.postchain.d1.icmf.IcmfSenderGTXModule"
        - "net.postchain.d1.icmf.IcmfReceiverGTXModule"
    sync_ext:
      - "net.postchain.d1.icmf.IcmfReceiverSynchronizationInfrastructureExtension"
blockchains:
  order-chain:
    module: order_chain
    config:
      <<: *sender
    test:
      modules:
        - test.order_chain_test
  delivery-chain:
    module: delivery_chain
    config:
      <<: *receiver
      icmf:
        receiver:
          local:
            - topic: "L_delivery"
              brid: null
            - topic: "L_shipment_ready"
              brid: null
    test:
      modules:
        - test.delivery_chain_test
  factory-chain:
    module: factory_chain
    config:
      <<: *sender_receiver
      icmf:
        receiver:
          local:
            - topic: "L_production"
              brid: null
    test:
      modules:
        - test.factory_chain_test
compile:
  rellVersion: 0.13.5
database:
  schema: schema_order_system_example
libs:
  icmf:
    registry: https://gitlab.com/chromaway/core/directory-chain
    path: src/messaging/icmf
    tagOrBranch: 1.29.0
    rid: x"19D6BC28D527E6D2239843608486A84F44EDCD244E253616F13D1C65893F35F6"

```

- [Sending and receiving a message](#sending-and-receiving-a-message)
- [Testing](#testing)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Before we start, please make sure you have the following prerequisites in place:

Set up PostgreSQL database

Rell requires PostgreSQL 16.3. The IDE can work without it but can't run a node. A console or a remote postchain app can
run without a database.

The default database configuration for Rell is:

- database: `postchain`
- user: `postchain`
- password: `postchain`

## Install [​](\#install "Direct link to Install")

- Mac
- Linux
- Docker
- Windows

1. Install Homebrew: [Homebrew installation guide](https://brew.sh/)

2. Install PostgreSQL:





```codeBlockLines_e6Vv
brew install postgresql@16
brew services start postgresql@16
createuser -s postgres

```

3. Prepare the PostgreSQL database:





```codeBlockLines_e6Vv
psql -U postgres -c "CREATE DATABASE postchain WITH TEMPLATE = template0 LC_COLLATE = 'C.UTF-8' LC_CTYPE = 'C.UTF-8' ENCODING 'UTF-8';" -c "CREATE ROLE postchain LOGIN ENCRYPTED PASSWORD 'postchain'; GRANT ALL ON DATABASE postchain TO postchain;"

```











note





If you get an error saying peer authentication failed, you must change the authentication method from `peer` to
`md5`. You can change it in the `pg_hba.conf` file of your `psql` database.


1. Install PostgreSQL:





```codeBlockLines_e6Vv
sudo apt install postgresql-16

```

2. Prepare the PostgreSQL database:





```codeBlockLines_e6Vv
sudo -u postgres psql -c "CREATE DATABASE postchain WITH TEMPLATE = template0 LC_COLLATE = 'C.UTF-8' LC_CTYPE = 'C.UTF-8' ENCODING 'UTF-8';" -c "CREATE ROLE postchain LOGIN ENCRYPTED PASSWORD 'postchain'; GRANT ALL ON DATABASE postchain TO postchain;"

```


1. Install Docker: [Docker installation guide](https://docs.docker.com/engine/install/)

2. Prepare the PostgreSQL database:





```codeBlockLines_e6Vv
docker run --name postgres -e POSTGRES_USER=postchain -e POSTGRES_PASSWORD=postchain -p 5432:5432 -d postgres:16.3-alpine3.20

```











note





We use the Alpine version of PostgreSQL because it provides the correct collation settings by default. This can be
explicitly set using the environment variable:







```codeBlockLines_e6Vv
POSTGRES_INITDB_ARGS="--lc-collate=C.UTF-8 --lc-ctype=C.UTF-8 --encoding=UTF-8"

```


1. Download the PostgreSQL installer from the [official website](https://www.postgresql.org/download/windows/).

2. Install the executable and add the PostgreSQL folder containing the binaries to your environment variables. Open the
Command Prompt (CMD) and run the following command, ensuring that you set the path to your binaries correctly and
replace the `<version>` placeholder with the actual version number:





```codeBlockLines_e6Vv
setx POSTGRESQL "C:\Program Files\PostgreSQL\<version>\bin"

```

3. Reopen the Command Prompt (CMD) to update the environment variables. Prepare the PostgreSQL database by running the
following two commands sequentially:





```codeBlockLines_e6Vv
psql -U postgres -c "CREATE DATABASE postchain WITH TEMPLATE = template0 LC_COLLATE = 'en_US.UTF-8' LC_CTYPE = 'en_US.UTF-8' ENCODING 'UTF-8';"
psql -U postgres -c "CREATE ROLE postchain LOGIN ENCRYPTED PASSWORD 'postchain'; GRANT ALL ON DATABASE postchain TO postchain;"

```











note





Depending on your Windows version, you may encounter various errors related to permissions or incorrect PostgreSQL
installations. If this happens, we recommend installing Docker and deploying the PostgreSQL container.


Install Chromia CLI

This topic contains instructions to install and update the
[Chromia CLI](https://gitlab.com/chromaway/core-tools/chromia-cli).

## Prerequisite [​](\#prerequisite "Direct link to Prerequisite")

Before proceeding, make sure the following prerequisites are met:

- **PostgreSQL database**: See [Set up PostgreSQL database](/docs/install/database-setup).
- **RELL\_JAVA environment**: Chromia CLI do requries a java runtime (version 21 or later) to execute. Through the
different package managers this has been abstracted away for you so you don't need to set this up. If you want to
control which java runtime you use to execute Chromia CLI with it is recomended to set RELL\_JAVA variable in your
environment to point to a valid Java installation

## Installation [​](\#installation "Direct link to Installation")

You can install Chromia CLI using a package manager or by downloading it directly from
[Chromia CLI Packages](https://gitlab.com/chromaway/core-tools/chromia-cli/-/packages).

- macOS
- Linux/WSL
- Windows

To install Chromia CLI ( `chr`) on macOS, follow these steps:

1. If Homebrew is not installed, install it by running:





```codeBlockLines_e6Vv
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

```

2. Add the Chromia repository to Homebrew by running the following command:





```codeBlockLines_e6Vv
brew tap chromia/core https://gitlab.com/chromaway/core-tools/homebrew-chromia.git

```

3. Install Chromia CLI with:





```codeBlockLines_e6Vv
brew install chromia/core/chr

```











info





To install a specific version of Chromia CLI, use the following commands:







```codeBlockLines_e6Vv
brew install chromia/core/chr@<version>
brew unlink chr
brew link chr@<version>

```











You can list available versions using: `brew search chr`.

4. To verify the installation, check the version by running:





```codeBlockLines_e6Vv
chr --version

```


To install Chromia CLI ( `chr`) on Linux or WSL (Windows Subsystem for Linux), follow these steps:

1. Download and add Chromia's `apt-repo` public key to your system’s trusted keyrings:





```codeBlockLines_e6Vv
curl -fsSL https://apt.chromia.com/chromia.gpg | sudo tee /usr/share/keyrings/chromia.gpg

```

2. Add the Chromia repository to your list of package sources:





```codeBlockLines_e6Vv
echo "deb [arch=amd64 signed-by=/usr/share/keyrings/chromia.gpg] https://apt.chromia.com stable main" | sudo tee /etc/apt/sources.list.d/chromia.list

```

3. Run the following command to update your package sources:





```codeBlockLines_e6Vv
sudo apt-get update

```











info





If you added `apt.chromia.com` before Chromia CLI version `0.16.0`, run the following command to allow the repository
update:







```codeBlockLines_e6Vv
sudo apt-get --allow-releaseinfo-change update

```

4. Once the repository is updated, install Chromia CLI by running:





```codeBlockLines_e6Vv
sudo apt-get install chr

```

5. To verify that Chromia CLI is installed successfully, check the version:





```codeBlockLines_e6Vv
chr --version

```


To install Chromia CLI ( `chr`) on Windows using [Scoop](https://scoop.sh/), follow these steps:

1. If Scoop is not installed, install it by running the following command in PowerShell (run as Administrator):





```codeBlockLines_e6Vv
iwr -useb get.scoop.sh | iex

```

2. Add the Chromia repository (bucket) to Scoop by running:





```codeBlockLines_e6Vv
scoop bucket add chromia https://gitlab.com/chromaway/core-tools/scoop-chromia/

```

3. Add the Java bucket to Scoop by running:





```codeBlockLines_e6Vv
scoop bucket add java

```









This will enable scoop to download the openjdk21 which chromia-cli depends on when installing

4. Install Chromia CLI by running:





```codeBlockLines_e6Vv
scoop install chr

```

5. To verify that Chromia CLI is installed successfully, check the version:





```codeBlockLines_e6Vv
chr --version

```


## Updating Chromia CLI [​](\#updating-chromia-cli "Direct link to Updating Chromia CLI")

You can download and install the latest Chromia CLI from
[here](https://gitlab.com/chromaway/core-tools/chromia-cli/-/packages), or if you have installed the Chromia CLI via a
package manager, you can update it with the following:

- macOS
- Linux
- Windows

```codeBlockLines_e6Vv
brew update
brew upgrade chr

```

```codeBlockLines_e6Vv
sudo apt-get update
sudo apt-get install chr

```

```codeBlockLines_e6Vv
scoop update
scoop update chr

```

## Docker [​](\#docker "Direct link to Docker")

Docker can run a standalone Linux container with the Chromia CLI pre-installed. Make sure that you have set up the
[PostgreSQL database](/docs/install/database-setup).

To use the published Docker images, you must first have Docker installed and configured on your host machine. Please
refer to the Docker documentation on how to [install Docker](https://docs.docker.com/get-docker/) on Windows, Mac, and
Linux.

### Start the Docker container with Chromia CLI pre-installed [​](\#start-the-docker-container-with-chromia-cli-pre-installed "Direct link to Start the Docker container with Chromia CLI pre-installed")

To run the latest version of the Chromia CLI, use the `docker run` command and specify the CLI Docker image name and
`chr`.

```codeBlockLines_e6Vv
docker run --rm -v $(pwd):/usr/app registry.gitlab.com/chromaway/core-tools/chromia-cli/chr:<latest version> chr

```

note

Make sure to configure your `chromia.yml` file correctly:

- **Mac**: Use `host.docker.internal` for `database:host`.
- **Windows**: Set `database:host` to `172.17.0.1`.
- **Linux**: Use the `--network=host` argument in Docker commands.

These configurations are crucial to ensure connectivity between Chromia CLI and the PostgreSQL instance.

See the [Docker command line reference](https://docs.docker.com/engine/reference/commandline/docker/) for more
information on updating or uninstalling the Docker image.

```codeBlockLines_e6Vv
#!/bin/bash

# Allocate a pseudo-TTY one when run in interactive mode
if [ -t 0 ] && [ -t 1 ] ; then TTY="--tty"; else TTY=""; fi

docker run \
  # Sets the network to host to not need to change the database hostname (linux only)
  --network=host \
  # Set timezone based on system settings (linux only)
  -e TZ=$(cat /etc/timezone) \
  # Sets process ownership to current user
  --user $(id -u):$(id -g) \
  --mount type=bind,source="/etc/passwd",target=/etc/passwd,readonly \
  --mount type=bind,source="/etc/group",target=/etc/group,readonly \
  # Configures ssh-agent (only needed if chr install is called on non-public repositores)
  -e SSH_AUTH_SOCK=$SSH_AUTH_SOCK \
  --volume "$SSH_AUTH_SOCK:$SSH_AUTH_SOCK" \
  --mount type=bind,source="${HOME}/.ssh",target=${HOME}/.ssh,readonly \
  --mount type=bind,source="${HOME}/.config/jgit",target=${HOME}/.config/jgit \
  # Mounts current folder into the container (Use `Get-Location` on PowerShell)
  --mount type=bind,source="$(pwd)",target=/usr/app \
  --interactive ${TTY} \
  --rm \
  registry.gitlab.com/chromaway/core-tools/chromia-cli/chr:${CHR_VERSION:-latest} chr "$@"

```

Let's kick things off by setting up your blockchain app project. Follow these steps:

1. Create a new directory for your project and navigate to it in your terminal:

```codeBlockLines_e6Vv
chr create-rell-dapp digital-warehouse-example --template=plain

```

```codeBlockLines_e6Vv
cd digital-warehouse-example

```

2. Configure the ICCF library by adding the following configuration details to the `chromia.yml` file:

```codeBlockLines_e6Vv
libs:
  iccf:
    registry: https://gitlab.com/chromaway/core/directory-chain
    path: src/iccf
    tagOrBranch: 1.32.2
    rid: x"1D567580C717B91D2F188A4D786DB1D41501086B155A68303661D25364314A4D"

```

Run `chr install` to download the `iccf` library. This will allow us to confirm transactions.

Below you can find the project structure and also the contents of the `chromia.yml` configuration file after the
performed changes. It can be very useful for comparison:

Project structure

```codeBlockLines_e6Vv
digital-warehouse-example/
├── build/
├── src/
│   ├── lib/
│   ├── test/
│   ├── main.rell
├── .gitignore
└── chromia.yml

```

Final version of the `chromia.yml` file

chromia.yml

```codeBlockLines_e6Vv
blockchains:
  digital-warehouse-example:
    module: main
compile:
  rellVersion: 0.13.5
database:
  schema: schema_digital_warehouse_example
test:
  modules:
    - test
libs:
  iccf:
    registry: https://gitlab.com/chromaway/core/directory-chain
    path: src/iccf
    tagOrBranch: 1.32.2
    rid: x"1D567580C717B91D2F188A4D786DB1D41501086B155A68303661D25364314A4D"

```

- [Install](#install)
- [Prerequisite](#prerequisite)
- [Installation](#installation)
- [Updating Chromia CLI](#updating-chromia-cli)
- [Docker](#docker)
  - [Start the Docker container with Chromia CLI pre-installed](#start-the-docker-container-with-chromia-cli-pre-installed)[Skip to main content](#__docusaurus_skipToContent_fallback)

Let's create a test to ensure that everything works as expected. We will build our test step by step using the Rell test framework. Start by opening `rell_marketplace_test/blockchain_rell_marketplace_test.rell` and adding the following imports.

rell\_marketplace\_test/blockchain\_rell\_marketplace\_test.rell

```codeBlockLines_e6Vv
@test module;

import rell_marketplace.*;
import lib.ft4.test.utils.{ ft_auth_operation_for };
import lib.ft4.assets.{ get_asset_balance };
import lib.ft4.external.accounts.{ get_accounts_by_signer };

```

We also need to add a query to fetch last account and our NFTs to complete the test; this query will also be used later when we do testing using Chromia CLI.

rell\_marketplace/queries.rell

```codeBlockLines_e6Vv
query get_last_account() = account @ {} ( $, @omit @sort_desc .rowid ) limit 1;

query get_all_nfts() {
    return nft_card @* {} (
        nft_card_dto(
            strength = .strength,
            health = .health,
            owner_id = .nft.owner.id,
            nft_id = .nft.rowid
        )
    );
}

struct nft_card_dto {
    strength: integer;
    health: integer;
    owner_id: byte_array;
    nft_id: rowid;
}

```

Then we set up a test function named `test_list_and_buy_nft`, and we set up two test accounts and our `economy_account`.

rell\_marketplace\_test/blockchain\_rell\_marketplace\_test.rell

```codeBlockLines_e6Vv
function test_list_and_buy_nft() {
    val alice = rell.test.keypairs.alice;
    val trudy = rell.test.keypairs.trudy;
    val economy_account = rell.test.keypairs.frank;

    rell.test.tx()
        .op(create_user(alice.pub)).sign(alice)
        .run();

    val alice_account = get_last_account();

    rell.test.tx()
        .op(create_user(trudy.pub)).sign(trudy)
        .run();

    val trudy_account = get_last_account();
}

```

After Alice has bought a mystery card, we will add a test function to list it on the marketplace. We start by fetching the first (and only) card minted by our previous operation. Then, we call the `list_nft` operation and get Alice to sign it.

```codeBlockLines_e6Vv
    rell.test.tx()
        .op(ft_auth_operation_for(alice.pub))
        .op(buy_mystery_card()).sign(alice)
        .run();

    val nft = get_all_nfts()[0];
    rell.test.tx()
        .op(ft_auth_operation_for(alice.pub))
        .op(list_nft(nft.nft_id.to_integer(), 20))
        .sign(alice)
        .run();

```

After the card has been successfully listed, we can let Trudy buy it from the marketplace at a set price.

```codeBlockLines_e6Vv
    rell.test.tx()
        .op(ft_auth_operation_for(trudy.pub))
        .op(buy_nft(nft.nft_id.to_integer()))
        .sign(trudy)
        .run();

```

That's it. We can now verify that the result is as expected by checking the account balances and the current owner of the minted NFT.

```codeBlockLines_e6Vv
    val nft_after_trade = get_all_nfts()[0];

    assert_equals(get_asset_balance(alice_account, dapp_meta.asset), 920);
    assert_equals(get_asset_balance(trudy_account, dapp_meta.asset), 980);
    assert_equals(nft_after_trade.owner_id, trudy_account.id);

```

That completes our test, which we can run using the `chr test` command from the terminal. When the test runs successfully, we can be sure that our marketplace works as expected.

We will do a similar test in the next lesson using Chromia CLI.[Skip to main content](#__docusaurus_skipToContent_fallback)

Since blockchains run on multiple nodes, there is no clear way to determine when some code was executed. If we could access, for example, `System.currentTimeMillis()`, this would return different results on different nodes. Even if we sync the node's clocks, the primary node will always execute the code first, and then the validating nodes, but they may not execute the time simultaneously due to network delays and hardware speed.

This means that the only way to get a reliable time is to look at the _latest known time_, or the _previous block time_. Since a timestamp is added to each block as part of the block header, which becomes accepted by the validating nodes, this would be a suitable choice. To access this timestamp, we can query against the [system block entity](https://docs.chromia.com/rell/language-features/systemlib/system-entities).

```codeBlockLines_e6Vv
block @ {} (@max .timestamp);

```

However, during blockchain initialization, blocks are yet to be built and therefore this will return null. For example, when setting the value on an object, we must first initialize it with zero:

```codeBlockLines_e6Vv
object my_object {
    mutable timestamp = 0;
}

```

and then update it manually with an operation.

```codeBlockLines_e6Vv
operation set_time() {
    my_object.timestamp = block @ {} (@max .timestamp);
}

```

In the scope of an `operation`, there is a special context called `op_context`, which has a `last_block_time` property. This could be used to simplify the above expression. It may be tempting to use this as the default value for timestamps on entities, however, if the attribute was added to an entity that has data already, we must rely on the block query to get a proper timestamp on those entities:

```codeBlockLines_e6Vv
entity my_entity {
    timestamp = if (op_context.exists) op_context.last_block_time else block @ {} (@max .timestamp)!!;
}

```

This is because the default value will be set on all existing entities when the blockchain starts up again after the update, and thus the `op_context` will be null.

To make this less inconsistent, we can create a function `last_known_time()` which covers all cases:

```codeBlockLines_e6Vv
function last_known_time()
    = if (op_context.exists) op_context.last_block_time else block @ {} (@max .timestamp) ?: 0;

```

This function can safely be used in all scenarios:

```codeBlockLines_e6Vv
object my_object {
    timestamp = last_known_time();
}

entity my_entity {
    timestamp = last_known_time();
}

operation my_operation() {
    create my_entity();
}

query get_last_known_time() = last_known_time();

```[Skip to main content](#__docusaurus_skipToContent_fallback)

For our marketplace, we need a payment token, and a couple of accounts. In this module we will guide you through the process using the FT4 libray.

## Lessons

[Lesson 1 - Register payment token](/courses/marketplace-course/module-ft4/register-token)

[Lesson 2 - Create user accounts](/courses/marketplace-course/module-ft4/register-account)

[Start module »](/courses/marketplace-course/module-ft4/register-token)[Skip to main content](#__docusaurus_skipToContent_fallback)

The marketplace is taking shape, and we now have functions to list NFTs that are up for sale. So, the next step is to create an operation to complete a purchase.

rell\_marketplace/marketplace.rell

```codeBlockLines_e6Vv
operation buy_nft(id: integer) {
    val account = auth.authenticate();
    val (nft, owner, price) = listed_nft @ {
        .nft.rowid == rowid(id)
    } ( .nft, .listed_by, .price );
    Unsafe.transfer(account, owner, dapp_meta.asset, price);
    delete listed_nft @ { .nft.rowid == rowid(id) };
    nft.owner = account;
}

```

When a user calls `buy_nft`, we verify that the user is authenticated. Then, we fetch the NFT and confirm it's listed by querying `listed_nft`. Next, we transfer the amount specified by the price from the account buying the NFT to the owner who is selling it. Lastly, we delete the NFT from being listed on the marketplace and set the new owner of the NFT.

BuyerDappSellerBuyerDappSellerThe card is added to the listingPayment of 10 CRD is processedLists card for 10 CRDBuys the listed card for 10 CRDTransfers 10 CRD to the SellerTransfers card ownership to the Buyer

Our marketplace now supports the following:

1. A user can buy an NFT, which is then minted in our dapp.
2. NFTs can be listed on the marketplace at a set price.
3. Users can buy a listed NFT at the asked price.[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

We now have all the building blocks for our marketplace, so let's test them out using Chromia CLI. Chromia CLI is a command-line tool that allows interaction with the Chromia blockchain utilizing a set of commands. You can read more [about it here](https://docs.chromia.com/cli/introduction).

## Queries for verification [​](\#queries-for-verification "Direct link to Queries for verification")

To make data verification easier, we will add two helper queries to our app. They will help us fetch and verify accounts and account balances.

rell\_marketplace/module.rell

```codeBlockLines_e6Vv
import lib.ft4.assets.{ asset, Unsafe, balance };

```

rell\_marketplace/queries.rell

```codeBlockLines_e6Vv
query get_all_accounts()
{
    return account @* {} ($.to_struct());
}

query get_all_balances()
{
    return balance @* {} ($.account.to_struct(), $.to_struct());
}

```

## Begin testing [​](\#begin-testing "Direct link to Begin testing")

Now we can begin our testing, and we start our blockchain node by running:

### Create accounts [​](\#create-accounts "Direct link to Create accounts")

```codeBlockLines_e6Vv
chr node start

```

Open a new terminal, where we will start issuing commands using the CLI. First, we can make sure that the dapp account was created by querying the accounts.

```codeBlockLines_e6Vv
chr query get_all_accounts

```

* * *

Now, we can create two users, Alice and Bob.

```codeBlockLines_e6Vv
chr keygen --file .chromia/alice.keypair
chr keygen --file .chromia/bob.keypair

chr tx --await create_user "<alice pubkey>" --secret .chromia/alice.keypair
chr tx --await create_user "<bob pubkey>" --secret .chromia/bob.keypair

```

`chr tx` will send a transaction to call an operation on the blockchain.

We can now run a query to fetch the balances for all accounts. We want to confirm that our minting operation works correctly, so both Alice's and Bob's accounts should have 1000 CRDs.

```codeBlockLines_e6Vv
chr query get_all_balances

```

This will generate a result similar to this, which contains our two created accounts and their balance (1000 CRD) that we minted in `create_user`

```codeBlockLines_e6Vv
[\
    [[x"3A0153952DCB30A904B1E3461321892C916B10E51897F32B3352DB65DDDA4562"], [7, 1, 1000L]],\
    [[x"8EF62426BA321FB23D6163DCFBFC53049E9A078500264F012BC4E4AB5048A859"], [13, 1, 1000L]]\
]

```

### Buy a mystery card [​](\#buy-a-mystery-card "Direct link to Buy a mystery card")

Now that we have verified that the balances are okay, we can let Alice buy a mystery card.

```codeBlockLines_e6Vv
chr tx --await buy_mystery_card --ft-auth --ft-account-id=<first id from get_all_balances query> --secret .chromia/alice.keypair

```

We can now have a look at the currently listed `nft_cards` and also check the balances to make sure the transaction has been completed.

```codeBlockLines_e6Vv
chr query get_all_nfts

```

It should result in something similar to this, showing a card NFT with its properties.

```codeBlockLines_e6Vv
[["health": 10, "nft_id": 22, "owner_id": x"<owner id>", "strength": 8]]

```

Checking the balance by using the following query

```codeBlockLines_e6Vv
chr query get_all_balances

```

will result in the following balances for Alice, Bob, and the Economy Account.

| Participant | Action | Amount | Balance |
| --- | --- | --- | --- |
| Alice | Bought a mystery card | -100 CRD | 900 CRD |
| Bob | No action |  | 1000 CRD |
| Economy Account | Received from Alice | +100 CRD | 100 CRD |

```codeBlockLines_e6Vv
[\
    [[x"3A0153952DCB30A904B1E3461321892C916B10E51897F32B3352DB65DDDA4562"], [7, 1, 900L]],  // Alice\
    [[x"8EF62426BA321FB23D6163DCFBFC53049E9A078500264F012BC4E4AB5048A859"], [13, 1, 1000L]],  // Bob\
    [[x"522546AF72636ABA2AFE34E1BF2D7BF2B9C0A483C20F87E145BE32992339962C"], [2, 1, 100L]] // Economy account\
]

```

### List cards on the marketplace [​](\#list-cards-on-the-marketplace "Direct link to List cards on the marketplace")

We let Alice list her card on the marketplace for 25 CRD. We can get the `nft_id` from our previous query `get_all_nfts` and the FT4 account id for Alice from `get_all_balances`

```codeBlockLines_e6Vv
chr tx --await list_nft "<nft_id from query>" "25L" --secret .chromia/alice.keypair --ft-auth --ft-account-id=<FT4 account from query>

```

and then we query using `get_cards` and pass arguments for filtering and sorting

```codeBlockLines_e6Vv
chr query get_cards "amount=10" "card_sorting=PRICE_HIGH"

```

This should generate a single result with the card Alice listed on the marketplace.

### Buy a card from the marketplace [​](\#buy-a-card-from-the-marketplace "Direct link to Buy a card from the marketplace")

Now, we will let Bob buy Alice's card by calling the `buy_card` operation

```codeBlockLines_e6Vv
chr tx --await buy_nft "<nft id>" --secret .chromia/bob.keypair --ft-auth --ft-account-id=<Bobs FT4 account id from get_all_balances>

```

followed by query.

```codeBlockLines_e6Vv
chr query get_all_balances

```

This will generate our final balances, which should look like this

| Participant | Action | Balance |
| --- | --- | --- |
| Alice | Bought a mystery card for 10 CRD<br>Received 25 CRD from Bob | 925 CRD |
| Bob | Bought Alice's card for 25 CRD | 975 CRD |
| Economy Account | Received fee of 100 CRD from Alice | 100 CRD |

and from our query.

```codeBlockLines_e6Vv
[\
    [[x"3A0153952DCB30A904B1E3461321892C916B10E51897F32B3352DB65DDDA4562"], [7, 1, 925L]],  // Alice\
    [[x"8EF62426BA321FB23D6163DCFBFC53049E9A078500264F012BC4E4AB5048A859"], [13, 1, 975L]],  // Bob\
    [[x"522546AF72636ABA2AFE34E1BF2D7BF2B9C0A483C20F87E145BE32992339962C"], [2, 1, 100L]]     // Economy account\
]

```

This concludes our testing using Chromia CLI and also ends this course. We hope that you enjoyed it, and happy coding!

- [Queries for verification](#queries-for-verification)
- [Begin testing](#begin-testing)
  - [Create accounts](#create-accounts)
  - [Buy a mystery card](#buy-a-mystery-card)
  - [List cards on the marketplace](#list-cards-on-the-marketplace)
  - [Buy a card from the marketplace](#buy-a-card-from-the-marketplace)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

The digital warehouse chain tracks inventory for a specific warehouse. Users are authenticated by presenting proof of
payment on the Subscription Chain, granting them unrestricted system access until their subscription expires.

Next, create a directory named `digital_warehouse_chain`. Within this directory, create a file named `module.rell` and
insert the following definition:

src/digital\_warehouse\_chain/module.rell

```codeBlockLines_e6Vv
module;

```

Add the user account entity to the `entities.rell` that includes an expiration date for the subscription:

src/digital\_warehouse\_chain/entities.rell

```codeBlockLines_e6Vv
entity warehouse_account {
    key id: pubkey;
    mutable valid_until: timestamp = op_context.last_block_time;
}

```

## Inventory model [​](\#inventory-model "Direct link to Inventory model")

The inventory is modeled using a single entity that monitors the stock level of a specific product ID.
We also add a logged entity, `inventory_log,` to track any changes in the inventory.
Add the following code to the `entities.rell` file:

src/digital\_warehouse\_chain/entities.rell

```codeBlockLines_e6Vv
entity inventory {
    key product_category: integer;
    UNIT;
    mutable stock: integer = 0;
}

enum UNIT {
    LITRE, PIECE, KILOGRAM
}

@log entity inventory_log {
    // We don't reference the inventory entity here since this entity may be removed
    product_category: integer;
    amount: integer;
    comment: text;
}

struct inventory_dto {
    product_category: integer;
    amount: integer;
    comment: text;
}

```

Next, we must enable users to register a new product category and update inventory.

The `update_inventory` operation is responsible for updating the current inventory stock and logging
the details of how and why the change occurred. `inventory_dto` represents a structure used to gather information
about the inventory change.

Add the following code to the `operations.rell` file stored in the `src/digital_warehouse_chain`:

src/digital\_warehouse\_chain/operations.rell

```codeBlockLines_e6Vv
operation register_product_category(category: integer, UNIT) {
    require_authenticated_signer();
    create inventory(product_category = category, UNIT);
}

operation update_inventory(inventory_dto) {
    require_authenticated_signer();
    update inventory @ { .product_category == inventory_dto.product_category } (stock += inventory_dto.amount);
    create inventory_log(
        product_category = inventory_dto.product_category,
        amount = inventory_dto.amount,
        comment = inventory_dto.comment
        );
}

```

Additionally, we need to add a function to the `functions.rell` file stored in the `src/digital_warehouse_chain` directory.

The function `require_authenticated` ensures that a user exists, has signed the transaction, and possesses a valid
subscription:

src/digital\_warehouse\_chain/functions.rell

```codeBlockLines_e6Vv
function require_authenticated_signer() {
    require(op_context.get_signers().size() == 1, "Require exactly one signature");
    val valid_until = warehouse_account @? { op_context.get_signers()[0]}.valid_until;
    require(exists(valid_until), "No account found");
    require(op_context.last_block_time <= valid_until!!, "Subscription has expired");
}

```

## Authentication [​](\#authentication "Direct link to Authentication")

Authentication of a user is handled through ICCF. To enable this, we configure our Digital Warehouse Chain to
utilize ICCF by adding the following configuration to the `chromia.yml` file:

chromia.yml

```codeBlockLines_e6Vv
blockchains:
  # ↓↓↓ Add this code snippet ↓↓↓
  digital-warehouse-chain:
    module: digital_warehouse_chain
    config:
      gtx:
        modules:
          - net.postchain.d1.iccf.IccfGTXModule
# ↑↑↑ Add this code snippet ↑↑↑

```

Then you have to import the ICCF module by adding the following to the `module.rell` file:

src/digital\_warehouse\_chain/module.rell

```codeBlockLines_e6Vv
import lib.iccf;
import subscription_chain.{ subscription, period, period_to_millis };

```

Define the `authorize` operation that takes a `gtx_transaction` containing transaction information to confirm with ICCF. It ensures uniqueness by storing a transaction hash before verifying and extracting the operation arguments. The first argument of the transaction should include the blockchain RID where the payment was made, and the second argument
should contain the subscription metadata. We verify the correctness of the blockchain RID and decode the subscription metadata.

The operation must be defined in the `operations.rell` file, which is stored in the `src/digital_warehouse_chain` directory:

src/digital\_warehouse\_chain/operations.rell

```codeBlockLines_e6Vv
operation authorize(tx: gtx_transaction) {
    iccf.make_transaction_unique(tx);
    val args = iccf.extract_operation_args(tx, "subscribe", verify_signers = true);
    require(byte_array.from_gtv(args[0]) == chain_context.blockchain_rid, "Wrong blockchain proof, found %s".format(chain_context.blockchain_rid));
    val subscription = subscription.from_gtv(args[1]);
    val warehouse_account = get_or_create_account(subscription.account_id);
    val new_expiration_date = max(op_context.last_block_time, warehouse_account.valid_until) + period_to_millis(subscription.period);
    warehouse_account.valid_until = new_expiration_date;
}

```

Finally, we retrieve or create a new account and extend its expiration date by adding the subscription period.
This approach ensures that regardless of when a subscription is purchased, the period will be added to the existing
expiration date.

Add the following block of code to the `functions.rell` file stored in the `src/digital_warehouse_chain` directory:

src/digital\_warehouse\_chain/functions.rell

```codeBlockLines_e6Vv
function get_or_create_account(id: pubkey) {
    require(op_context.is_signer(id));
    return warehouse_account @? { id } ?: create warehouse_account(id);
}

```

## Creating a report [​](\#creating-a-report "Direct link to Creating a report")

Finally, we define a query to create a report and history log of all inventory updates that have occurred.
Since this smart contract represents only a single warehouse, we include a module argument containing
information about the warehouse to be included in the report.

Add the following struct to the `entities.rell` file stored in the `src/digital_warehouse_chain` directory:

src/digital\_warehouse\_chain/entities.rell

```codeBlockLines_e6Vv
struct module_args {
    warehouse_id: integer;
}

```

Next, place the `create_report` query within the `queries.rell` file located in the `src/digital_warehouse_chain` directory;

src/digital\_warehouse\_chain/queries.rell

```codeBlockLines_e6Vv
query create_report(from: timestamp?, to: timestamp?) {
    val current_inventory = inventory @* {} ($.to_struct());

    val history = inventory_log @* {
        if (from??).transaction.block.timestamp >= from else true,
        if (to??).transaction.block.timestamp < to else true,
        .product_category in current_inventory @* {}( .product_category )
        }(
        $.to_struct()
    );

    return (warehouse_id = chain_context.args.warehouse_id, inventory = current_inventory, history = group_logs_by_product(history));
}

```

Additionally, include the `group_logs_by_product` function in the `functions.rell` file located
in the `src/digital_warehouse_chain` folder.

The query collects the current inventory and historical updates, combining them into a tuple along with the warehouse ID:

src/digital\_warehouse\_chain/functions.rell

```codeBlockLines_e6Vv
function group_logs_by_product(value: list<(struct<inventory_log>)>) {
    val result = map<integer, list<struct<inventory_log>>>();
    for (v in value) {
        if (v.product_category not in result) result[v.product_category] = [];
        result[v.product_category].add(v);
    }
    return result;
}

```

Configure the warehouse ID by adding new configuration details ( `moduleArgs`) in the `chromia.yml` file:

chromia.yml

```codeBlockLines_e6Vv
blockchains:
  digital-warehouse-chain:
    # ↓↓↓ Add this code snippet ↓↓↓
    moduleArgs:
      digital_warehouse_chain:
        warehouse_id: 1
    # ↑↑↑ Add this code snippet ↑↑↑

```

tip

Creating multiple warehouses is straightforward; simply define several blockchains in the `chromia.yml` file,
each with its own set of module arguments.

chromia.yml

```codeBlockLines_e6Vv
blockchains:
  digital-warehouse-chain-1:
    module: digital_warehouse_chain
    ...
    moduleArgs:
      digital_warehouse_chain:
        warehouse_id: 1
  digital-warehouse-chain-2:
    module: digital_warehouse_chain
    ...
    moduleArgs:
      digital_warehouse_chain:
        warehouse_id: 2

```

## Unit tests [​](\#unit-tests "Direct link to Unit tests")

To initiate testing for this app, we need to create a new file named `src/digital_warehouse_chain_test.rell`,
where the code for the test will be stored:

src/test/digital\_warehouse\_chain\_test.rell

```codeBlockLines_e6Vv
@test module;

import digital_warehouse_chain.{ subscription, period, authorize, warehouse_account, period_to_millis, register_product_category, update_inventory, inventory_dto, create_report, UNIT };

function test_grant_access() {
    val certificate = subscription(
        account_id = rell.test.pubkeys.alice,
        period = period.WEEK
    );
    val tx = rell.test.tx();
    val gtx = gtx_transaction(
        body = gtx_transaction_body(
            blockchain_rid = x"AB",
            operations = [gtx_operation(name = "subscribe", args = [chain_context.blockchain_rid.to_gtv(), certificate.to_gtv()])],
            signers = [rell.test.pubkeys.alice.to_gtv()]
        ),
        signatures = []
    );

    rell.test.set_next_block_time(1);
    rell.test.block().run();
    rell.test.tx()
        .op(gtx_operation(name = "iccf_proof", args = [x"AB".to_gtv(), gtx.hash().to_gtv(), x"".to_gtv()]).to_test_op())
        .op(authorize(gtx))
        .sign(rell.test.keypairs.alice)
        .run();

    val warehouse_account = warehouse_account @? { rell.test.pubkeys.alice };
    assert_not_null(warehouse_account);
    assert_equals(warehouse_account.valid_until, 1 + period_to_millis(period.WEEK));

    rell.test.tx()
        .op(register_product_category(101, UNIT.LITRE))
        .op(update_inventory(inventory_dto(product_category = 101, amount = 5000, "Received milk shipment from barn")))
        .sign(rell.test.keypairs.alice)
        .run();

    val report = create_report(null, null);
    assert_equals(report.warehouse_id, 1);
    assert_equals(report.inventory[0].stock, 5000);
    assert_equals(report.history[101].size(), 1);
    assert_equals(report.history[101][0].comment, "Received milk shipment from barn");
}

```

Next, add the `test` definition along with its corresponding details to the `chromia.yml` file:

chromia.yml

```codeBlockLines_e6Vv
blockchains:
  digital-warehouse-chain:
    # ↓↓↓ Add this code snippet ↓↓↓
    test:
      modules:
        - test.digital_warehouse_chain_test
    # ↑↑↑ Add this code snippet ↑↑↑

```

This test creates a dummy `gtx_transaction` for the `alice` pubkey. It then forcefully sets the next block time to 1 and
executes an empty block before invoking the `authorize` operation. This step ensures that we obtain accurate block time
values when verifying the results.

In the final transaction executed, we include a `gtx_operation` that invokes `iccf_proof` with placeholder values,
except for `gtx.hash().to_gtv()`. This approach accommodates the test framework's limitation of not directly verifying
proofs; therefore, constructing the transaction and passing the correct transaction hash. We verify the successful
creation of the account, log an inventory update, and validate the generated report.

The tests are executed using the `chr test` command.

Below you can find the project structure and the contents of the `chromia.yml` configuration file after the changes have been made.
It can be very useful for comparison at this stage of the course:

Project structure

```codeBlockLines_e6Vv
digital-warehouse-example/
├── build/
├── src/
│   ├── digital_warehouse_chain/
│   │   ├── entities.rell
│   │   ├── functions.rell
│   │   ├── module.rell
│   │   ├── operations.rell
│   │   └── queries.rell
│   ├── lib/
│   ├── subscription_chain/
│   │   ├── entities.rell
│   │   ├── functions.rell
│   │   ├── module.rell
│   │   ├── operations.rell
│   │   └── queries.rell
│   ├── test/
│   │   ├── subscription_chain_test.rell
│   │   └── digital_warehouse_chain_test.rell
│   └── main.rell
├── .gitignore
└── chromia.yml

```

Final version of the `chromia.yml`

chromia.yml

```codeBlockLines_e6Vv
blockchains:
  subscription-chain:
    module: subscription_chain
    test:
      modules:
        - test.subscription_chain_test
  digital-warehouse-chain:
    module: digital_warehouse_chain
    config:
      gtx:
        modules:
          - net.postchain.d1.iccf.IccfGTXModule
    moduleArgs:
      digital_warehouse_chain:
        warehouse_id: 1
    test:
      modules:
        - test.digital_warehouse_chain_test
compile:
  rellVersion: 0.13.5
database:
  schema: schema_digital_warehouse_example
libs:
  iccf:
    registry: https://gitlab.com/chromaway/core/directory-chain
    path: src/iccf
    tagOrBranch: 1.32.2
    rid: x"1D567580C717B91D2F188A4D786DB1D41501086B155A68303661D25364314A4D"

```

- [Inventory model](#inventory-model)
- [Authentication](#authentication)
- [Creating a report](#creating-a-report)
- [Unit tests](#unit-tests)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

The order chain will contain the logic for buying an item, similar to e-commerce. The chain will then automatically send
a message to the factory and delivery chains that a new order has been completed.

## Configuration [​](\#configuration "Direct link to Configuration")

We start by configuring the order chain to use the `&sender` part that we defined earlier. Open the `chromia.yml` and
add the following to the `blockchains` property:

chromia.yml

```codeBlockLines_e6Vv
blockchains:
  order-chain:
    module: order_chain
    config:
      <<: *sender

```

This should be enough to enable the infrastructure needed for the dapp to emit messages.

## Database Model [​](\#database-model "Direct link to Database Model")

Let’s create a new directory named `order_chain`. Inside this directory, create a file called `module.rell`. This file
represents the module definition and must have the following content:

src/order\_chain/module.rell

```codeBlockLines_e6Vv
module;

```

We want to track which orders have been processed and their contents. Create a new file called `entities.rell` in the
`src/order_chain` directory, and add the following code:

- Rell
- Entity Relation

src/order\_chain/entities.rell

```codeBlockLines_e6Vv
entity order {
    key tx: byte_array = op_context.transaction.tx_rid;
    index customer_id: integer;
    address: text;
}

entity product {
    id: integer;
}

entity product_order {
    key order, product;
    quantity: integer;
}

```

ORDERintegeridPKintegercustomer\_idtextaddressbyte\_arraytxUKPRODUCTintegeridPKPRODUCT-ORDERintegerquantityhasincluded in

In the code, we model a many-to-many relationship between an order and a product by the `product_order` entity that
contains the quantity ordered of that product. Let's also add a few queries to the `queries.rell` file to be able to
read the data from a client:

src/order\_chain/queries.rell

```codeBlockLines_e6Vv
query list_orders() {
    val ordered_products = product_order @* {} (.order.rowid.to_integer(), (product_id = .product.id, quantity = .quantity));
    return group_products_by_id(ordered_products);
}

query get_order_id(tx: byte_array) = order @? { tx }.rowid;

query get_order_details(id: integer)
    = product_order @* { .order.rowid == rowid(id) } ( order_id = .order.rowid, product_id = .product.id, quantity = .quantity );

query get_order_details_by_tx(tx: byte_array) = get_order_details(require(get_order_id(tx)?.to_integer()));

```

Create a new file named `functions.rell` in the `src/order_chain` directory. It will store the helper functions
presented below:

src/order\_chain/functions.rell

```codeBlockLines_e6Vv
function group_products_by_id(value: list<(integer, (product_id:integer, quantity:integer))>) {
    val result = map<integer, list<(product_id:integer, quantity:integer)>>();
    for ((k, v) in value) {
        if (k not in result) result[k] = list<(product_id:integer, quantity:integer)>();
        result[k].add(v);
    }
    return result @* {} (order_id = $[0], details = $[1]);
}

```

We also need a simple way to add products to our catalog. Create a new file called `operations.rell` in the
`src/order_chain` directory and insert the following code:

src/order\_chain/operations.rell

```codeBlockLines_e6Vv
operation register_product(id: integer) {
    create product ( id );
}

```

## Sending a message [​](\#sending-a-message "Direct link to Sending a message")

Now, we are ready to create a customer order and notify other chains that this event has happened. We do this by
importing the message types and messaging utilities to the `src/order_chain/module.rell` file:

src/order\_chain/module.rell

```codeBlockLines_e6Vv
module;

import messages.{ msg, topic };
import lib.icmf.{ send_message };

```

Next, we have to define an operation that the customer can call to make an order. Add the following code to the
`src/order_chain/operations.rell` file:

src/order\_chain/operations.rell

```codeBlockLines_e6Vv
operation make_customer_order(details: msg.order_details) {
    val order = create order (
        customer_id = details.customer_id,
        address = details.address
    );
    val product_to_ids = product @* { .id in details.products @* { }.id }( $, .id );

    val ordered_products = list<struct<product_order>>();
    for ((p, id) in product_to_ids) {
        ordered_products.add(
        struct<product_order>(
            order = order,
            product = p,
            quantity = details.products @ { .id == id }.quantity
        )
        );
    }

    create product_order ( ordered_products );

    val order_id = order.rowid.to_integer();
    send_production_order(order_id, details.products);
    send_new_delivery(order_id, details.customer_id, details.address);
}

```

Also, add the following functions to the `src/order_chain/functions.rell` file. These functions allow sending an order
to production and also initiate the delivery.

src/order\_chain/functions.rell

```codeBlockLines_e6Vv
function send_production_order(order_id: integer, products: list<msg.product>) {
    send_message(
        topic.PRODUCTION_ORDER,
        msg.production_details(order_id, products).to_gtv()
    );
}

function send_new_delivery(order_id: integer, customer_id: integer, shipping_address: text) {
    send_message(
        topic.NEW_DELIVERY,
        msg.delivery_details(order_id, customer_id, shipping_address).to_gtv()
    );
}

```

The operation takes a struct containing order details as input. It then creates the `order` and `product_order` entities
before sending the production order and new delivery message. We wrap the calls to
`send_message(topic: text, body: gtv)` to make the code more readable.

## Testing [​](\#testing "Direct link to Testing")

Let's configure a new test module for the order chain by adding the following to the `blockchains:order-chain` part in
the `chromia.yml`.

chromia.yml

```codeBlockLines_e6Vv
blockchains:
  order-chain:
    # ↓↓↓ Add this code snippet ↓↓↓
    test:
      modules:
        - test.order_chain_test
    # ↑↑↑ Add this code snippet ↑↑↑

```

Ceate a new file `order_chain_test.rell` in the `src/test` directory and add the following code:

src/test/order\_chain\_test.rell

```codeBlockLines_e6Vv
@test module;

import order_chain.{ register_product, make_customer_order, order };
import messages.{ msg, topic };

function test_make_order() {
    val test_order = msg.order_details(0, "MyStreet 12", [msg.product(id = 12, quantity = 110)]);

    rell.test.tx().op(register_product(12)).run();
    rell.test.tx().op(make_customer_order(test_order)).run();
    val order_id = order @ { } ( .rowid.to_integer() );
    assert_events(
        (
        "icmf_message",
        (topic = topic.PRODUCTION_ORDER,
        body = msg.production_details(order_id, test_order.products).to_gtv())
            .to_gtv_pretty()),
        ("icmf_message",
        (topic = topic.NEW_DELIVERY,
        body = msg.delivery_details(order_id, customer_id = test_order.customer_id, test_order.address).to_gtv())
            .to_gtv_pretty())
    );
}

```

In the test, we register a product, create a new customer order, and assert that the events have been created correctly.
It should now be possible to run the tests and get the following output:

```codeBlockLines_e6Vv
chr test

```

Result

```codeBlockLines_e6Vv
Running tests for chain: order-chain
TEST: order_chain_test:test_make_order
OK: order_chain_test:test_make_order (0,628s)

------------------------------------------------------------
TEST RESULTS:

OK order_chain_test:test_make_order

SUMMARY: 0 FAILED / 1 PASSED / 1 TOTAL (0,628s)

```

Below are the project structure and the contents of the `chromia.yml` configuration file after the changes have been
made. It can be handy for comparison at this stage of the course:

Project structure

```codeBlockLines_e6Vv
order-system-example/
├── build/
├── src/
│   ├── lib/
│   ├── order_chain/
│   │   ├── entities.rell
│   │   ├── functions.rell
│   │   ├── module.rell
│   │   ├── operations.rell
│   │   └── queries.rell
│   ├── test/
│   │   └── order_chain_test.rell
│   └── messages.rell
├── .gitignore
└── chromia.yml

```

Final version of the `chromia.yml` file

chromia.yml

```codeBlockLines_e6Vv
definitions:
  - &sender # Configuration for a chain that sends messages
    gtx:
      modules:
        - "net.postchain.d1.icmf.IcmfSenderGTXModule"
  - &receiver # Base configuration for a chain that receives messages
    gtx:
      modules:
        - "net.postchain.d1.icmf.IcmfReceiverGTXModule"
    sync_ext:
      - "net.postchain.d1.icmf.IcmfReceiverSynchronizationInfrastructureExtension"
  - &sender_receiver # Base configuration for a chain that will both send and receive messages
    gtx:
      modules:
        - "net.postchain.d1.icmf.IcmfSenderGTXModule"
        - "net.postchain.d1.icmf.IcmfReceiverGTXModule"
    sync_ext:
      - "net.postchain.d1.icmf.IcmfReceiverSynchronizationInfrastructureExtension"
blockchains:
  order-chain:
    module: order_chain
    config:
      <<: *sender
    test:
      modules:
        - test.order_chain_test
compile:
  rellVersion: 0.13.5
database:
  schema: schema_order_system_example
libs:
  icmf:
    registry: https://gitlab.com/chromaway/core/directory-chain
    path: src/messaging/icmf
    tagOrBranch: 1.29.0
    rid: x"19D6BC28D527E6D2239843608486A84F44EDCD244E253616F13D1C65893F35F6"

```

- [Configuration](#configuration)
- [Database Model](#database-model)
- [Sending a message](#sending-a-message)
- [Testing](#testing)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

This section covers the basics of working with queries in Chromia blockchain development. Queries are used to fetch data
from the blockchain. We'll guide you through the process, showing you how to create and test them.

## Define the query [​](\#define-the-query "Direct link to Define the query")

Open the file `src/main/queries.rell` and add the following Rell code:

src/main/queries.rell

```codeBlockLines_e6Vv
query get_all_books() {
  return book @* { } (
    .isbn,
    .title,
    .author
  );
}

```

### Breakdown of the query [​](\#breakdown-of-the-query "Direct link to Breakdown of the query")

- **`query` keyword:** Defines a new query. This works similarly to a `SELECT` statement in SQL, allowing you to
retrieve data from the blockchain.
- **`@*` operand:** In `book @*`, we expect 0 or more objects of the `book` type from the query.
- **Filter criteria:** The curly braces `{}` allow you to specify conditions for the query, but here we keep it simple
and fetch all entries.
- **Attributes:** After the curly braces, we specify which attributes to retrieve: `.isbn`, `.title`, and `.author`.

This query retrieves all books in a collection, with each item including the attributes `isbn`, `title`, and `author`.

## Update the unit tests [​](\#update-the-unit-tests "Direct link to Update the unit tests")

To ensure our query works correctly, we need to update the tests.

### Step 1: Update imports [​](\#step-1-update-imports "Direct link to Step 1: Update imports")

Open the file `src/test/book_review_test.rell` and update the import statement as follows:

src/test/book\_review\_test.rell

```codeBlockLines_e6Vv
import main.{ book, create_book, get_all_books };

```

### Step 2: Add the new test function [​](\#step-2-add-the-new-test-function "Direct link to Step 2: Add the new test function")

Next, add the following test function to the same file:

src/test/book\_review\_test.rell

```codeBlockLines_e6Vv
function test_get_books() {
    rell.test.tx()
        .op(create_book("123", "Book1", "Author1"))
        .op(create_book("124", "Book2", "Author2"))
        .run();

    val books = get_all_books();
    assert_equals(books.size(), 2);
}

```

### Breakdown of the test [​](\#breakdown-of-the-test "Direct link to Breakdown of the test")

- **Transaction creation:** `rell.test.tx()` creates a test transaction.
- **Adding operations:** Two `create_book` operations are added to the transaction.
- **Execution:** `run()` executes the transaction.
- **Query and assertions:** The `get_all_books()` function retrieves the books. We then assert that the number of
retrieved books is 2.

To run the tests, ensure you are in your project folder and enter the following command in your terminal:

```codeBlockLines_e6Vv
chr test

```

## Test on a local Chromia node [​](\#test-on-a-local-chromia-node "Direct link to Test on a local Chromia node")

To validate our query on a local Chromia node, follow these steps:

1. **Update or start the local Chromia node**:


   - **If the node is already running**, use the following command to update it:





     ```codeBlockLines_e6Vv
     chr node update

     ```

   - **If the node is not already running**, start it with:





     ```codeBlockLines_e6Vv
     chr node start

     ```


note

After running `chr node update`, the update might take a moment to be reflected. You may need to wait for the
following block to be processed before the query becomes available.

2. **Run the query**: In a new terminal window or tab, execute the following command:





```codeBlockLines_e6Vv
chr query get_all_books

```









You should see the results, including any books you previously inserted, like the one you added with the
`create_book` operation. For instance, if you followed the earlier steps, you should see an output similar to the
following:





```codeBlockLines_e6Vv
[\
     {\
       "author": "George Orwell",\
       "isbn": "ISBN1234",\
       "title": "1984"\
     }\
]

```









This confirms that the query correctly retrieves the stored book from the blockchain.


Congratulations! You have successfully stored entities on your test node blockchain and created a query to retrieve a
collection of all books.

- [Define the query](#define-the-query)
  - [Breakdown of the query](#breakdown-of-the-query)
- [Update the unit tests](#update-the-unit-tests)
  - [Step 1: Update imports](#step-1-update-imports)
  - [Step 2: Add the new test function](#step-2-add-the-new-test-function)
  - [Breakdown of the test](#breakdown-of-the-test)
- [Test on a local Chromia node](#test-on-a-local-chromia-node)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

Let's start with a quick overview of Cosmos, and then we will continue with comparing Cosmos to Chromia
and also discuss the benefits and challenges of the two solutions.

## Cosmos [​](\#cosmos-1 "Direct link to Cosmos")

**Tech and Architecture**

- Cosmos is structured as a **network of independent blockchains**, each called a zone, which is connected through the Cosmos Hub.
- It employs a **Proof-of-Stake (PoS)** consensus mechanism called Tendermint, where validators are chosen based on the amount of stake they hold.
- Notable for its **Inter-Blockchain Communication (IBC) protocol**, allowing different blockchains to transfer tokens and other data among one another seamlessly.

**Scalability**

- Cosmos scalability comes from its modular architecture using Hubs and Zones, allowing each zone to operate independently and process transactions concurrently with other zones.
- This structure enables the network to handle a higher volume of transactions compared to a single-chain blockchain.

**Development Tools**

- Cosmos offers the **Cosmos SDK**, a framework that simplifies blockchain development. It allows developers to build blockchains using pre-built modules or create their own.
- Primarily supports the Go programming language through its Cosmos SDK, and Cosmos itself is built in Go. Cosmos can also support other languages like Solidity or Rust for smart contracts.

**Fee Structure**

- Cosmos utilizes a dynamic fee system, where fees are determined based on network activity and transaction complexity.

## Comparison [​](\#comparison "Direct link to Comparison")

### Development [​](\#development "Direct link to Development")

* * *

Cosmos

- Cosmos uses the Cosmos SDK, a framework for building blockchain applications, built-in Go. This allows for easier development of custom blockchains using ready-built components.
- Supports multiple programming languages like Go, Rust, and Solidity
- Cosmos also has Starport, an interface that helps build and launch Cosmos blockchains. It provides tools for scaffolding, testing, and deployment.

Chromia

- Chromia uses Rell, a relational blockchain programming language. Rell can be a more user-friendly language than Go or Rust, making it easier for developers to build dapps on Chromia.
- Development on Chromia using Rell is very similar to Web2 development. For more insights on this, check out our guide [here](https://docs.chromia.com/category/rell-language).
- Chromia provides tools and libraries to simplify authentication, transaction signing, and asset management, and new features are added to support rapid dapp development.
- Chromia's development environment has support for testing using its own test framework and simple deployment using developer-friendly tools.

### Scalability [​](\#scalability "Direct link to Scalability")

* * *

Cosmos

- Cosmos scalability model is achieved through its architecture of zones and hubs.
  - Zones are individual blockchains that operate independently. Each zone can have its own governance consensus mechanism and can be tailored for specific use cases.
  - Hubs are blockchains that connect the zones together. The Cosmos Hub is the first and primary hub in the Cosmos network.
- IBC protocol is used for different blockchains to communicate and transfer value and data among each other

- Each zone in the Cosmos network processes transactions independently, allowing for parallel transaction processing. Zones can be optimized for specific tasks or applications, enhancing performance and efficiency.


Chromia

- Chromia's approach is that every dapp on Chromia operates on a unique subchain. Each subchain can handle about 500 transactions every second.
If a dapp witnesses growth, it can with ease be expanded by adding more chains.
This structure guarantees sustained high throughput and a predictable way of scaling your dapp, much like in a traditional cloud environment.

Since every subchain is isolated from other subchains, this means that you can process transactions in parallel. In essence, this means scaling horizontally
and only your app architecture sets the limit for scalability.

Chromia's sidechain architecture is built into the platform, making it a low effort for developers to utilize this approach of sidechains.


### Operational Costs & Fees [​](\#operational-costs--fees "Direct link to Operational Costs & Fees")

* * *

Cosmos

- In Cosmos, gas is a special unit that is used to track the consumption of resources during execution, much like a traditional Gas or transaction fee.
Gas is typically consumed whenever read and writes are made to the blockchain, but it can also be consumed if expensive computation needs to be done.

- Users have some flexibility in choosing the fee they pay, which can influence the priority or speed of transaction processing. But it is still the
end user that has to pay for actions on the Cosmos network.


Chromia

- Chromia changes the game by allowing developers to host their decentralized app (dapp) in a container for a fixed,
predictable fee. This transparency means developers know how much their operational costs are each month, and they can create their own end-user fee structures to cover these operational expenses.

So, instead of being charged gas fees for every action, there's a single, more manageable cost to work with.

- As a Chromia dapp grows in usage, the developer of the dapp can increase the resources of their container. Very similar to how
you manage resources in a Cloud environment.


### Revenue Models [​](\#revenue-models "Direct link to Revenue Models")

* * *

Cosmos

- Cosmos uses transaction fees for operations carried out on its network. Developers of decentralized applications on Cosmos have the option to add additional fees on transactions as a means of generating income.
- Validators in Cosmos can earn rewards through staking and participating in network security.

Chromia

- Operational costs of dapps are fixed and predictable on Chromia. The dapp developer can choose which fee model they want to use for their end-users.
With Chromia, you are not locked in by transactions and gas fees.

- For your dapp, you can have a monthly subscription fee, charge for single features, or, if you want, per transaction.
This opens up a more user-friendly experience since you can even let the user start for free and then
open up for revenues later when the user has found the value of your dapp. This is a common practice in traditional web applications and should be no different for Web3.


### Conclusion and Comparison Summary to Chromia [​](\#conclusion-and-comparison-summary-to-chromia "Direct link to Conclusion and Comparison Summary to Chromia")

* * *

In the evolving landscape of blockchain platforms, Cosmos and Chromia each present unique features and approaches.
Let's summarize and discuss the benefits and challenges.

### Architecture [​](\#architecture "Direct link to Architecture")

Cosmos uses its hub and zones model to enable an interconnected network of blockchains.
Its Cosmos SDK framework provides tools and modules that simplify the process of creating secure and scalable blockchains.
While zones are independent, their connection to the Cosmos Hub creates a certain level of dependency, which could be a point of failure.

Chromia offers simplicity with its development language Rell, extensive library and tool support, and its subchain architecture.
This makes it very accessible for traditional developers and provides a smooth transition into blockchain development.

### Scalability Considerations [​](\#scalability-considerations "Direct link to Scalability Considerations")

Cosmos achieves scalability through its network of independent zones, allowing for concurrent processing and efficient communication via the IBC protocol.

Zones in the Cosmos network can be specialized by tailoring their functionalities and governance models to suit specific use cases or industries.
This means they can be optimized for specific use cases, thereby making them more efficient for the targeted applications.

Chromia has a similar approach and offers a straightforward scalability solution.
Each dapp operates on its own subchain, capable of handling high transaction volumes. These subchains can be added as needed, which makes it scale very well.

Scalability can be easily managed through resource adjustments, which is very close to cloud services. Making the development and resource management effort more straightforward.
The ability to add subchains enables parallel execution of transactions, which gives the developer full control of scaling.

### Operational Costs & Fees [​](\#operational-costs--fees-1 "Direct link to Operational Costs & Fees")

Cosmos gas fee model might pose unpredictability in costs for developers and end-users. Since every transaction sent through the network comes with a fee, it will limit the way dapp developers
can set their revenue models and user experience. It will, for example, make a freemium model difficult to implement since there
will always be a transaction fee for the user.

Chromia, however, offers a fixed, predictable fee for hosting dapps.
This model not only simplifies budgeting for developers but also allows them to craft unique fee structures for end users,
enhancing the user experience.

### Revenue Models [​](\#revenue-models-1 "Direct link to Revenue Models")

Cosmos provides traditional blockchain revenue streams like staking and transaction fees, which are effective but may not offer the flexibility some developers seek.

Chromia, on the other hand, allows developers to choose their revenue models, from subscriptions to feature-based charges or even per-transaction fees.
This flexibility opens up creative revenue strategies that are more aligned with today's web apps.

### Final Words [​](\#final-words "Direct link to Final Words")

While Cosmos presents a powerful, scalable, and flexible blockchain ecosystem, Chromia distinguishes itself with its user-friendly approach, predictable cost model, and adaptable revenue strategies.
These features make Chromia an appealing option, particularly for developers seeking an easy entry into the blockchain space.

- [Cosmos](#cosmos-1)
- [Comparison](#comparison)
  - [Development](#development)
  - [Scalability](#scalability)
  - [Operational Costs & Fees](#operational-costs--fees)
  - [Revenue Models](#revenue-models)
  - [Conclusion and Comparison Summary to Chromia](#conclusion-and-comparison-summary-to-chromia)
  - [Architecture](#architecture)
  - [Scalability Considerations](#scalability-considerations)
  - [Operational Costs & Fees](#operational-costs--fees-1)
  - [Revenue Models](#revenue-models-1)
  - [Final Words](#final-words)[Skip to main content](#__docusaurus_skipToContent_fallback)

Now, we have the capability to buy mystery cards, in which you will receive a randomly minted collector card.

The next step is to extend the marketplace with functions for listing cards on the market and for users to buy and sell cards.

NFTbyte\_arrayidKeyaccountownerMutableindexownerIndexNFT\_CARDbyte\_arraynftKeyintegerstrengthintegerhealthLISTED\_NFTbyte\_arraynftKeybig\_integerpriceMutableaccountlisted\_byIndextimestamplisted\_dateDefault: op\_context.last\_block\_timeindexlisted\_byIndexis\_associated\_withlisted\_as

We start by adding the `listed_nft` entity.

rell\_marketplace/nft.rell

```codeBlockLines_e6Vv
entity listed_nft {
    key nft: nft;
    mutable price: big_integer;
    index listed_by: account;
    listed_date: timestamp = op_context.last_block_time;
}

```

This entity represents an NFT that's listed on the marketplace. It has a set price for the NFT for sale and a date when it was listed. Next, we will add an operation where users can list an NFT card they own.

rell\_marketplace/marketplace.rell

```codeBlockLines_e6Vv
operation list_nft(id: integer, price: big_integer) {
    val account = auth.authenticate();
    val (nft, owner) = nft @ { .rowid == rowid(id) } ( $, .owner );
    require(owner == account, "User must be owner of NFT");
    create listed_nft ( nft, price, owner );
}

```

What happens here is that the user sends a transaction to `list_nft` with the card NFT ID and the price.

- First, this operation requires the transaction to be signed by an FT4 account, which we verify using the authenticate method.
- Then, we query for the owner of the NFT, and we fetch the NFT entity.
- A check is done to make sure that the user listing the NFT is the owner of the NFT.
- If everything is okay, a new instance of `listed_nft` is created with NFT, price, and owner stored.

That's it. This way, users can list their NFTs on the marketplace. We can also add a query to ensure that we can fetch the listed NFTs.

rell\_marketplace/queries.rell

```codeBlockLines_e6Vv
enum card_sorting { NONE, PRICE_HIGH, PRICE_LOW }

query get_cards(amount: integer, card_sorting)
    = (listed_nft, nft_card) @* {
    listed_nft.nft == nft_card.nft
} (
    @omit @sort_desc when (card_sorting) {
          PRICE_HIGH -> .price;
          PRICE_LOW -> -.price;
          else -> nft_card.rowid.to_integer()
        },
    listed_nft_card_dto (
        price = listed_nft.price,
        id = nft_card.nft.rowid.to_integer(),
        card = nft_card.to_struct()
    )
) limit amount;

struct listed_nft_card_dto {
    id: integer;
    price: big_integer;
    card: struct<nft_card>;
}

```

Let's break this down a bit.

This query fetches NFTs listed on our marketplace. We can sort the result by price. The result is then structured using `listed_nft_card_dto`, where we specify which attributes to return from the result set.[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

For the delivery chain, we only need to think about two things: we want to keep track of which orders we should deliver
but must also take into account if, for some reason, the message is delayed such that the shipment becomes ready before
it was created. This would never happen in a real-life scenario, but we'll consider it in this example.

Let’s create a new module file `module.rell` in the `src/delivery_chain` directory to hold the following definition:

src/delivery\_chain/module.rell

```codeBlockLines_e6Vv
module;

```

Next, we need to define an enum in the `src/delivery_chain/entities.rell` file, that will contain three states associated
with an order: created, dispatched, and delivered.

src/delivery\_chain/entities.rell

```codeBlockLines_e6Vv
enum shipping_state {
    CREATED,
    DISPATCHED,
    DELIVERED
}

entity delivery {
    key order_id: integer;
    index customer_id: integer;
    shipping_address: text;
    mutable shipping_state;
}

// orders that can be dispatched but have not yet been created
entity pending_delivery {
    key order_id: integer;
}

```

Add a new operation to the `src/delivery_chain/operations.rell` file to change the status of the shipment to be delivered:

src/delivery\_chain/operations.rell

```codeBlockLines_e6Vv
operation accept_delivery(order_id: integer) {
    require(delivery @ { order_id }.shipping_state == shipping_state.DISPATCHED, "Order must be dispatched before it can be completed");
    update delivery @ { order_id } ( shipping_state = shipping_state.DELIVERED);
}

```

To get the current delivery status, you have to add the corresponding query to the `src/selivery_chain?queries.rell` file:

src/delivery\_chain/queries.rell

```codeBlockLines_e6Vv
query get_delivery_details(order_id: integer) = delivery @* { order_id } ($.to_struct());

query list_deliveries() = delivery @* {} ($.to_struct());

```

## Receiving a message [​](\#receiving-a-message "Direct link to Receiving a message")

To be able to receive a message, we must first configure our new blockchain and add a reference to the `receiver` that
we defined in the Introduction section. Add the following `delivery_chain` details to the `blockchains` property in the
`chromia.yml` file:

chromia.yml

```codeBlockLines_e6Vv
blockchains:
  # ↓↓↓ Add this code snippet ↓↓↓
  delivery-chain:
    module: delivery_chain
    config:
      <<: *receiver
      icmf:
        receiver:
          local:
            - topic: "L_delivery"
              brid: null
            - topic: "L_shipment_ready"
              brid: null
  # ↑↑↑ Add this code snippet ↑↑↑

```

In this configuration, we make the dapp subscribe to the topics `L_delivery` and `L_shipment_ready`, as defined by our
dapp code. The `brid` should point to the producer of the message topic, but since we have not deployed our dapp to the
network yet, we leave it as `null`.

info

Note that `null` only works when testing locally. When deploying to a real network, the producer chain must be
deployed first to obtain the `brid` to be specified in this field.

To handle two message types, we add the following imports to the `src/delivery_chain/module.rell` file:

src/delivery\_chain/module.rell

```codeBlockLines_e6Vv
import messages. { topic.*, msg };
import lib.icmf.receiver.{ receive_icmf_message };

```

We also define a new extension called `receive_icmf_message` in the `functions.rell` file:

src/delivery\_chain/functions.rell

```codeBlockLines_e6Vv
@extend(receive_icmf_message)
function (sender: byte_array, topic: text, body: gtv) {
    when (topic) {
        NEW_DELIVERY -> handle_new_delivery(msg.delivery_details.from_gtv(body));
        SHIPMENT_READY -> handle_shipment_ready(msg.shipment_ready.from_gtv(body));
        else -> require(false, "Message type %s not handled".format(topic));
    }
}

function handle_new_delivery(msg: msg.delivery_details) {
    val state = pending_delivery @? { msg.order_id } (shipping_state.DISPATCHED) ?: shipping_state.CREATED;
    create delivery(
        order_id = msg.order_id,
        customer_id = msg.customer_id,
        shipping_address = msg.shipping_address,
        shipping_state = state
    );
    delete pending_delivery @? { msg.order_id };
}

function handle_shipment_ready(msg: msg.shipment_ready) {
    if (not exists(delivery @? { .order_id == msg.order_id })) {
        create pending_delivery ( msg.order_id );
    } else {
        update delivery @ { .order_id == msg.order_id } ( shipping_state = shipping_state.DISPATCHED );
    }
}

```

The extension checks the topic and switches behavior accordingly. If the message topic is not handled, we fail the
operation, halting the block building process due to incorrect configuration. We handle two message types by creating or
updating entities to mark the delivery with the correct state.

## Testing [​](\#testing "Direct link to Testing")

To test the delivery chain, we need to add new configuration details to the `chromia.yaml` file. Insert the `test`
property under the `delivery_chain` section, along with the necessary details.

chromia.yml

```codeBlockLines_e6Vv
blockchains:
  delivery-chain:
    # ↓↓↓ Add this code snippet ↓↓↓
    test:
      modules:
        - test.delivery_chain_test
    # ↑↑↑ Add this code snippet ↑↑↑

```

We then create a test that emits events using ICMF test utilities and ensures that the correct shipment orders and
states are created. Create a file called `delivery_chain_test.rell` in the `src/test` directory and insert the following
code:

src/test/delivery\_chain\_test.rell

```codeBlockLines_e6Vv
@test module;

import delivery_chain.{ delivery, accept_delivery, shipping_state };
import messages.{ msg, topic };
import lib.icmf.test.{ test_icmf_message };

function test_make_delivery() {
    rell.test.tx().op(
            test_icmf_message(
                x"",
                topic.NEW_DELIVERY,
                msg.delivery_details(
                    order_id = 1,
                    customer_id = 10,
                    shipping_address = "MyStreet 101"
                )
                    .to_gtv()
            )
        )
        .run();
    assert_equals(delivery @ { .order_id == 1 }.shipping_state, shipping_state.CREATED);
    rell.test.tx().op(accept_delivery(1)).run_must_fail("must be dispatched before");
    rell.test.tx().op(
            test_icmf_message(
                x"",
                topic.SHIPMENT_READY,
                msg.shipment_ready(order_id = 1)
                    .to_gtv()
            )
        )
        .run();
    assert_equals(delivery @ { .order_id == 1 }.shipping_state, shipping_state.DISPATCHED);
    rell.test.tx().op(accept_delivery(1)).run();
}

```

Then run the `chr test` command to verify the test results.

```codeBlockLines_e6Vv
Running tests for chain: delivery-chain
TEST: order_chain_test:test_make_delivery
OK: order_chain_test:test_make_order (0,837s)

------------------------------------------------------------
TEST RESULTS:

OK delivery_chain_test:delivery_make_order

SUMMARY: 0 FAILED / 1 PASSED / 1 TOTAL (0,837s)

```

Below are the project structure and the contents of the `chromia.yml` configuration file after the changes have been made.
It can be handy for comparison at this stage of the course:

Project structure

```codeBlockLines_e6Vv
order-system-example/
├── build/
├── src/
│   ├── delivery_chain/
│   │   ├── entities.rell
│   │   ├── functions.rell
│   │   ├── module.rell
│   │   ├── operations.rell
│   │   └── queries.rell
│   ├── lib/
│   ├── order_chain/
│   │   ├── entities.rell
│   │   ├── functions.rell
│   │   ├── module.rell
│   │   ├── operations.rell
│   │   └── queries.rell
│   ├── test/
│   │   ├── delivery_chain_test.rell
│   │   └── order_chain_test.rell
│   └── messages.rell
├── .gitignore
└── chromia.yml

```

Final version of the `chromia.yml`

chromia.yml

```codeBlockLines_e6Vv
definitions:
  - &sender # Configuration for a chain that sends messages
    gtx:
      modules:
        - "net.postchain.d1.icmf.IcmfSenderGTXModule"
  - &receiver # Base configuration for a chain that receives messages
    gtx:
      modules:
        - "net.postchain.d1.icmf.IcmfReceiverGTXModule"
    sync_ext:
      - "net.postchain.d1.icmf.IcmfReceiverSynchronizationInfrastructureExtension"
  - &sender_receiver # Base configuration for a chain that will both send and receive messages
    gtx:
      modules:
        - "net.postchain.d1.icmf.IcmfSenderGTXModule"
        - "net.postchain.d1.icmf.IcmfReceiverGTXModule"
    sync_ext:
      - "net.postchain.d1.icmf.IcmfReceiverSynchronizationInfrastructureExtension"
blockchains:
  order-chain:
    module: order_chain
    config:
      <<: *sender
    test:
      modules:
        - test.order_chain_test
  delivery-chain:
    module: delivery_chain
    config:
      <<: *receiver
      icmf:
        receiver:
          local:
            - topic: "L_delivery"
              brid: null
            - topic: "L_shipment_ready"
              brid: null
    test:
      modules:
        - test.delivery_chain_test
compile:
  rellVersion: 0.13.5
database:
  schema: schema_order_system_example
libs:
  icmf:
    registry: https://gitlab.com/chromaway/core/directory-chain
    path: src/messaging/icmf
    tagOrBranch: 1.29.0
    rid: x"19D6BC28D527E6D2239843608486A84F44EDCD244E253616F13D1C65893F35F6"

```

- [Receiving a message](#receiving-a-message)
- [Testing](#testing)[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

In this section, we'll learn how to structure the results from queries in Chromia. This approach can be beneficial when
you need to fetch complex data, such as combining book information with associated reviews.

To achieve this, we'll create a `book_review_dto` struct to encapsulate the book details and the review information.
We'll then update our query to return this structured data.

### Define the struct [​](\#define-the-struct "Direct link to Define the struct")

We will define a new struct, `book_review_dto`, which will contain the book information and review details. This struct
should be added to the `src/main/entities.rell` file, which is appropriate for defining such data structures.

Open the `src/main/entities.rell` file and add the following code:

src/main/entities.rell

```codeBlockLines_e6Vv
struct book_review_dto {
  book: struct<book>;
  reviewer_name: text;
  review: text;
  rating: integer;
}

```

### Update the query [​](\#update-the-query "Direct link to Update the query")

Next, we'll modify the `get_all_reviews_for_book` query to use the `book_review_dto` struct. This will allow us to
include both book and review information in a single query result.

Open the `src/main/queries.rell` file and update the query as follows:

src/main/queries.rell

```codeBlockLines_e6Vv
query get_all_reviews_for_book(isbn: text) {
  require(book @? { .isbn == isbn }, "Book with isbn %s not found".format(isbn));
  val reviews = book_review @* { .book.isbn == isbn } (
    book_review_dto(
      book = .book.to_struct(),
      .reviewer_name,
      .review,
      .rating
    )
  );
  return reviews;
}

```

### Explanation [​](\#explanation "Direct link to Explanation")

1. **Struct Definition:** The `book_review_dto` struct combines the book and review details into a single unit, making
it easier to manage related information together.

2. **Updated Query:**
   - The `require` function checks that the book with the specified `isbn` exists.
   - The query `book_review @* { .book.isbn == isbn }` fetches all reviews for the specified book.
   - We use the `book_review_dto` struct to structure the result. The `book` attribute of the struct is populated using
     `book_review.book.to_struct()` converts the `book` field into a structured format.

### Testing the update [​](\#testing-the-update "Direct link to Testing the update")

To ensure that everything is working as expected, follow these steps:

1. **Update the node:**

If you have a Chromia node running, update it with the latest version of your dapp:





```codeBlockLines_e6Vv
chr node update

```









If the node is not running, start it with:





```codeBlockLines_e6Vv
chr node start

```











note





If you update the node while it is running, it might take a moment for the changes to propagate. You may need to wait
for the next block for the update to be fully effective.

2. **Run the query:**

Execute the query using the Chromia CLI:





```codeBlockLines_e6Vv
chr query get_all_reviews_for_book "isbn=ISBN1234"

```









The expected output should look something like this:





```codeBlockLines_e6Vv
[\
     {\
       "book": {\
         "author": "George Orwell",\
         "isbn": "ISBN1234",\
         "title": "1984"\
       },\
       "rating": 5,\
       "review": "It was a great book",\
       "reviewer_name": "Alice"\
     }\
]

```


### Summary [​](\#summary "Direct link to Summary")

In this lesson, we added a `book_review_dto` struct to combine book and review details into a structured format. We
updated the query to return this structured data, making it easier to handle and display in client applications. This
approach improves the organization and usability of the data you retrieve from the blockchain.

- [Define the struct](#define-the-struct)
- [Update the query](#update-the-query)
- [Explanation](#explanation)
- [Testing the update](#testing-the-update)
- [Summary](#summary)
